From 0bede702528103a67cf2eb646189375e8cf715f3 Mon Sep 17 00:00:00 2001
From: Jiaming Huang <jiaming.huang@amlogic.com>
Date: Fri, 12 Jun 2015 17:17:53 +0800
Subject: [PATCH 5654/5965] PD#107155: lcd :add lcd driver for g9tv

Change-Id: I10732d6b40d793fdd542bf3118d19e689ce545f7
---
 arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd  |  10 -
 drivers/amlogic/display/lcd/Makefile          |   4 +-
 drivers/amlogic/display/lcd/aml_tv_lcd.c      | 606 ++++++++++++++++++
 drivers/amlogic/display/lcd/aml_tv_lcd.h      | 196 ++++++
 .../display/lcd/aml_tv_lcd_port/Makefile      |   4 +
 .../display/lcd/aml_tv_lcd_port/lcd_common.c  | 196 ++++++
 .../display/lcd/aml_tv_lcd_port/lcd_common.h  |  42 ++
 .../display/lcd/aml_tv_lcd_port/lvds_drv.c    | 194 ++++++
 .../display/lcd/aml_tv_lcd_port/ttl_drv.c     | 156 +++++
 .../display/lcd/aml_tv_lcd_port/vbyone_drv.c  | 407 ++++++++++++
 10 files changed, 1803 insertions(+), 12 deletions(-)
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd.c
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd.h
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd_port/Makefile
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd_port/ttl_drv.c
 create mode 100644 drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c

diff --git a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
index 6b89d6c31851..7c20b9df0ea7 100644
--- a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
@@ -730,8 +730,6 @@
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
-			blacklight_power_pin ="GPIOY_6";
-			blacklight_power_att =<1 0 600 200>;/** on off on_delay off_delay*/
 		};
 
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
@@ -742,8 +740,6 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
-			blacklight_power_pin ="GPIOY_6";
-			blacklight_power_att =<1 0 600 200>;/** on off on_delay off_delay*/
 		};
 
 		/*BOE: HV320WHB-N80 lvds : 1366x768@60hz 8bit pixel clk@74.25mhz 1port*/
@@ -754,8 +750,6 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
-			blacklight_power_pin ="GPIOY_6";
-			blacklight_power_att =<1 0 600 200>;/** on off on_delay off_delay*/
 		};
 
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
@@ -766,8 +760,6 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
-			blacklight_power_pin ="GPIOY_6";
-			blacklight_power_att =<1 0 600 200>;/** on off on_delay off_delay*/
 		};
 
 		/*BOE: HV550QU2-305 vx1 : 3840x2160@60hz 8lane pixel clk@74.5mhz */
@@ -778,8 +770,6 @@
 			vbyone_att = <8 4 2 4>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
-			blacklight_power_pin ="GPIOY_6";
-			blacklight_power_att =<1 0 600 200>;/** on off on_delay off_delay*/
 		};
 	};
 
diff --git a/drivers/amlogic/display/lcd/Makefile b/drivers/amlogic/display/lcd/Makefile
index 8d3e7e033c0c..eefc533bc83a 100644
--- a/drivers/amlogic/display/lcd/Makefile
+++ b/drivers/amlogic/display/lcd/Makefile
@@ -4,5 +4,5 @@
 
 obj-y							+= lcd_notify.o
 obj-$(CONFIG_AML_TV_LCD)		+= aml_lcd.o
-obj-$(CONFIG_AML_TV_LCD_V2)		+= aml_lcd_v2.o
-
+obj-$(CONFIG_AML_TV_LCD_V2)		+= aml_tv_lcd.o
+obj-$(CONFIG_AML_TV_LCD_V2)  += aml_tv_lcd_port/
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd.c b/drivers/amlogic/display/lcd/aml_tv_lcd.c
new file mode 100644
index 000000000000..b515073a9781
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd.c
@@ -0,0 +1,606 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <mach/register.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/display/lcd.h>
+
+#include "aml_tv_lcd.h"
+
+#define PANEL_NAME		"panel"
+
+extern unsigned int lvds_init(Lcd_Config_t *pConf);
+extern unsigned int vbyone_init(Lcd_Config_t *pConf);
+
+extern void _disable_display_driver(void);
+
+static char lcd_propname[30] = "lvds_0";
+
+static const char* lcd_type_table[]={
+	"LVDS",
+	"vbyone",
+	"TTL",
+	"invalid",
+};
+
+unsigned int (*init_lcd_port[])(Lcd_Config_t *pConf) = {
+	lvds_init,
+	vbyone_init,
+};
+
+//**** Special parameters just for Vbyone ***//
+static Vbyone_Config_t lcd_vbyone_config={
+	.lane_count = 8,	//lane:  1/2/4/6/8 lanes;
+	.byte		= 4,	//byte:  3/4/5 bytes;
+	.region		= 2,	//region
+	.color_fmt	= 4,	//color_fmt
+};
+
+//**** Special parameters just for lvds ***//
+static Lvds_Config_t lcd_lvds_config={
+	.lvds_bits		= 8,	//6/8/10 bit
+	.lvds_repack	= 1,	//0->JEDIA mode,  1->VESA mode
+	.pn_swap		= 0,	//0->normal,         1->swap
+	.dual_port		= 1,	//0->single lvds,	1->double lvds
+	.port_reverse	= 1,
+	.lvds_fifo_wr_mode	= 0x3, //fifo:0x3->double,  0x101->single
+};
+
+//****panel power control only for uboot ***//
+static Panel_Power_Config_t lcd_panel_power =
+{
+	.gpio		=	GPIOH_10,		/** panel power control gpio port */
+	.on_value	=	1,				/** panel power on gpio out value*/
+	.off_value	=	0,				/** panel power off gpio out value*/
+	.panel_on_delay		=	50,		/** panel power on delay time (unit: ms)*/
+	.panel_off_delay	=	50 		/** panel power off delay time (unit: ms)*/
+};
+
+Lcd_Config_t lcd_config_dft =
+{
+	.lcd_basic = {
+		.lcd_type = LCD_DIGITAL_LVDS,	//LCD_DIGITAL_TTL /LCD_DIGITAL_LVDS/LCD_DIGITAL_VBYONE
+		.h_active = 1920,
+		.v_active = 1080,
+		.h_period = 2200,
+		.v_period = 1125,
+		.video_on_pixel = 148,
+		.video_on_line  = 41,
+		.screen_ratio_width   = 16,
+		.screen_ratio_height  = 9,
+	},
+
+	.lcd_timing = {
+		.hpll_clk = 0x500404ad,  //0x10c8 : N->bits[13:9]       M->bits[8:0]
+		.hpll_od = 0x00414400,   //0x10c9 : od1->bits[17:16]   od2->bits[23:22]   od3->bits[19:18]
+		.hdmi_pll_cntl5 = 0x71486900,
+
+		.sth1_hs_addr = 44,
+		.sth1_he_addr = 2156,
+		.sth1_vs_addr = 0,
+		.sth1_ve_addr = 1125 - 1,
+		.stv1_hs_addr = 2100,
+		.stv1_he_addr = 2164,
+		.stv1_vs_addr = 3,
+		.stv1_ve_addr = 5,
+	},
+
+	.lcd_control = {
+		.lvds_config	=	&lcd_lvds_config,
+		.vbyone_config	=	&lcd_vbyone_config,
+	},
+
+	.lcd_power_ctrl = {
+		.panel_power	=	&lcd_panel_power,
+	},
+};
+
+
+#ifdef CONFIG_USE_OF
+static inline int aml_lcd_get_property_string(struct device_node *np,
+									   const char *propname,
+									   const char **out_string)
+{
+	int ret;
+
+	ret = of_property_read_string(np, propname, out_string);
+	if (ret) {
+		TV_LCD_ERR("faild to get %s !\n",propname);
+		*out_string = "invalid";
+	}
+
+	return ret;
+}
+
+static inline int aml_lcd_get_property_array(struct device_node* of_node,
+												const char *propname,
+												u32 *out_values, size_t sz)
+{
+	int ret;
+
+	ret= of_property_read_u32_array(of_node,propname,out_values,sz);
+	if (ret)
+		TV_LCD_ERR("faild to get %s !\n",propname);
+
+	return ret;
+}
+
+static int _get_lcd_config(struct platform_device *pdev)
+{
+	struct aml_lcd *pDev;
+	struct device_node* of_node = pdev->dev.of_node;
+	struct device_node* child;
+	const char *str;
+	unsigned int val;
+	unsigned int *lcd_para = NULL;
+
+	pDev = platform_get_drvdata(pdev);
+
+	lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*20, GFP_KERNEL);
+
+	memset(lcd_para, 0, sizeof(*lcd_para));
+	if (lcd_para == NULL) {
+		kfree(lcd_para);
+		TV_LCD_ERR("Not enough memory\n");
+		return -EINVAL;
+	}
+
+	if (of_node) {
+		child = of_get_child_by_name(of_node,lcd_propname);
+		if (child == NULL) {
+			kfree(lcd_para);
+			TV_LCD_ERR("faild to get lcd_model_config!! \n");
+			return -EINVAL;
+		}
+
+		if (!aml_lcd_get_property_string(child, "interface", &str)) {
+			for (val = 0; val < LCD_TYPE_MAX; val++) {
+				if (!strcasecmp(str, lcd_type_table[val]))
+					break;
+			}
+			pDev->pConf->lcd_basic.lcd_type = val;
+		}
+
+		if (!aml_lcd_get_property_array(child, "basic_setting", &lcd_para[0], 6)) {
+			pDev->pConf->lcd_basic.h_active = lcd_para[0];
+			pDev->pConf->lcd_basic.v_active = lcd_para[1];
+			pDev->pConf->lcd_basic.h_period = lcd_para[2];
+			pDev->pConf->lcd_basic.v_period = lcd_para[3];
+			pDev->pConf->lcd_basic.video_on_pixel = lcd_para[4];
+			pDev->pConf->lcd_basic.video_on_line = lcd_para[5];
+		}
+
+		if (!aml_lcd_get_property_array(child, "lcd_timing", &lcd_para[0], 11)) {
+			pDev->pConf->lcd_timing.hpll_clk = lcd_para[0];
+			pDev->pConf->lcd_timing.hpll_od  = lcd_para[1];
+			pDev->pConf->lcd_timing.hdmi_pll_cntl5 = lcd_para[2];
+			pDev->pConf->lcd_timing.sth1_hs_addr	 = lcd_para[3];
+			pDev->pConf->lcd_timing.sth1_he_addr	 = lcd_para[4];
+			pDev->pConf->lcd_timing.sth1_vs_addr	 = lcd_para[5];
+			pDev->pConf->lcd_timing.sth1_ve_addr	 = lcd_para[6];
+			pDev->pConf->lcd_timing.stv1_hs_addr	 = lcd_para[7];
+			pDev->pConf->lcd_timing.stv1_he_addr	 = lcd_para[8];
+			pDev->pConf->lcd_timing.stv1_vs_addr	 = lcd_para[9];
+			pDev->pConf->lcd_timing.stv1_ve_addr	 = lcd_para[10];
+		}
+
+		if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+			if (!aml_lcd_get_property_array(child, "lvds_att", &lcd_para[0], 6)) {
+				pDev->pConf->lcd_control.lvds_config->lvds_bits	 = lcd_para[0];
+				pDev->pConf->lcd_control.lvds_config->lvds_repack  = lcd_para[1];
+				pDev->pConf->lcd_control.lvds_config->pn_swap 	 = lcd_para[2];
+				pDev->pConf->lcd_control.lvds_config->dual_port	 = lcd_para[3];
+				pDev->pConf->lcd_control.lvds_config->port_reverse		 = lcd_para[4];
+				pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode	 = lcd_para[5];
+			}
+		} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
+			if (!aml_lcd_get_property_array(child, "vbyone_att", &lcd_para[0], 4)) {
+				pDev->pConf->lcd_control.vbyone_config->lane_count	 = lcd_para[0];
+				pDev->pConf->lcd_control.vbyone_config->byte		= lcd_para[1];
+				pDev->pConf->lcd_control.vbyone_config->region		= lcd_para[2];
+				pDev->pConf->lcd_control.vbyone_config->color_fmt 	= lcd_para[3];
+			}
+		} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+
+		}
+	}
+
+	TV_LCD_INFO("lcd_type = %s(%s)\n", lcd_type_table[pDev->pConf->lcd_basic.lcd_type],lcd_propname);
+	TV_LCD_INFO("h_active = %u, v_active = %u \n", pDev->pConf->lcd_basic.h_active, pDev->pConf->lcd_basic.v_active);
+	TV_LCD_INFO("h_period = %u, v_period = %u \n", pDev->pConf->lcd_basic.h_period, pDev->pConf->lcd_basic.v_period );
+	TV_LCD_INFO("video_on_pixel = %u, video_on_line = %u \n", pDev->pConf->lcd_basic.video_on_pixel, pDev->pConf->lcd_basic.video_on_line);
+	TV_LCD_INFO("hpll_clk = %x, hpll_od =%x hdmi_pll_cntl5 = %x \n", pDev->pConf->lcd_timing.hpll_clk, pDev->pConf->lcd_timing.hpll_od, pDev->pConf->lcd_timing.hdmi_pll_cntl5);
+	TV_LCD_INFO("sth1_hs_addr = %u, sth1_he_addr = %u \n", pDev->pConf->lcd_timing.sth1_hs_addr, pDev->pConf->lcd_timing.sth1_he_addr);
+	TV_LCD_INFO("sth1_vs_addr = %u, sth1_ve_addr = %u \n", pDev->pConf->lcd_timing.sth1_vs_addr, pDev->pConf->lcd_timing.sth1_ve_addr);
+	TV_LCD_INFO("stv1_hs_addr = %u, stv1_he_addr = %u \n", pDev->pConf->lcd_timing.stv1_hs_addr, pDev->pConf->lcd_timing.stv1_he_addr);
+	TV_LCD_INFO("stv1_vs_addr = %u, stv1_ve_addr = %u \n", pDev->pConf->lcd_timing.stv1_vs_addr, pDev->pConf->lcd_timing.stv1_ve_addr);
+
+	if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+		TV_LCD_INFO("lvds_bits = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_bits);
+		TV_LCD_INFO("lvds_repack = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_repack);
+		TV_LCD_INFO("pn_swap = %d \n",pDev->pConf->lcd_control.lvds_config->pn_swap);
+		TV_LCD_INFO("dual_port = %d \n",pDev->pConf->lcd_control.lvds_config->dual_port);
+		TV_LCD_INFO("port_reverse = %d \n",pDev->pConf->lcd_control.lvds_config->port_reverse);
+		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
+	} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
+		TV_LCD_INFO("lvds_bits = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_bits);
+		TV_LCD_INFO("lvds_repack = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_repack);
+		TV_LCD_INFO("pn_swap = %d \n",pDev->pConf->lcd_control.lvds_config->pn_swap);
+		TV_LCD_INFO("dual_port = %d \n",pDev->pConf->lcd_control.lvds_config->dual_port);
+		TV_LCD_INFO("port_reverse = %d \n",pDev->pConf->lcd_control.lvds_config->port_reverse);
+		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
+	} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+
+	}
+
+	kfree(lcd_para);
+
+	return 0;
+}
+
+static int _get_lcd_power_config(struct platform_device *pdev)
+{
+	struct aml_lcd *pDev;
+	struct device_node* of_node = pdev->dev.of_node;
+	struct device_node* child;
+
+	const char *str;
+	unsigned int panel_power_pin;
+	unsigned int *lcd_para = NULL;
+
+	pDev = platform_get_drvdata(pdev);
+
+	lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*20, GFP_KERNEL);
+
+	if (lcd_para == NULL) {
+		TV_LCD_ERR("Not enough memory\n");
+		return -EINVAL;
+	}
+	memset(lcd_para, 0, sizeof(*lcd_para));
+
+	if (of_node) {
+		child = of_get_child_by_name(of_node,lcd_propname);
+		if (child == NULL) {
+			kfree(lcd_para);
+			TV_LCD_ERR("faild to get lcd_model_config!! \n");
+			return -EINVAL;
+		}
+		if (!aml_lcd_get_property_string(child, "panel_power_pin", &str)) {
+			panel_power_pin = amlogic_gpio_name_map_num(str);
+			if (panel_power_pin<0) {
+				kfree(lcd_para);
+				TV_LCD_ERR("wrong gpio number %s\n",str);
+				return -EINVAL;
+			}
+			pDev->pConf->lcd_power_ctrl.panel_power->gpio	= panel_power_pin;
+		}
+
+		if (!aml_lcd_get_property_array(child, "panel_power_att", &lcd_para[0], 4)) {
+			pDev->pConf->lcd_power_ctrl.panel_power->on_value  = lcd_para[0];
+			pDev->pConf->lcd_power_ctrl.panel_power->off_value = lcd_para[1];
+			pDev->pConf->lcd_power_ctrl.panel_power->panel_on_delay = lcd_para[2];
+			pDev->pConf->lcd_power_ctrl.panel_power->panel_off_delay = lcd_para[3];
+		}
+
+		TV_LCD_INFO("panel_power_pin: %s--%d \n",str,pDev->pConf->lcd_power_ctrl.panel_power->gpio);
+		TV_LCD_INFO("on_value = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->on_value);
+		TV_LCD_INFO("off_value = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->off_value);
+		TV_LCD_INFO("panel_on_delay = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->panel_on_delay);
+		TV_LCD_INFO("panel_off_delay = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->panel_off_delay);
+	}
+
+	kfree(lcd_para);
+
+return 0;
+
+}
+#endif
+
+static void panel_power_ctrl(Bool_t status)
+{
+	const char *owner = "aml_tv_lcd";
+	Lcd_Config_t *pConf;
+	pConf = &lcd_config_dft;
+
+	TV_LCD_INFO("statu=%s gpio=%d value=%d \n",(status ? "ON" : "OFF"),
+		pConf->lcd_power_ctrl.panel_power->gpio,
+		(status ?pConf->lcd_power_ctrl.panel_power->on_value:
+				pConf->lcd_power_ctrl.panel_power->off_value));
+
+	if (ON == status) {
+		amlogic_gpio_request(pConf->lcd_power_ctrl.panel_power->gpio,owner);
+		amlogic_gpio_direction_output(pConf->lcd_power_ctrl.panel_power->gpio,
+									   pConf->lcd_power_ctrl.panel_power->on_value,owner);
+		mdelay(pConf->lcd_power_ctrl.panel_power->panel_on_delay);
+
+	} else {
+		amlogic_gpio_request(pConf->lcd_power_ctrl.panel_power->gpio,owner);
+		amlogic_gpio_direction_output(pConf->lcd_power_ctrl.panel_power->gpio,
+									  pConf->lcd_power_ctrl.panel_power->off_value,owner);
+		mdelay(pConf->lcd_power_ctrl.panel_power->panel_off_delay);
+	}
+}
+
+static inline void _init_display_driver(Lcd_Config_t *pConf_t)
+{
+	if (pConf_t->lcd_basic.lcd_type < LCD_TYPE_MAX) {
+		init_lcd_port[pConf_t->lcd_basic.lcd_type](pConf_t);
+	} else {
+		TV_LCD_ERR("no lcd port\n");
+		init_lcd_port[LCD_DIGITAL_LVDS](pConf_t);
+	}
+}
+
+static void _lcd_module_enable(void)
+{
+	_init_display_driver(&lcd_config_dft);
+}
+
+DEFINE_MUTEX(lcd_vout_mutex);
+
+static const vinfo_t *lcd_get_current_info(void)
+{
+   return NULL;
+}
+
+
+static int lcd_set_current_vmode(vmode_t mode)
+{
+    mutex_lock(&lcd_vout_mutex);
+    if (mode != VMODE_LCD) {
+        mutex_unlock(&lcd_vout_mutex);
+        return -EINVAL;
+    }
+
+    _lcd_module_enable();
+    mutex_unlock(&lcd_vout_mutex);
+
+    return 0;
+}
+
+static vmode_t lcd_validate_vmode(char *mode)
+{
+    if (mode == NULL)
+        return VMODE_MAX;
+
+    if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
+        return VMODE_LCD;
+
+    return VMODE_MAX;
+}
+
+static int lcd_vmode_is_supported(vmode_t mode)
+{
+    mode &= VMODE_MODE_BIT_MASK;
+    if ( mode == VMODE_LCD )
+		return true;
+
+    return false;
+}
+
+static int lcd_vout_disable(vmode_t cur_vmod)
+{
+    return 0;
+}
+
+#ifdef  CONFIG_PM
+static int lcd_suspend(int pm_event)
+{
+	TV_LCD_INFO("lcd_suspend \n");
+    /* in freeze process do not turn off the display devices */
+    if (pm_event == PM_EVENT_FREEZE)
+        return 0;
+
+    _disable_display_driver();
+
+    return 0;
+}
+static int lcd_resume(int pm_event)
+{
+    TV_LCD_INFO("lcd_resume\n");
+    /* in thaw/restore process do not reset the display mode */
+    if (pm_event == PM_EVENT_THAW
+         || pm_event == PM_EVENT_RESTORE)
+        return 0;
+
+    lcd_set_current_vmode(VMODE_LCD);
+
+    return 0;
+}
+#endif
+
+static vout_server_t lcd_vout_server={
+    .name = "lcd_vout_server",
+    .op = {
+        .get_vinfo = lcd_get_current_info,
+        .set_vmode = lcd_set_current_vmode,
+        .validate_vmode = lcd_validate_vmode,
+        .vmode_is_supported=lcd_vmode_is_supported,
+        .disable=lcd_vout_disable,
+#ifdef  CONFIG_PM
+        .vout_suspend=lcd_suspend,
+        .vout_resume=lcd_resume,
+#endif
+    },
+};
+
+static void _init_vout(struct platform_device *pdev)
+{
+	struct aml_lcd *pDev;
+	pDev = platform_get_drvdata(pdev);
+
+    pDev->lcd_info.name = PANEL_NAME;
+    pDev->lcd_info.mode = VMODE_LCD;
+    pDev->lcd_info.width = pDev->pConf->lcd_basic.h_active;
+    pDev->lcd_info.height = pDev->pConf->lcd_basic.v_active;
+    pDev->lcd_info.field_height = pDev->pConf->lcd_basic.v_active;
+    pDev->lcd_info.aspect_ratio_num = pDev->pConf->lcd_basic.screen_ratio_width;
+    pDev->lcd_info.aspect_ratio_den = pDev->pConf->lcd_basic.screen_ratio_height;
+    pDev->lcd_info.screen_real_width= pDev->pConf->lcd_basic.h_active_area;
+    pDev->lcd_info.screen_real_height= pDev->pConf->lcd_basic.v_active_area;
+    pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
+    pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
+
+	aml_write_reg32(P_VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
+
+	vout_register_server(&lcd_vout_server);
+}
+
+static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
+ {
+	TV_LCD_INFO("state=%lu\n",state);
+//	if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0)
+//		return NOTIFY_DONE;
+	lcd_notifier_call_chain(LCD_EVENT_POWEROFF, NULL);
+	_disable_display_driver();
+	panel_power_ctrl(OFF);
+
+	return NOTIFY_OK;
+}
+
+
+static struct notifier_block lcd_reboot_nb;
+static int lcd_probe(struct platform_device *pdev)
+{
+	unsigned int ret = 0;
+	struct aml_lcd *pDev;
+
+	pDev = (struct aml_lcd *)kmalloc(sizeof(struct aml_lcd), GFP_KERNEL);
+	if (!pDev) {
+		TV_LCD_ERR("lcd error: Not enough memory.\n");
+		return -ENOMEM;
+	}
+	memset(pDev, 0, sizeof(*pDev));
+
+	platform_set_drvdata(pdev, pDev);
+	pDev->pdev = pdev;
+
+	pDev->pConf = &lcd_config_dft;
+	pDev->pConf->lcd_control.lvds_config = (Lvds_Config_t *)(lcd_config_dft.lcd_control.lvds_config);
+	pDev->pConf->lcd_control.vbyone_config = (Vbyone_Config_t *)(lcd_config_dft.lcd_control.vbyone_config);
+	pDev->pConf->lcd_power_ctrl.panel_power = (Panel_Power_Config_t *)(lcd_config_dft.lcd_power_ctrl.panel_power);
+
+	if (_get_lcd_config(pdev)) {
+		kfree(pDev);
+		TV_LCD_ERR("can not find lcd dtd config \n");
+		return -ENOMEM;
+	}
+	if (_get_lcd_power_config(pdev)) {
+		kfree(pDev);
+		TV_LCD_ERR("can not find panel power dtd config \n");
+		return -ENOMEM;
+	}
+
+	//panel_power_ctrl(ON);
+	//udelay(50);
+	_init_vout(pdev);
+	//lcd_set_current_vmode(VMODE_LCD);
+	//lcd_notifier_call_chain(LCD_EVENT_POWERON, NULL);
+
+	lcd_reboot_nb.notifier_call = lcd_reboot_notifier;
+	ret = register_reboot_notifier(&lcd_reboot_nb);
+	if (ret) {
+		TV_LCD_ERR("notifier register lcd_reboot_notifier fail!\n");
+	}
+
+	TV_LCD_INFO("LCD probe ok\n");
+
+	return 0;
+}
+
+static int lcd_remove(struct platform_device *pdev)
+{
+	struct aml_lcd *pDev = platform_get_drvdata(pdev);
+
+	unregister_reboot_notifier(&lcd_reboot_nb);
+	platform_set_drvdata(pdev, NULL);
+	if (pDev)
+		kfree(pDev);
+
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+  static const struct of_device_id lcd_dt_match[] = {
+	  {
+		  .compatible = "amlogic,lcd",
+	  },
+	  {},
+  };
+#endif
+
+static struct platform_driver lcd_driver = {
+	 .probe = lcd_probe,
+	 .remove = lcd_remove,
+	 .driver = {
+		 .name = "mesonlcd",
+		 .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+		 .of_match_table = lcd_dt_match,
+#endif
+	 },
+ };
+
+static int __init lcd_init(void)
+{
+	 printk("LCD driver init\n");
+	 if (platform_driver_register(&lcd_driver)) {
+		 printk("failed to register lcd driver module\n");
+		 return -ENODEV;
+	 }
+
+	 return 0;
+}
+
+static void __exit lcd_exit(void)
+{
+	platform_driver_unregister(&lcd_driver);
+}
+
+subsys_initcall(lcd_init);
+module_exit(lcd_exit);
+
+
+static int __init lcd_boot_para_setup(char *s)
+{
+	if (NULL != s) {
+		sprintf(lcd_propname, "%s", s);
+	}
+
+	return 0;
+}
+ __setup("panel_type=",lcd_boot_para_setup);
+
+
+ MODULE_DESCRIPTION("Meson LCD Panel Driver");
+ MODULE_LICENSE("GPL");
+ MODULE_AUTHOR("Amlogic, Inc.");
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd.h b/drivers/amlogic/display/lcd/aml_tv_lcd.h
new file mode 100644
index 000000000000..dcb93b0b634c
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd.h
@@ -0,0 +1,196 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  <jiaming.huang@amlogic.com>
+ *
+ */
+
+#ifndef AML_TV_LCD_H
+#define AML_TV_LCD_H
+
+#include <linux/amlogic/vout/vinfo.h>
+
+
+typedef enum {
+    OFF = 0,
+    ON = 1,
+} Bool_t;
+
+
+typedef enum {
+	LCD_DIGITAL_LVDS = 0,
+	LCD_DIGITAL_VBYONE,
+	LCD_DIGITAL_TTL,
+	//LCD_DIGITAL_MINILVDS,
+	LCD_TYPE_MAX,
+} Lcd_Type_t;
+
+
+typedef struct {
+	char *model_name;
+	u16 h_active;		// Horizontal display area
+	u16 v_active;		// Vertical display area
+	u16 h_period;		// Horizontal total period time
+	u16 v_period;		// Vertical total period time
+	u16 video_on_pixel;
+	u16 video_on_line;
+
+	u32 screen_ratio_width;		// screen aspect ratio width
+	u32 screen_ratio_height;		// screen aspect ratio height
+	u32 h_active_area;				/* screen physical width in "mm" unit */
+	u32 v_active_area;				/* screen physical height in "mm" unit */
+
+	Lcd_Type_t lcd_type;
+	//u16 lcd_bits;			// 6 or 8 bits
+	//u16 lcd_bits_option;	//option=0, means the panel only support one lcd_bits option
+}Lcd_Basic_t;
+/*
+
+typedef struct {
+	u32 pll_ctrl;		//video PLL settings
+	u32 div_ctrl;		// video pll div settings
+	u32 clk_ctrl;		// video clock settings //[31]clk_auto, [11:8]ss_ctrl, [7:0]xd
+	u32 lcd_clk;		// lcd clock
+	u16 sync_duration_num;
+	u16 sync_duration_den;
+
+	u16 pol_ctrl;
+	//u16 inv_cnt_addr;
+	//u16 tcon_misc_sel_addr;
+
+	u16 video_on_pixel;
+	u16 video_on_line;
+
+	u16 hsync_width;
+	u16 hsync_bp;
+	u16 vsync_width;
+	u16 vsync_bp;
+	u32 vsync_h_phase; //[31]sign [15:0]value
+	u16 hvsync_valid;
+	//u16 de_hstart;
+	//u16 de_vstart;
+	u16 de_valid;
+	u32 h_offset;
+	u32 v_offset;
+
+	u16 de_hs_addr;
+	u16 de_he_addr;
+	u16 de_vs_addr;
+	u16 de_ve_addr;
+
+	u16 hs_hs_addr;
+	u16 hs_he_addr;
+	u16 hs_vs_addr;
+	u16 hs_ve_addr;
+
+	u16 vs_hs_addr;
+	u16 vs_he_addr;
+	u16 vs_vs_addr;
+	u16 vs_ve_addr;
+
+	u16 vso_hstart;
+	u16 vso_vstart;
+	u16 vso_user;
+
+} Lcd_Timing_t;
+*/
+
+typedef struct {
+	u32 hpll_clk;
+	u32 hpll_od;
+	u32 hdmi_pll_cntl5;
+
+    u16 sync_duration_num;
+    u16 sync_duration_den;
+
+    u16 sth1_hs_addr;
+    u16 sth1_he_addr;
+    u16 sth1_vs_addr;
+    u16 sth1_ve_addr;
+
+    u16 stv1_hs_addr;
+    u16 stv1_he_addr;
+    u16 stv1_vs_addr;
+    u16 stv1_ve_addr;
+} Lcd_Timing_t;
+
+typedef struct {
+	int lvds_bits;				// 6 / 8 /10  bits
+    int lvds_repack;
+    int pn_swap;
+    int dual_port;
+    int port_reverse;
+    int lvds_fifo_wr_mode;
+} Lvds_Config_t;
+
+typedef struct {
+	int lane_count;
+    int byte;
+    int region;
+    int color_fmt;
+} Vbyone_Config_t;
+
+typedef struct {
+	Lvds_Config_t *lvds_config;
+	Vbyone_Config_t *vbyone_config;
+
+	//TTL_Config_t *ttl_config;
+	//DSI_Config_t *mipi_config;
+	//EDP_Config_t *edp_config;
+	//MLVDS_Config_t *mlvds_config;
+	//MLVDS_Tcon_Config_t *mlvds_tcon_config;
+} Lcd_Control_Config_t;
+
+//****panel power control only for uboot ***//
+typedef struct {
+	unsigned int gpio;
+	unsigned short on_value;
+	unsigned short off_value;
+	unsigned short panel_on_delay;
+	unsigned short panel_off_delay;
+} Panel_Power_Config_t;
+
+typedef struct {
+	Panel_Power_Config_t *panel_power;
+} Lcd_Power_Ctrl_t;
+
+typedef struct {
+    Lcd_Basic_t lcd_basic;
+	Lcd_Timing_t lcd_timing;
+	Lcd_Control_Config_t lcd_control;
+	Lcd_Power_Ctrl_t lcd_power_ctrl;
+} Lcd_Config_t;
+
+
+struct aml_lcd {
+	Lcd_Config_t *pConf;
+	vinfo_t lcd_info;
+	struct platform_device *pdev;
+};
+
+
+
+
+#define TV_LCD_INFO(format, arg...) printk(KERN_INFO "lcd info: %s: " format, \
+		__FUNCTION__ , ## arg)
+#define TV_LCD_ERR(format, arg...)  printk(KERN_ERR "lcd error: %s: " format, \
+		__FUNCTION__ , ## arg)
+
+
+#endif
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/Makefile b/drivers/amlogic/display/lcd/aml_tv_lcd_port/Makefile
new file mode 100644
index 000000000000..64644656bca9
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/Makefile
@@ -0,0 +1,4 @@
+
+obj-y	+= lcd_common.o
+obj-y	+= lvds_drv.o
+obj-y	+= vbyone_drv.o
\ No newline at end of file
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
new file mode 100644
index 000000000000..b5a7bbdb4268
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
@@ -0,0 +1,196 @@
+
+#include "lcd_common.h"
+
+
+int set_hpll_pll(int hpll_clk, int hpll_od,int hdmi_pll_cntl5)
+{
+//===============================
+//out off pll clock
+//===============================
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, hpll_clk);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL2,hpll_od);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL5,hdmi_pll_cntl5);
+
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, hpll_clk & (~(1<<28)));
+	//aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2,od1,18,2); //no used ,bit[18:19]
+
+	//printf("Wait 10us for phy_clk stable!\n");
+	udelay(10); // delay 10uS to wait clock is stable
+
+	return 0;
+}
+
+
+// --------------------------------------------------
+//              clocks_set_vid_clk_div
+// --------------------------------------------------
+// wire            clk_final_en    = control[19];
+// wire            clk_div1        = control[18];
+// wire    [1:0]   clk_sel         = control[17:16];
+// wire            set_preset      = control[15];
+// wire    [14:0]  shift_preset    = control[14:0];
+void lcd_clocks_set_vid_clk_div(int div_sel)
+{
+	int shift_val = 0;
+	int shift_sel = 0;
+
+	TV_LCD_INFO("div = %d\n", div_sel);
+	// Disable the output clock
+	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+	switch (div_sel) {
+		case CLK_UTIL_VID_PLL_DIV_1:      shift_val = 0xFFFF; shift_sel = 0; break;
+		case CLK_UTIL_VID_PLL_DIV_2:      shift_val = 0x0aaa; shift_sel = 0; break;
+		case CLK_UTIL_VID_PLL_DIV_3:      shift_val = 0x0db6; shift_sel = 0; break;
+		case CLK_UTIL_VID_PLL_DIV_3p5:    shift_val = 0x36cc; shift_sel = 1; break;
+		case CLK_UTIL_VID_PLL_DIV_3p75:   shift_val = 0x6666; shift_sel = 2; break;
+		case CLK_UTIL_VID_PLL_DIV_4:      shift_val = 0x0ccc; shift_sel = 0; break;
+		case CLK_UTIL_VID_PLL_DIV_5:      shift_val = 0x739c; shift_sel = 2; break;
+		case CLK_UTIL_VID_PLL_DIV_6:      shift_val = 0x0e38; shift_sel = 0; break;
+		case CLK_UTIL_VID_PLL_DIV_6p25:   shift_val = 0x0000; shift_sel = 3; break;
+		case CLK_UTIL_VID_PLL_DIV_7:      shift_val = 0x3c78; shift_sel = 1; break;
+		case CLK_UTIL_VID_PLL_DIV_7p5:    shift_val = 0x78f0; shift_sel = 2; break;
+		case CLK_UTIL_VID_PLL_DIV_12:     shift_val = 0x0fc0; shift_sel = 0; break;
+		case CLK_UTIL_VID_PLL_DIV_14:     shift_val = 0x3f80; shift_sel = 1; break;
+		case CLK_UTIL_VID_PLL_DIV_15:     shift_val = 0x7f80; shift_sel = 2; break;
+		case CLK_UTIL_VID_PLL_DIV_2p5:    shift_val = 0x5294; shift_sel = 2; break;
+		default:
+		TV_LCD_ERR("clocks_set_vid_clk_div:  Invalid parameter\n");
+		break;
+	}
+
+	if (shift_val == 0xffff ) {      // if divide by 1
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+	} else {
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+	}
+	// Enable the final output clock
+	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+void lcd_set_crt_video_enc(int vIdx, int inSel, int DivN)
+{
+	if (vIdx == 0) //V1
+	{
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+		udelay(2);
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, inSel,   16, 3); // [18:16] - cntl_clk_in_sel
+		aml_set_reg32_bits(P_HHI_VID_CLK_DIV, (DivN-1), 0, 8); // [7:0]   - cntl_xd0
+		udelay(5);
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);//[19] -enable clk_div0
+	} else { //V2
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+		udelay(2);
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, inSel,  16, 3); // [18:16] - cntl_clk_in_sel
+		aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, (DivN-1),0, 8); // [7:0]   - cntl_xd0
+		udelay(5);
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
+	}
+	udelay(5);
+}
+
+void lcd_enable_crt_video_encl(int enable, int inSel)
+{
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV,inSel,  12, 4); //encl_clk_sel:hi_viid_clk_div[15:12]
+
+	if (inSel <= 4) //V1
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL,1, inSel, 1);
+	else
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL,1, (inSel-5),1);
+
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2,enable, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
+
+#ifndef NO_EDP_DSI
+	aml_set_reg32_bits(P_VPU_MISC_CTRL, 1, 0, 1);    // vencl_clk_en_force: vpu_misc_ctrl[0]
+#endif
+}
+
+void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode)
+{
+	if (vd1_or_vd2_or_post == 0) { //vd1
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 5, 1);
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 8, 2);
+	}else if (vd1_or_vd2_or_post == 1) { //vd2
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 4, 1);
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 2, 8, 2);
+	}else{
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 0, 1);
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 0, 8, 2);
+		if (mode == 0) {
+			aml_set_reg32_bits(P_VPP_MATRIX_CTRL, 1, 1, 2);
+		}else if (mode == 1) {
+			aml_set_reg32_bits(P_VPP_MATRIX_CTRL, 0, 1, 2);
+		}
+	}
+
+	if (mode == 0) { //ycbcr not full range, 601 conversion
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET0_1, 0x0064C8FF);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET2, 0x006400C8);
+		//1.164     0       1.596
+		//1.164   -0.392    -0.813
+		//1.164   2.017     0
+		aml_write_reg32(P_VPP_MATRIX_COEF00_01, 0x04000000);
+		aml_write_reg32(P_VPP_MATRIX_COEF02_10, 0x059C0400);
+		aml_write_reg32(P_VPP_MATRIX_COEF11_12, 0x1EA01D24);
+		aml_write_reg32(P_VPP_MATRIX_COEF20_21, 0x04000718);
+		aml_write_reg32(P_VPP_MATRIX_COEF22, 0x00000000);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET0_1, 0x00000000);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET2, 0x00000000);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET0_1, 0x00000E00);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET2, 0x00000E00);
+	}else if (mode == 1) {//ycbcr full range, 601 conversion
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET0_1, 0x0000600);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET2, 0x0600);
+		//	1	0			1.402
+		//	1	-0.34414	-0.71414
+		//	1	1.772		0
+		aml_write_reg32(P_VPP_MATRIX_COEF00_01, (0x400 << 16) |0);
+		aml_write_reg32(P_VPP_MATRIX_COEF02_10, (0x59c << 16) |0x400);
+		aml_write_reg32(P_VPP_MATRIX_COEF11_12, (0x1ea0 << 16) |0x1d25);
+		aml_write_reg32(P_VPP_MATRIX_COEF20_21, (0x400 << 16) |0x717);
+		aml_write_reg32(P_VPP_MATRIX_COEF22, 0x0);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET0_1, 0x0);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET2, 0x0);
+	}
+}
+
+
+
+void _enable_vsync_interrupt(void)
+{
+	if ((aml_read_reg32(P_ENCL_VIDEO_EN) & 1) || (aml_read_reg32(P_ENCL_VIDEO_EN) & 1)) {
+		aml_write_reg32(P_VENC_INTCTRL, 0x200);
+	} else {
+		aml_write_reg32(P_VENC_INTCTRL, 0x2);
+	}
+}
+
+
+void _disable_display_driver(void)
+{
+	int vclk_sel;
+
+	vclk_sel = 0;//((pConf->lcd_timing.clk_ctrl) >>4) & 0x1;
+
+	aml_set_reg32_bits(P_HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
+
+	aml_write_reg32(P_ENCT_VIDEO_EN, 0);	//disable enct
+	aml_write_reg32(P_ENCL_VIDEO_EN, 0);	//disable encl
+
+	if (vclk_sel)
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 0, 5);		//close vclk2 gate: 0x104b[4:0]
+	else
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 0, 5);		//close vclk1 gate: 0x105f[4:0]
+
+	TV_LCD_INFO("disable lcd display driver.\n");
+}
+
+
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
new file mode 100644
index 000000000000..02a551ebf9e8
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
@@ -0,0 +1,42 @@
+#ifndef LCD_COMMON_H
+#define LCD_COMMON_H
+
+
+#include <mach/register.h>
+
+#include <linux/of.h>
+
+#include <linux/delay.h>
+#include <linux/types.h>
+
+#include <mach/am_regs.h>
+
+#include "../aml_tv_lcd.h"
+
+#define VPP_OUT_SATURATE            (1 << 0)
+
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+#define CLK_UTIL_VID_PLL_DIV_2p5    14
+
+
+void lcd_clocks_set_vid_clk_div(int div_sel);
+int set_hpll_pll(int freq, int od1,int hdmi_pll_cntl5);
+void lcd_set_crt_video_enc(int vIdx, int inSel, int DivN);
+void lcd_enable_crt_video_encl(int enable, int inSel);
+void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode);
+ void _enable_vsync_interrupt(void);
+
+#endif
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
new file mode 100644
index 000000000000..a115ae2c136f
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
@@ -0,0 +1,194 @@
+
+#include "lcd_common.h"
+
+static void set_tcon_lvds(Lcd_Config_t *pConf)
+{
+	vpp_set_matrix_ycbcr2rgb(2, 0);
+	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 3);
+	aml_write_reg32(P_L_RGB_BASE_ADDR, 0);
+	aml_write_reg32(P_L_RGB_COEFF_ADDR, 0x400);
+
+	if (pConf->lcd_control.lvds_config->lvds_bits == 8)
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x400);
+	else if (pConf->lcd_control.lvds_config->lvds_bits == 6)
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x600);
+	else
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0);
+
+	aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
+}
+
+static void init_lvds_phy(Lcd_Config_t *pConf)
+{
+	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
+	//od   clk 1039.5 / 2 = 519.75 = 74.25*7
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
+}
+
+static void set_control_lvds(Lcd_Config_t *pConf)
+{
+	unsigned int bit_num = 1;
+	unsigned int pn_swap = 0;
+	unsigned int dual_port = 1;
+	unsigned int lvds_repack = 1;
+	unsigned int port_reverse = 1;
+
+	lvds_repack = (pConf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	pn_swap		= (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
+	dual_port	= (pConf->lcd_control.lvds_config->dual_port) & 0x1;
+	port_reverse= (pConf->lcd_control.lvds_config->port_reverse) & 0x1;
+	switch (pConf->lcd_control.lvds_config->lvds_bits) {
+		case 10:
+			bit_num=0;
+			break;
+		case 8:
+			bit_num=1;
+			break;
+		case 6:
+			bit_num=2;
+			break;
+		case 4:
+			bit_num=3;
+			break;
+		default:
+			bit_num=1;
+			break;
+	}
+
+	aml_write_reg32(P_MLVDS_CONTROL,  (aml_read_reg32(P_MLVDS_CONTROL) & ~(1 << 0)));  //disable mlvds
+	aml_write_reg32(P_LVDS_PACK_CNTL_ADDR,
+					( lvds_repack<<0 ) | // repack
+					( port_reverse?(0<<2):(1<<2)) | // odd_even
+					( 0<<3 ) |			// reserve
+					( 0<<4 ) |			// lsb first
+					( pn_swap<<5 ) |	// pn swap
+					( dual_port<<6 ) |	// dual port
+					( 0<<7 ) |			// use tcon control
+					( bit_num<<8 ) |	// 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+					( 0<<10 ) |			//r_select  //0:R, 1:G, 2:B, 3:0
+					( 1<<12 ) |			//g_select  //0:R, 1:G, 2:B, 3:0
+					( 2<<14 ));			//b_select  //0:R, 1:G, 2:B, 3:0;
+}
+
+static void venc_set_lvds(Lcd_Config_t *pConf)
+{
+//	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0)|(0<<2));     // viu1 select encl  | viu2 select encl
+	aml_write_reg32(P_ENCL_VIDEO_EN, 0);
+	//int havon_begin = 80;
+	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0)|(0<<2) );    // viu1 select encl | viu2 select encl
+	aml_write_reg32(P_ENCL_VIDEO_MODE, 0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV, 0x0418); // Sampling rate: 1
+
+	// bypass filter
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL, 	0x1000);
+	aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT, 	pConf->lcd_basic.h_period - 1);
+	aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT,		pConf->lcd_basic.v_period - 1);
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN,	pConf->lcd_basic.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_END,		pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_basic.video_on_line);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_basic.video_on_line);
+
+	aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,		pConf->lcd_timing.sth1_hs_addr);
+	aml_write_reg32(P_ENCL_VIDEO_HSO_END,		pConf->lcd_timing.sth1_he_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN,		pConf->lcd_timing.stv1_hs_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_END,		pConf->lcd_timing.stv1_he_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,		pConf->lcd_timing.stv1_vs_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,		pConf->lcd_timing.stv1_ve_addr);
+	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 	0);
+
+	// enable encl
+	aml_write_reg32(P_ENCL_VIDEO_EN, 1);
+}
+
+//new lvd_vx1_phy config
+static void lvds_phy_config(int lvds_vx1_sel)
+{
+	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+
+	if (lvds_vx1_sel == 0) { //lvds
+		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
+		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
+		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
+		//od   clk 1039.5 / 2 = 519.75 = 74.25*7
+		aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
+	}
+}
+
+static void vclk_set_encl_lvds(int lvds_ports, int hpll_clk, int hpll_od,int hdmi_pll_cntl5)
+{
+	//int hdmi_clk_out;
+	int vx1_phy_div;
+	int encl_div;
+	unsigned int xd;
+
+	if (lvds_ports < 2) {
+		TV_LCD_INFO("lvds clk: hpll_clk=%x hpll_od%x \n",hpll_clk,hpll_od);
+		if (set_hpll_pll(hpll_clk, hpll_od,hdmi_pll_cntl5)) {
+			TV_LCD_ERR("Unsupported hpll_pll out frequency!\n");
+			return;
+		}
+		vx1_phy_div  = 2/2;
+		encl_div	 = vx1_phy_div*7;
+
+		if (lvds_ports == 1) //dual port
+			vx1_phy_div = vx1_phy_div*2;
+	}else if (lvds_ports >= 2) {
+		TV_LCD_ERR("lcd error :Quad-LVDS is not supported!\n");
+		return;
+	}
+
+	//configure vid_clk_div_top
+	if ((encl_div%14) == 0) {//7*even
+		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_14);
+		xd = encl_div/14;
+	}else if ((encl_div%7) == 0) { //7*odd
+		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7);
+		xd = encl_div/7;
+	}else{ //3.5*odd
+		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p5);
+		xd = encl_div/3.5;
+	}
+	//for lvds phy clock and enable decoupling FIFO
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((vx1_phy_div-1)<<1)|1)<<24);
+
+	//config lvds phy
+	lvds_phy_config(0);
+	//configure crt_video
+	lcd_set_crt_video_enc(0,0,xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	lcd_enable_crt_video_encl(1,0); //select and enable the output
+}
+
+static void set_pll_lvds(Lcd_Config_t *pConf)
+{
+	unsigned int sw_port 	= (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0x100;
+	unsigned int lvds_fifo = (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0xff;
+	vclk_set_encl_lvds(pConf->lcd_control.lvds_config->dual_port, pConf->lcd_timing.hpll_clk, pConf->lcd_timing.hpll_od,pConf->lcd_timing.hdmi_pll_cntl5);
+	if ( sw_port == 0x100 )
+		aml_write_reg32( P_HHI_VIID_DIVIDER_CNTL, ((aml_read_reg32(P_HHI_VIID_DIVIDER_CNTL) & ~(0x7 << 8)) | (1 << 8) | (0<<10)));
+	else
+		aml_write_reg32( P_HHI_VIID_DIVIDER_CNTL, ((aml_read_reg32(P_HHI_VIID_DIVIDER_CNTL) & ~(0x7 << 8)) | (2 << 8) | (0<<10)));
+	aml_write_reg32(P_LVDS_GEN_CNTL, (aml_read_reg32(P_LVDS_GEN_CNTL)| (1 << 3) | (lvds_fifo << 0)));
+}
+
+unsigned int  lvds_init(Lcd_Config_t *pConf)
+{
+	TV_LCD_INFO("lcd: lvds mode is selected!\n");
+	set_pll_lvds(pConf);
+	venc_set_lvds(pConf);
+	set_control_lvds(pConf);
+	init_lvds_phy(pConf);
+	set_tcon_lvds(pConf);
+	_enable_vsync_interrupt();
+
+	return 0;
+}
+
+
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/ttl_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/ttl_drv.c
new file mode 100644
index 000000000000..971837647582
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/ttl_drv.c
@@ -0,0 +1,156 @@
+
+void set_ttl_pinmux(void)
+{
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_0, 0x3f, 0, 6);
+	//aml_set_reg32_bits(P_PERIPHS_PIN_MUX_0, 0x3, 18, 2);
+	//aml_set_reg32_bits(P_PERIPHS_PIN_MUX_0, 0x1, 29, 1);
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_8, 0x7, 22, 3);
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_8, 0x1, 28, 1);
+
+	//aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG4, 0x1, 26, 1);
+	//aml_set_reg32_bits(P_PAD_PULL_UP_REG4, 0x1, 26, 1);
+}
+
+static void set_tcon_ttl(Lcd_Config_t *pConf)
+{
+	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+
+	//set_lcd_gamma_table_ttl(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R);
+	//set_lcd_gamma_table_ttl(pConf->lcd_effect.GammaTableG, LCD_H_SEL_G);
+	//set_lcd_gamma_table_ttl(pConf->lcd_effect.GammaTableB, LCD_H_SEL_B);
+
+	aml_write_reg32(P_L_GAMMA_CNTL_PORT, 0);//pConf->lcd_effect.gamma_cntl_port);
+	//aml_write_reg32(P_GAMMA_VCOM_HSWITCH_ADDR, pConf->lcd_effect.gamma_vcom_hswitch_addr);
+
+	aml_write_reg32(P_L_RGB_BASE_ADDR,   0xf0);//pConf->lcd_effect.rgb_base_addr);
+	aml_write_reg32(P_L_RGB_COEFF_ADDR,  0x74a);//pConf->lcd_effect.rgb_coeff_addr);
+	//aml_write_reg32(P_POL_CNTL_ADDR,   pConf->lcd_timing.pol_cntl_addr);
+	if (pConf->lcd_control.lvds_config->lcd_bits == 8)
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x400);
+	else
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x600);
+
+	aml_write_reg32(P_L_STH1_HS_ADDR,    tcon_adr->sth1_hs_addr);
+	aml_write_reg32(P_L_STH1_HE_ADDR,    tcon_adr->sth1_he_addr);
+	aml_write_reg32(P_L_STH1_VS_ADDR,    tcon_adr->sth1_vs_addr);
+	aml_write_reg32(P_L_STH1_VE_ADDR,    tcon_adr->sth1_ve_addr);
+
+	aml_write_reg32(P_L_OEH_HS_ADDR,     tcon_adr->oeh_hs_addr);
+	aml_write_reg32(P_L_OEH_HE_ADDR,     tcon_adr->oeh_he_addr);
+	aml_write_reg32(P_L_OEH_VS_ADDR,     tcon_adr->oeh_vs_addr);
+	aml_write_reg32(P_L_OEH_VE_ADDR,     tcon_adr->oeh_ve_addr);
+
+	aml_write_reg32(P_L_VCOM_HSWITCH_ADDR, tcon_adr->vcom_hswitch_addr);
+	aml_write_reg32(P_L_VCOM_VS_ADDR,    tcon_adr->vcom_vs_addr);
+	aml_write_reg32(P_L_VCOM_VE_ADDR,    tcon_adr->vcom_ve_addr);
+
+	aml_write_reg32(P_L_CPV1_HS_ADDR,    tcon_adr->cpv1_hs_addr);
+	aml_write_reg32(P_L_CPV1_HE_ADDR,    tcon_adr->cpv1_he_addr);
+	aml_write_reg32(P_L_CPV1_VS_ADDR,    tcon_adr->cpv1_vs_addr);
+	aml_write_reg32(P_L_CPV1_VE_ADDR,    tcon_adr->cpv1_ve_addr);
+
+	aml_write_reg32(P_L_STV1_HS_ADDR,    tcon_adr->stv1_hs_addr);
+	aml_write_reg32(P_L_STV1_HE_ADDR,    tcon_adr->stv1_he_addr);
+	aml_write_reg32(P_L_STV1_VS_ADDR,    tcon_adr->stv1_vs_addr);
+	aml_write_reg32(P_L_STV1_VE_ADDR,    tcon_adr->stv1_ve_addr);
+
+	aml_write_reg32(P_L_OEV1_HS_ADDR,    tcon_adr->oev1_hs_addr);
+	aml_write_reg32(P_L_OEV1_HE_ADDR,    tcon_adr->oev1_he_addr);
+	aml_write_reg32(P_L_OEV1_VS_ADDR,    tcon_adr->oev1_vs_addr);
+	aml_write_reg32(P_L_OEV1_VE_ADDR,    tcon_adr->oev1_ve_addr);
+
+	aml_write_reg32(P_L_INV_CNT_ADDR,    tcon_adr->inv_cnt_addr);
+	aml_write_reg32(P_L_TCON_MISC_SEL_ADDR,     tcon_adr->tcon_misc_sel_addr);
+	aml_write_reg32(P_L_DUAL_PORT_CNTL_ADDR, tcon_adr->dual_port_cntl_addr);
+
+	aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
+}
+
+static void venc_set_ttl(Lcd_Config_t *pConf)
+{
+	printf("%s\n", __FUNCTION__);
+	aml_write_reg32(P_ENCL_VIDEO_EN,           0);
+	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL,
+	   (0<<0) |    // viu1 select ENCL
+	   (0<<2)      // viu2 select ENCL
+	);
+	aml_write_reg32(P_ENCL_VIDEO_MODE,        0);
+	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,    0x0418);
+
+	// bypass filter
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL,    0x1000);
+	aml_write_reg32(P_VENC_DVI_SETTING,        0x11);
+	aml_write_reg32(P_VENC_VIDEO_PROG_MODE,    0x100);
+
+	aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT,    pConf->lcd_basic.h_period - 1);
+	aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT,    pConf->lcd_basic.v_period - 1);
+
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN,  pConf->lcd_basic.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_END,    pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,  pConf->lcd_basic.video_on_line);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,  pConf->lcd_basic.v_active + 3  + pConf->lcd_basic.video_on_line);
+
+	aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,    15);
+	aml_write_reg32(P_ENCL_VIDEO_HSO_END,      31);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN,    15);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_END,      31);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,    0);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,    2);
+
+	// enable ENCL
+	aml_write_reg32(P_ENCL_VIDEO_EN,           1);
+}
+
+ void vclk_set_encl_ttl(vmode_t vmode)
+{
+	int hdmi_clk_out;
+	//int hdmi_vx1_clk_od1;
+	int vx1_phy_div;
+	int encl_div;
+	unsigned int xd;
+	//no used, od2 must >= od3.
+	//hdmi_vx1_clk_od1 = 1; //OD1 always 1
+
+	//pll_video.pl 3500 pll_out
+	switch (vmode) {
+		case VMODE_720P: //total: 1650*750 pixel clk = 74.25MHz,phy_clk(s)=(pclk*7)= 519.75 = 1039.5/2
+			hdmi_clk_out = 1039.5;
+			vx1_phy_div  = 2/2;
+			encl_div     = vx1_phy_div*7;
+			break;
+
+		default:
+			printf("Error video format!\n");
+			return;
+	}
+	//if(set_hdmi_dpll(hdmi_clk_out,hdmi_vx1_clk_od1)) {
+	if (set_hdmi_dpll(hdmi_clk_out,0)) {
+		printf("Unsupported HDMI_DPLL out frequency!\n");
+		return;
+	}
+
+	//configure vid_clk_div_top
+	if ((encl_div%14) == 0) {//7*even
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_14);
+		xd = encl_div/14;
+	}else if ((encl_div%7) == 0) { //7*odd
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7);
+		xd = encl_div/7;
+	}else{ //3.5*odd
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p5);
+		xd = encl_div/3.5;
+	}
+
+	//configure crt_video
+	set_crt_video_enc(0,0,xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	enable_crt_video_encl(1,0); //select and enable the output
+}
+
+static void set_pll_ttl(Lcd_Config_t *pConf)
+{
+	vclk_set_encl_ttl(pDev->lcd_info.mode);
+//	set_video_spread_spectrum(pll_sel, ss_level);
+}
+
+
+
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
new file mode 100644
index 000000000000..3a7cb4f78689
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
@@ -0,0 +1,407 @@
+
+#include "lcd_common.h"
+
+
+
+#define VBO_ENABLE_BIT  0
+#define VBO_EBABLE_WID  1
+
+#define VBO_CTL_MODE_BIT      11
+#define VBO_CTL_MODE_WID      5
+
+#define VBO_CTL_MODE2_BIT     0
+#define VBO_CTL_MODE2_WID     4
+
+#define VBO_VIN2ENC_HVSYNC_DLY_BIT  9
+#define VBO_VIN2ENC_HVSYNC_DLY_WID  1
+
+#define  VBO_LANE_NUM_BIT      0
+#define  VBO_LANE_NUM_WID      3
+
+#define  VBO_LANE_REGION_BIT   4
+#define  VBO_LANE_REGION_WID   2
+
+#define  VBO_SUBLANE_NUM_BIT   8
+#define  VBO_SUBLANE_NUM_WID   3
+
+#define  VBO_BYTE_MODE_BIT     11
+#define  VBO_BYTE_MODE_WID     2
+
+#define  VBO_VIN_HSYNC_POL_BIT 4
+#define  VBO_VIN_HSYNC_POL_WID 1
+
+#define  VBO_VIN_VSYNC_POL_BIT 5
+#define  VBO_VIN_VSYNC_POL_WID 1
+
+#define  VBO_VOUT_HSYNC_POL_BIT 6
+#define  VBO_VOUT_HSYNC_POL_WID 1
+
+#define  VBO_VOUT_VSYNC_POL_BIT 7
+#define  VBO_VOUT_VSYNC_POL_WID 1
+
+#define  VBO_VIN_PACK_BIT      8
+#define  VBO_VIN_PACK_WID      3
+
+#define  VBO_VIN_BPP_BIT      11
+#define  VBO_VIN_BPP_WID       2
+
+#define  VBO_PXL_CTR0_BIT     0
+#define  VBO_PXL_CTR0_WID     4
+
+
+//set VX1_LOCKN && VX1_HTPDN
+void set_vbyone_pinmux(void)
+{
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_7, 3, 18, 2);
+	aml_clr_reg32_mask(P_PERIPHS_PIN_MUX_4, 1<<9);
+	aml_clr_reg32_mask(P_PERIPHS_PIN_MUX_3, 1<<26);
+	aml_clr_reg32_mask(P_PERIPHS_PIN_MUX_7, 1<<29);
+	aml_clr_reg32_mask(P_PERIPHS_PIN_MUX_4, 1<<8);
+}
+
+static void set_tcon_vbyone(Lcd_Config_t *pConf)
+{
+    vpp_set_matrix_ycbcr2rgb(2, 0);
+    aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 3);
+    aml_write_reg32(P_L_RGB_BASE_ADDR, 0);
+    aml_write_reg32(P_L_RGB_COEFF_ADDR, 0x400);
+    aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
+}
+
+static void init_vbyone_phy(Lcd_Config_t *pConf)
+{
+	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6e0ec918);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x00000a7c);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x00ff0800);
+	//od   clk 2970 / 5 = 594
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0xfff00c0);
+	//clear lvds fifo od (/2)
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1, 0xc1000000);
+}
+
+int config_vbyone(int lane, int byte, int region, int hsize, int vsize)
+{
+   int sublane_num;
+   int region_size[4];
+   int tmp;
+
+   if ((lane == 0) || (lane == 3) || (lane == 5) || (lane == 6) || (lane == 7) || (lane>8))
+      return 1;
+   if ((region == 0) || (region== 3) || (region>4))
+      return 1;
+   if (lane%region)
+      return 1;
+   if ((byte<3) || (byte>4))
+      return 1;
+
+   sublane_num = lane/region;
+   aml_set_reg32_bits(P_VBO_LANES,lane-1,  VBO_LANE_NUM_BIT,    VBO_LANE_NUM_WID);
+   aml_set_reg32_bits(P_VBO_LANES,region-1,VBO_LANE_REGION_BIT, VBO_LANE_REGION_WID);
+   aml_set_reg32_bits(P_VBO_LANES,sublane_num-1,VBO_SUBLANE_NUM_BIT, VBO_SUBLANE_NUM_WID);
+   aml_set_reg32_bits(P_VBO_LANES,byte-1,VBO_BYTE_MODE_BIT, VBO_BYTE_MODE_WID);
+
+   if (region>1) {
+       region_size[3] = (hsize/lane)*sublane_num;
+       tmp = (hsize%lane);
+       region_size[0] = region_size[3] + (((tmp/sublane_num)>0) ? sublane_num : (tmp%sublane_num));
+       region_size[1] = region_size[3] + (((tmp/sublane_num)>1) ? sublane_num : (tmp%sublane_num));
+       region_size[2] = region_size[3] + (((tmp/sublane_num)>2) ? sublane_num : (tmp%sublane_num));
+       aml_write_reg32(P_VBO_REGION_00,region_size[0]);
+       aml_write_reg32(P_VBO_REGION_01,region_size[1]);
+       aml_write_reg32(P_VBO_REGION_02,region_size[2]);
+       aml_write_reg32(P_VBO_REGION_03,region_size[3]);
+   }
+   aml_write_reg32(P_VBO_ACT_VSIZE,vsize);
+   //aml_set_reg32_bits(P_VBO_CTRL_H,0x80,VBO_CTL_MODE_BIT,VBO_CTL_MODE_WID);  // different from FBC code!!!
+   aml_set_reg32_bits(P_VBO_CTRL_H,0x0,VBO_CTL_MODE2_BIT,VBO_CTL_MODE2_WID); // different from simulation code!!!
+   aml_set_reg32_bits(P_VBO_CTRL_H,0x1,VBO_VIN2ENC_HVSYNC_DLY_BIT,VBO_VIN2ENC_HVSYNC_DLY_WID);
+   //aml_set_reg32_bits(P_VBO_CTRL_L,enable,VBO_ENABLE_BIT,VBO_EBABLE_WID);
+
+   return 0;
+}
+
+void set_vbyone_ctlbits(int p3d_en, int p3d_lr, int mode)
+{
+	if (mode == 0)  //insert at the first pixel
+		aml_set_reg32_bits(P_VBO_PXL_CTRL,(1<<p3d_en)|(p3d_lr&0x1),VBO_PXL_CTR0_BIT,VBO_PXL_CTR0_WID);
+	else
+		aml_set_reg32_bits(P_VBO_VBK_CTRL_0,(1<<p3d_en)|(p3d_lr&0x1),0,2);
+}
+
+void set_vbyone_sync_pol(int hsync_pol, int vsync_pol)
+{
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,hsync_pol,VBO_VIN_HSYNC_POL_BIT,VBO_VIN_HSYNC_POL_WID);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,vsync_pol,VBO_VIN_VSYNC_POL_BIT,VBO_VIN_VSYNC_POL_WID);
+
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,hsync_pol,VBO_VOUT_HSYNC_POL_BIT,VBO_VOUT_HSYNC_POL_WID);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,vsync_pol,VBO_VOUT_VSYNC_POL_BIT,VBO_VOUT_VSYNC_POL_WID);
+}
+
+static void set_control_vbyone(Lcd_Config_t *pConf)
+{
+    int lane, byte, region,hsize, vsize,color_fmt;
+    int vin_color, vin_bpp;
+
+    hsize = pConf->lcd_basic.h_active;
+	vsize = pConf->lcd_basic.v_active;
+    lane = pConf->lcd_control.vbyone_config->lane_count;		//lane;8
+	byte = pConf->lcd_control.vbyone_config->byte;		       //byte;4
+	region = pConf->lcd_control.vbyone_config->region;		//region_num;2
+	color_fmt = pConf->lcd_control.vbyone_config->color_fmt;  //color_fmt;4
+
+    switch (color_fmt) {
+        case 0://SDVT_VBYONE_18BPP_RGB
+                  vin_color = 4;
+                  vin_bpp   = 2;
+                  break;
+        case 1://SDVT_VBYONE_18BPP_YCBCR444
+                  vin_color = 0;
+                  vin_bpp   = 2;
+                  break;
+        case 2://SDVT_VBYONE_24BPP_RGB
+                  vin_color = 4;
+                  vin_bpp   = 1;
+                  break;
+        case 3://SDVT_VBYONE_24BPP_YCBCR444
+                  vin_color = 0;
+                  vin_bpp   = 1;
+                  break;
+        case 4://SDVT_VBYONE_30BPP_RGB
+                  vin_color = 4;
+                  vin_bpp   = 0;
+                  break;
+        case 5://SDVT_VBYONE_30BPP_YCBCR444
+                  vin_color = 0;
+                  vin_bpp   = 0;
+                  break;
+        default:
+            TV_LCD_ERR("lcd error:VBYONE_COLOR_FORMAT!\n");
+                  return;
+	}
+    // clock seting for VX1
+    //vclk_set_encl_vx1(vfromat, lane, byte);
+
+    // set encl format
+    //set_tv_encl (TV_ENC_LCD3840x2160p_vic03,1,0,0);
+
+    // vpu clock setting
+    //aml_set_reg32(P_HHI_VPU_CLK_CNTL,   (0 << 9)    |   // vpu   clk_sel
+    //                       						 (0 << 0) );     // vpu   clk_div
+    //aml_set_reg32(P_HHI_VPU_CLK_CNTL, (Rd(HHI_VPU_CLK_CNTL) | (1 << 8)) );
+
+    //PIN_MUX for VX1 need to add this to dtd
+
+   // printf("Set VbyOne PIN MUX ......\n");
+   // aml_set_reg32_bits(P_PERIPHS_PIN_MUX_3,3,8,2);
+
+    // set Vbyone
+    TV_LCD_INFO("lcd: VbyOne Configuration ......\n");
+    //set_vbyone_vfmt(vin_color,vin_bpp);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL, vin_color, VBO_VIN_PACK_BIT,VBO_VIN_PACK_WID);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL, vin_bpp,   VBO_VIN_BPP_BIT,VBO_VIN_BPP_WID);
+
+    config_vbyone(lane, byte, region, hsize, vsize);
+
+    set_vbyone_sync_pol(0, 0); //set hsync/vsync polarity to let the polarity is low active inside the VbyOne
+
+    // below line copy from simulation
+    aml_set_reg32_bits(P_VBO_VIN_CTRL, 1, 0, 2); //gate the input when vsync asserted
+    ///aml_set_reg32(P_VBO_VBK_CTRL_0,0x13);
+    //aml_set_reg32(P_VBO_VBK_CTRL_1,0x56);
+    //aml_set_reg32(P_VBO_HBK_CTRL,0x3478);
+    //aml_set_reg32_bits(P_VBO_PXL_CTRL,0x2,VBO_PXL_CTR0_BIT,VBO_PXL_CTR0_WID);
+    //aml_set_reg32_bits(P_VBO_PXL_CTRL,0x3,VBO_PXL_CTR1_BIT,VBO_PXL_CTR1_WID);
+    //set_vbyone_ctlbits(1,0,0);
+    //set fifo_clk_sel: 3 for 10-bits
+    aml_set_reg32_bits(P_HHI_LVDS_TX_PHY_CNTL0,3,6,2);
+
+    //PAD select:
+	if ((lane == 1) || (lane == 2)) {
+		aml_set_reg32_bits(P_LCD_PORT_SWAP,1,9,2);
+	} else if(lane == 4) {
+		aml_set_reg32_bits(P_LCD_PORT_SWAP,2,9,2);
+	} else {
+		aml_set_reg32_bits(P_LCD_PORT_SWAP,0,9,2);
+	}
+    //aml_set_reg32_bits(P_LCD_PORT_SWAP, 1, 8, 1);//reverse lane output order
+
+    // Mux pads in combo-phy: 0 for dsi; 1 for lvds or vbyone; 2 for edp
+    aml_write_reg32(P_HHI_DSI_LVDS_EDP_CNTL0, 0x1); // Select vbyone in combo-phy
+    aml_set_reg32_bits(P_VBO_CTRL_L, 1, VBO_ENABLE_BIT, VBO_EBABLE_WID);
+
+    //force vencl clk enable, otherwise, it might auto turn off by mipi DSI
+    //WRITE_VCBUS_REG_BITS(VPU_MISC_CTRL, 1, 0, 1);
+}
+
+static void venc_set_vbyone(Lcd_Config_t *pConf)
+{
+	aml_write_reg32(P_ENCL_VIDEO_EN, 0);
+
+	//int havon_begin = 80;
+	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL,	(0<<0)|(3<<2));	 // viu1 select encl  | viu2 select encl
+	aml_write_reg32(P_ENCL_VIDEO_MODE,			40);	//0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,		0x18);//0x0418); // Sampling rate: 1
+
+	// bypass filter
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL,		0x1000);
+
+	aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT,		pConf->lcd_basic.h_period - 1);
+	aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT,		pConf->lcd_basic.v_period - 1);
+
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN, 	pConf->lcd_basic.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_END, 	pConf->lcd_basic.h_active - 1 + pConf->lcd_basic.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_basic.video_on_line);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_basic.video_on_line);
+
+	aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,		pConf->lcd_timing.sth1_hs_addr);
+	aml_write_reg32(P_ENCL_VIDEO_HSO_END,		pConf->lcd_timing.sth1_he_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN, 	pConf->lcd_timing.stv1_hs_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_END,		pConf->lcd_timing.stv1_he_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE, 	pConf->lcd_timing.stv1_vs_addr);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE, 	pConf->lcd_timing.stv1_ve_addr);
+
+	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL,	0);
+	// enable encl
+	aml_write_reg32(P_ENCL_VIDEO_EN, 1);
+}
+
+//clock seting for VX1
+static void set_pll_vbyone(Lcd_Config_t *pConf)
+{
+    int  lane, byte;//vfromat,
+	//int hdmi_clk_out;
+	//int hdmi_vx1_clk_od1;
+	int pclk_div;
+	int phy_div;
+	int xd = 0;
+	int minlane;
+
+    lane = pConf->lcd_control.vbyone_config->lane_count;//lane_num;8
+    byte = pConf->lcd_control.vbyone_config->byte;//byte_num;4
+
+	//phy_clk = pixel_clk*10*byte_num/lane_num;
+	//                                   lane_num      byte_num      phy_clk
+	//TV_ENC_LCD720x480:(pclk=27M) 858x525  8            3            101.25      (pclk*3.75)
+	//                                      4            3            202.5       (pclk*7.5)
+	//                                      2            3            405         (pclk*15)
+	//                                      1            3            810         (pclk*30)
+	//                                      8            4            135         (pclk*5)
+	//                                      4            4            270         (pclk*10)
+	//                                      2            4            540         (pclk*20)
+	//                                      1            4            1080        (pclk*40)
+	//                                   lane_num      byte_num      phy_clk
+	//TV_ENC_LCD1920x1080:(pclk=148.5M)     8            3            556.875     (pclk*3.75)
+	//                      2200x1125       4            3            1113.75     (pclk*7.5)
+	//                                      2            3            2227.5      (pclk*15)
+	//                                      1            3            4455        (pclk*30)
+	//                                      8            4            742.5       (pclk*5)
+	//                                      4            4            1485        (pclk*10)
+	//                                      2            4            2970        (pclk*20)
+	//                                      1            4            5940        (pclk*40)
+	//                                   lane_num      byte_num      phy_clk
+	//TV_ENC_LCD3840x2160p:(pclk=594M)      8            3            2227.5      (pclk*3.75)
+	//                      4400x2250       4            3            4455        (pclk*7.5)
+	//                                      2            3            8910        (pclk*15)
+	//                                      1            3           17820        (pclk*30)
+	//                                      8            4            2970        (pclk*5)
+	//                                      4            4            5940        (pclk*10)
+	//                                      2            4           11880        (pclk*20)
+	//                                      1            4           23760        (pclk*40)
+    //if (byte_num == 3)
+    //	hdmi_clk_out = 2227.5*2;  //OD1 = 1
+    //else //4
+    //	hdmi_clk_out = 2970*2;    //OD1 = 1
+    minlane = 8;
+    //hdmi_vx1_clk_od1 = 1;
+
+	if (lane < minlane) {
+		TV_LCD_ERR("lcd error: VX1 cannot support this configuration!\n");
+		return;
+	}
+
+	phy_div = lane/minlane; //1,2,4,8
+	if (phy_div == 8) {
+		phy_div = phy_div/2;
+		//if(hdmi_vx1_clk_od1 != 0) {
+		//	printf("VX1 cannot support this configuration!\n");
+		//	return;
+		//}
+    //	hdmi_vx1_clk_od1=1;
+	}
+	//need check whether we need to set this dpll !!!!!!!
+	//if (set_hdmi_dpll(hdmi_clk_out,hdmi_vx1_clk_od1)){
+    //   printf("Unsupported HDMI_DPLL out frequency!\n");
+    //    return;
+    //}
+
+   pclk_div = (((byte == 3) ? 30:40)*100)/minlane;
+   TV_LCD_INFO("lcd: vbyone byte=%d, lane=%d, pclk=%d, phy_div=%d \n", byte, lane, pclk_div, phy_div);
+   //configure vid_clk_div_top
+   if (byte == 3) {
+	   if (pclk_div == 375) {
+		   lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p75);
+		   xd = 1;
+	   } else if (pclk_div == 750) {
+		   lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7p5);
+		   xd = 1;
+	   } else {
+		   lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_15);
+		   xd = pclk_div/100/15;
+	   }
+	} else if (byte == 4) {
+		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_5);
+		xd = pclk_div/100/5;
+	}
+
+	//for lvds phy clock and enable decoupling FIFO
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((phy_div-1)<<1)|1)<<24);
+
+	//configure crt_video
+	//set_crt_video_enc(0, 0, xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	//if (vidx == 0)
+	{ //V1
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+		udelay(2);  //delay 2uS
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0,   16, 3); // [18:16] - cntl_clk_in_sel
+		aml_set_reg32_bits(P_HHI_VID_CLK_DIV, (xd-1), 0, 8); // [7:0]   - cntl_xd0
+		udelay(5);  // delay 5uS
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
+	}
+    //else { //V2
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+	//	udelay(2);  //delay 2uS
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, insel,  16, 3); // [18:16] - cntl_clk_in_sel
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, (divn-1),0, 8); // [7:0]   - cntl_xd0
+	//	udelay(5);  // delay 5uS
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
+	//}
+	udelay(5);  // delay 5uS
+	//enable_crt_video_encl(1, 0); //select and enable the output
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, 0,  12, 4); //encl_clk_sel:hi_viid_clk_div[15:12]
+	//if(inSel<=4) //V1
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL,1, 0, 1);
+	//else
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL,1, (inSel-5),1);
+
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2, 1, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
+}
+
+unsigned int vbyone_init(Lcd_Config_t *pConf)
+{
+	TV_LCD_INFO("lcd: vx1 mode is selected!\n");
+	set_pll_vbyone(pConf);
+	venc_set_vbyone(pConf);
+	set_control_vbyone(pConf);
+	init_vbyone_phy(pConf);
+	set_tcon_vbyone(pConf);
+	set_vbyone_pinmux();
+
+	_enable_vsync_interrupt();
+
+	return 0;
+}
+
-- 
2.19.0

