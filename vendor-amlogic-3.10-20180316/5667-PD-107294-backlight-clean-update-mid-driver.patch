From 2519095609761dd888ee201af926351454d641a0 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Mon, 1 Jun 2015 10:38:42 +0800
Subject: [PATCH 5667/5965] PD#107294: backlight: clean & update mid driver

separated from tv backlight driver.

Change-Id: I0b6096fe9343bc5e726ff62d5d9f5b916962a42f
---
 drivers/amlogic/display/backlight/Kconfig     |  24 +-
 drivers/amlogic/display/backlight/Makefile    |   2 +-
 drivers/amlogic/display/backlight/aml_bl.c    | 797 +++++-------------
 .../display/backlight/aml_bl_extern/Kconfig   |  23 +
 .../display/backlight/aml_bl_extern/Makefile  |   7 +-
 .../backlight/aml_bl_extern/aml_bl_extern.c   |  14 +-
 include/linux/amlogic/aml_lcd_bl.h            |   2 +-
 7 files changed, 264 insertions(+), 605 deletions(-)
 mode change 100755 => 100644 drivers/amlogic/display/backlight/aml_bl.c
 create mode 100644 drivers/amlogic/display/backlight/aml_bl_extern/Kconfig

diff --git a/drivers/amlogic/display/backlight/Kconfig b/drivers/amlogic/display/backlight/Kconfig
index c9194d7431f9..83a42700a362 100755
--- a/drivers/amlogic/display/backlight/Kconfig
+++ b/drivers/amlogic/display/backlight/Kconfig
@@ -8,6 +8,17 @@ config AMLOGIC_BACKLIGHT
 	help
 		Say Y here if you want to use the Amlogic backlight management.
 
+config AML_BACKLIGHT_EXTERN
+	boolean "AML backlight extern driver IC support"
+	default y
+	depends on AMLOGIC_BACKLIGHT
+	help
+		AML backlight extern driver IC support
+
+if  AML_BACKLIGHT_EXTERN
+source "drivers/amlogic/display/backlight/aml_bl_extern/Kconfig"
+endif
+
 config AMLOGIC_TV_BACKLIGHT
 	bool "Amlogic TV backlight support"
 	select BACKLIGHT_CLASS_DEVICE
@@ -17,38 +28,35 @@ config AMLOGIC_TV_BACKLIGHT
 
 config AML_BL_LATCH_ON_VSYNC
 	bool "Backlight latch on vsync"
-	depends on AMLOGIC_BACKLIGHT
+	depends on AMLOGIC_TV_BACKLIGHT
 	default n
 	help
 	  Say Y if you want to enable the Amlogic backlight latch on vsync.
 
 config AML_BL_PWM_ATTR
 	bool "Backlight sys class attr"
+	depends on AMLOGIC_TV_BACKLIGHT
 	default n
 	help
 	  Say Y if you want to enable the Amlogic backlight sys pwm attr.
 
-config AML_LCD_BACKLIGHT_SUPPORT
-	tristate "AML lcd backlight support"
-	default y
-	depends on AMLOGIC_BACKLIGHT
-	help
-		AML lcd backlight support
-
 config AML_LOCAL_DIMMING
 	bool "Amlogic Local Dimming"
+	depends on AMLOGIC_TV_BACKLIGHT
 	default n
 	help
 	  Amlogic local dimming support.
 
 config IW7023_BACKLIGHT
 	bool "iW7023 Backlight"
+	depends on AMLOGIC_TV_BACKLIGHT
 	default n
 	help
 	  iW7023 LED Driver for LCD Panel Backlight.
 
 config IW7023_USE_EEPROM
 	bool "iW7023 use eeprom to backup data"
+	depends on AMLOGIC_TV_BACKLIGHT
 	default n
 	help
 	  Say Y if you use eeprom to backup data of iw7023.
diff --git a/drivers/amlogic/display/backlight/Makefile b/drivers/amlogic/display/backlight/Makefile
index 3813f107ed21..759d1a80bc34 100755
--- a/drivers/amlogic/display/backlight/Makefile
+++ b/drivers/amlogic/display/backlight/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_AMLOGIC_BACKLIGHT)			+= aml_bl.o
-obj-$(CONFIG_AML_LCD_BACKLIGHT_SUPPORT)	+= aml_bl_extern/
+obj-$(CONFIG_AML_BACKLIGHT_EXTERN)		+= aml_bl_extern/
 
 obj-$(CONFIG_AMLOGIC_TV_BACKLIGHT)		+= aml_tv_bl.o
 
diff --git a/drivers/amlogic/display/backlight/aml_bl.c b/drivers/amlogic/display/backlight/aml_bl.c
old mode 100755
new mode 100644
index 6689a6205ddc..ffee319ecf12
--- a/drivers/amlogic/display/backlight/aml_bl.c
+++ b/drivers/amlogic/display/backlight/aml_bl.c
@@ -30,25 +30,18 @@
 #include <linux/gpio.h>
 #include <linux/backlight.h>
 #include <linux/slab.h>
-#include <linux/amlogic/aml_bl.h>
 #include <linux/workqueue.h>
 #include <mach/power_gate.h>
-#ifdef CONFIG_ARCH_MESON6
-#include <mach/mod_gate.h>
-#endif /* CONFIG_ARCH_MESON6 */
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/pinctrl/consumer.h>
 #include <linux/delay.h>
-#ifdef CONFIG_AML_LCD_BACKLIGHT_SUPPORT
 #include <linux/amlogic/aml_lcd_bl.h>
+#ifdef CONFIG_AML_BACKLIGHT_EXTERN
 #include <linux/amlogic/aml_bl_extern.h>
 #endif
-#include <linux/amlogic/vout/lcdoutc.h>
 
 //#define MESON_BACKLIGHT_DEBUG
 #ifdef MESON_BACKLIGHT_DEBUG
-#define DPRINT(...) printk(KERN_INFO __VA_ARGS__)
-#define DTRACE()    DPRINT(KERN_INFO "%s()\n", __FUNCTION__)
+#define DPRINT(...)   printk(KERN_INFO __VA_ARGS__)
+#define DTRACE()      DPRINT(KERN_INFO "%s()\n", __func__)
 static const char* bl_ctrl_method_table[]={
     "gpio",
     "pwm_negative",
@@ -61,81 +54,12 @@ static const char* bl_ctrl_method_table[]={
 #define DPRINT(...)
 #define DTRACE()
 #endif /* MESON_BACKLIGHT_DEBUG */
+#define BL_PR(...)   printk(KERN_INFO __VA_ARGS__)
 
-#define BL_LEVEL_DEFAULT					BL_LEVEL_MID
-#define BL_NAME 							"backlight"
-#define bl_gpio_request(gpio) 				amlogic_gpio_request(gpio, BL_NAME)
-#define bl_gpio_free(gpio) 					amlogic_gpio_free(gpio, BL_NAME)
-#define bl_gpio_direction_input(gpio) 		amlogic_gpio_direction_input(gpio, BL_NAME)
-#define bl_gpio_direction_output(gpio, val) amlogic_gpio_direction_output(gpio, val, BL_NAME)
-#define bl_gpio_get_value(gpio) 			amlogic_get_value(gpio, BL_NAME)
-#define bl_gpio_set_value(gpio,val) 		amlogic_set_value(gpio, val, BL_NAME)
-
-#ifdef CONFIG_AML_LCD_BACKLIGHT_SUPPORT
-/* for lcd backlight power */
-typedef enum {
-    BL_CTL_GPIO = 0,
-    BL_CTL_PWM_NEGATIVE = 1,
-    BL_CTL_PWM_POSITIVE = 2,
-    BL_CTL_PWM_COMBO = 3,
-    BL_CTL_EXTERN = 4,
-    BL_CTL_MAX = 5,
-} BL_Ctrl_Method_t;
-
-
-typedef enum {
-    BL_PWM_A = 0,
-    BL_PWM_B,
-    BL_PWM_C,
-    BL_PWM_D,
-#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
-    BL_PWM_E,
-    BL_PWM_F,
-#endif
-    BL_PWM_MAX,
-} BL_PWM_t;
-
-typedef struct {
-    unsigned level_default;
-    unsigned level_mid;
-    unsigned level_mid_mapping;
-    unsigned level_min;
-    unsigned level_max;
-    unsigned short power_on_delay;
-    unsigned char method;
-
-    int gpio;
-    unsigned char gpio_on;
-    unsigned char gpio_off;
-    unsigned dim_max;
-    unsigned dim_min;
-    unsigned char pwm_port;
-    unsigned char pwm_gpio_used;
-    unsigned pwm_cnt;
-    unsigned pwm_pre_div;
-    unsigned pwm_max;
-    unsigned pwm_min;
-
-    unsigned combo_level_switch;
-    unsigned char combo_high_port;
-    unsigned char combo_high_method;
-    unsigned char combo_low_port;
-    unsigned char combo_low_method;
-    unsigned combo_high_cnt;
-    unsigned combo_high_pre_div;
-    unsigned combo_high_duty_max;
-    unsigned combo_high_duty_min;
-    unsigned combo_low_cnt;
-    unsigned combo_low_pre_div;
-    unsigned combo_low_duty_max;
-    unsigned combo_low_duty_min;
-
-    struct pinctrl *p;
-    struct workqueue_struct *workqueue;
-    struct delayed_work bl_delayed_work;
-} Lcd_Bl_Config_t;
-
-static Lcd_Bl_Config_t bl_config = {
+static struct aml_bl_s *amlbl;
+
+#ifdef CONFIG_OF
+static struct lcd_bl_config_s bl_config = {
     .level_default = 128,
     .level_mid = 128,
     .level_mid_mapping = 128,
@@ -144,82 +68,87 @@ static Lcd_Bl_Config_t bl_config = {
     .power_on_delay = 100,
     .method = BL_CTL_MAX,
 };
-static unsigned bl_level = BL_LEVEL_DEFAULT;
-static unsigned int bl_status = 3; //0=off, 1=lcd_on_bl_off, 3=lcd_on_bl_on. //bit[0]:lcd, bit[1]:bl
-static unsigned int bl_real_status = 1;
+#endif
 
-#define FIN_FREQ				(24 * 1000)
+#define FIN_FREQ		(24 * 1000)
 
 void get_bl_ext_level(struct bl_extern_config_t *bl_ext_cfg)
 {
-    bl_ext_cfg->level_min = bl_config.level_min;
-    bl_ext_cfg->level_max = bl_config.level_max;
+    if (amlbl == NULL) {
+        BL_PR("no bl data\n");
+        return;
+    }
+    bl_ext_cfg->level_min = amlbl->bconf->level_min;
+    bl_ext_cfg->level_max = amlbl->bconf->level_max;
 }
 
 static DEFINE_MUTEX(bl_power_mutex);
-static void power_on_bl(int bl_flag)
+static void power_on_bl(void)
 {
+    struct lcd_bl_config_s *bconf;
     struct pinctrl_state *s;
     struct aml_bl_extern_driver_t *bl_extern_driver;
     int ret;
 
-    mutex_lock(&bl_power_mutex);
-    if (bl_flag == LCD_BL_FLAG) {
-        if (bl_status > 0)
-            bl_status = 3;
-        else
-            goto exit_power_on_bl;
+    if (amlbl == NULL) {
+        BL_PR("no bl data\n");
+        return;
+    } else {
+        bconf = amlbl->bconf;
     }
+    mutex_lock(&bl_power_mutex);
 
-    DPRINT("%s(bl_flag=%s): bl_level=%u, bl_status=%u, bl_real_status=%u\n", __FUNCTION__, (bl_flag ? "LCD_BL_FLAG" : "DRV_BL_FLAG"), bl_level, bl_status, bl_real_status);
-    if ((bl_level == 0) || (bl_status != 3) || (bl_real_status == 1)) {
+    DPRINT("%s: bl_level=%u, state=0x%x\n", __func__, amlbl->level, amlbl->state);
+    if ((amlbl->level == 0) ||
+      ((amlbl->state & BL_STATE_BL_ON) == 0) ||
+      (amlbl->state & BL_STATE_REAL_ON)) {
         goto exit_power_on_bl;
     }
 
-    switch (bl_config.method) {
+    switch (bconf->method) {
         case BL_CTL_GPIO:
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
             aml_set_reg32_bits(P_LED_PWM_REG0, 1, 12, 2);
 #endif
             mdelay(20);
-            bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_on);
+            bl_gpio_direction_output(bconf->gpio, bconf->gpio_on);
             break;
         case BL_CTL_PWM_NEGATIVE:
         case BL_CTL_PWM_POSITIVE:
-            switch (bl_config.pwm_port) {
+            switch (bconf->pwm_port) {
                 case BL_PWM_A:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.pwm_pre_div, 8, 7);  //pwm_a_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bconf->pwm_pre_div, 8, 7);  //pwm_a_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
                     break;
                 case BL_PWM_B:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.pwm_pre_div, 16, 7);  //pwm_b_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bconf->pwm_pre_div, 16, 7);  //pwm_b_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
                     break;
                 case BL_PWM_C:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.pwm_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bconf->pwm_pre_div, 8, 7);  //pwm_c_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
                     break;
                 case BL_PWM_D:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.pwm_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bconf->pwm_pre_div, 16, 7);  //pwm_d_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
                     break;
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
                 case BL_PWM_E:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.pwm_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bconf->pwm_pre_div, 8, 7);  //pwm_c_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 4, 2);  //pwm_c_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 15, 1);  //pwm_c_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 0, 1);  //enable pwm_c
                     break;
                 case BL_PWM_F:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.pwm_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bconf->pwm_pre_div, 16, 7);  //pwm_d_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 6, 2);  //pwm_d_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 1, 1);  //enable pwm_d
@@ -229,64 +158,64 @@ static void power_on_bl(int bl_flag)
                     break;
             }
 
-            if (IS_ERR(bl_config.p)) {
+            if (IS_ERR(bconf->p)) {
                 printk("set backlight pinmux error.\n");
                 goto exit_power_on_bl;
             }
-            s = pinctrl_lookup_state(bl_config.p, "default"); //select pinctrl
+            s = pinctrl_lookup_state(bconf->p, "default"); //select pinctrl
             if (IS_ERR(s)) {
                 printk("set backlight pinmux error.\n");
-                devm_pinctrl_put(bl_config.p);
+                devm_pinctrl_put(bconf->p);
                 goto exit_power_on_bl;
             }
 
-            ret = pinctrl_select_state(bl_config.p, s); //set pinmux and lock pins
+            ret = pinctrl_select_state(bconf->p, s); //set pinmux and lock pins
             if (ret < 0) {
                 printk("set backlight pinmux error.\n");
-                devm_pinctrl_put(bl_config.p);
+                devm_pinctrl_put(bconf->p);
                 goto exit_power_on_bl;
             }
             mdelay(20);
-            if (bl_config.pwm_gpio_used) {
-                if (bl_config.gpio)
-                    bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_on);
+            if (bconf->pwm_gpio_used) {
+                if (bconf->gpio)
+                    bl_gpio_direction_output(bconf->gpio, bconf->gpio_on);
             }
             break;
         case BL_CTL_PWM_COMBO:
-            switch (bl_config.combo_high_port) {
+            switch (bconf->combo_high_port) {
                 case BL_PWM_A:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 8, 7);  //pwm_a_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bconf->combo_high_pre_div, 8, 7);  //pwm_a_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
                     break;
                 case BL_PWM_B:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_high_pre_div, 16, 7);  //pwm_b_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bconf->combo_high_pre_div, 16, 7);  //pwm_b_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
                     break;
                 case BL_PWM_C:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bconf->combo_high_pre_div, 8, 7);  //pwm_c_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
                     break;
                 case BL_PWM_D:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_high_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bconf->combo_high_pre_div, 16, 7);  //pwm_d_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
                     break;
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
                 case BL_PWM_E:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_high_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bconf->combo_high_pre_div, 8, 7);  //pwm_c_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 4, 2);  //pwm_c_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 15, 1);  //pwm_c_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 0, 1);  //enable pwm_c
                     break;
                 case BL_PWM_F:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_high_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bconf->combo_high_pre_div, 16, 7);  //pwm_d_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 6, 2);  //pwm_d_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 1, 1);  //enable pwm_d
@@ -295,40 +224,40 @@ static void power_on_bl(int bl_flag)
                 default:
                     break;
             }
-            switch (bl_config.combo_low_port) {
+            switch (bconf->combo_low_port) {
                 case BL_PWM_A:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_low_pre_div, 8, 7);  //pwm_a_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bconf->combo_low_pre_div, 8, 7);  //pwm_a_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 4, 2);  //pwm_a_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 15, 1);  //pwm_a_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 0, 1);  //enable pwm_a
                     break;
                 case BL_PWM_B:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bl_config.combo_low_pre_div, 16, 7);  //pwm_b_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_AB, bconf->combo_low_pre_div, 16, 7);  //pwm_b_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 6, 2);  //pwm_b_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 23, 1);  //pwm_b_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 1, 1, 1);  //enable pwm_b
                     break;
                 case BL_PWM_C:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_low_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bconf->combo_low_pre_div, 8, 7);  //pwm_c_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 4, 2);  //pwm_c_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 15, 1);  //pwm_c_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 0, 1);  //enable pwm_c
                     break;
                 case BL_PWM_D:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bl_config.combo_low_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_CD, bconf->combo_low_pre_div, 16, 7);  //pwm_d_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 6, 2);  //pwm_d_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
                     break;
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
                 case BL_PWM_E:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_low_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bconf->combo_low_pre_div, 8, 7);  //pwm_c_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 4, 2);  //pwm_c_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 15, 1);  //pwm_c_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 0, 1);  //enable pwm_c
                     break;
                 case BL_PWM_F:
-                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_low_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bconf->combo_low_pre_div, 16, 7);  //pwm_d_clk_div
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 6, 2);  //pwm_d_clk_sel
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 1, 1);  //enable pwm_d
@@ -338,24 +267,25 @@ static void power_on_bl(int bl_flag)
                     break;
             }
 
-            if (IS_ERR(bl_config.p)) {
+            if (IS_ERR(bconf->p)) {
                 printk("set backlight pinmux error.\n");
                 goto exit_power_on_bl;
             }
-            s = pinctrl_lookup_state(bl_config.p, "pwm_combo");  //select pinctrl
+            s = pinctrl_lookup_state(bconf->p, "pwm_combo");  //select pinctrl
             if (IS_ERR(s)) {
                 printk("set backlight pinmux error.\n");
-                devm_pinctrl_put(bl_config.p);
+                devm_pinctrl_put(bconf->p);
                 goto exit_power_on_bl;
             }
 
-            ret = pinctrl_select_state(bl_config.p, s);  //set pinmux and lock pins
+            ret = pinctrl_select_state(bconf->p, s);  //set pinmux and lock pins
             if (ret < 0) {
                 printk("set backlight pinmux error.\n");
-                devm_pinctrl_put(bl_config.p);
+                devm_pinctrl_put(bconf->p);
                 goto exit_power_on_bl;
             }
             break;
+#ifdef CONFIG_AML_BACKLIGHT_EXTERN
         case BL_CTL_EXTERN:
             bl_extern_driver = aml_bl_extern_get_driver();
             if (bl_extern_driver == NULL) {
@@ -374,42 +304,55 @@ static void power_on_bl(int bl_flag)
                 }
             }
             break;
+#endif
         default:
             printk("wrong backlight control method\n");
             goto exit_power_on_bl;
             break;
     }
-    bl_real_status = 1;
+    amlbl->state |= BL_STATE_REAL_ON; //bl_real_status = 1;
     printk("backlight power on\n");
 
 exit_power_on_bl:
     mutex_unlock(&bl_power_mutex);
 }
 
-static void bl_delayd_on(struct work_struct *work) //bl_delayed_work for LCD_BL_FLAG control
+/* bl_delayed_work for LCD_BL_FLAG control */
+static void bl_delayd_on(struct work_struct *work)
 {
-    power_on_bl(LCD_BL_FLAG);
+    if (amlbl->state & BL_STATE_LCD_ON)
+        amlbl->state |= BL_STATE_BL_ON;
+    power_on_bl();
 }
 
 void bl_power_on(int bl_flag)
 {
-    DPRINT("%s(bl_flag=%s): bl_level=%u, bl_status=%s, bl_real_status=%s\n", __FUNCTION__, (bl_flag ? "LCD_BL_FLAG" : "DRV_BL_FLAG"), bl_level, (bl_status ? "ON" : "OFF"), (bl_real_status ? "ON" : "OFF"));
-    if (bl_flag == LCD_BL_FLAG)
-        bl_status = 1;
+    struct lcd_bl_config_s *bconf;
+
+    if (amlbl == NULL) {
+        BL_PR("no bl data\n");
+        return;
+    } else {
+        bconf = amlbl->bconf;
+    }
+    DPRINT("%s(bl_flag=%s): bl_level=%u, state=0x%x\n", __func__, (bl_flag ? "LCD_BL_FLAG" : "DRV_BL_FLAG"), amlbl->level, amlbl->state);
 
-    if (bl_config.method < BL_CTL_MAX) {
+    if (bconf->method < BL_CTL_MAX) {
         if (bl_flag == LCD_BL_FLAG) {
-            if (bl_config.workqueue) {
-                queue_delayed_work(bl_config.workqueue, &bl_config.bl_delayed_work, msecs_to_jiffies(bl_config.power_on_delay));
+            amlbl->state |= BL_STATE_LCD_ON; //bl_status = 1;
+            if (amlbl->workqueue) {
+                queue_delayed_work(amlbl->workqueue, &amlbl->bl_delayed_work, msecs_to_jiffies(bconf->power_on_delay));
             }
             else {
                 printk("[Warning]: no bl workqueue\n");
-                msleep(bl_config.power_on_delay);
-                power_on_bl(bl_flag);
+                msleep(bconf->power_on_delay);
+                if (amlbl->state & BL_STATE_LCD_ON)
+                    amlbl->state |= BL_STATE_BL_ON;
+                power_on_bl();
             }
         }
         else {
-            power_on_bl(bl_flag);
+            power_on_bl();
         }
     }
     else {
@@ -421,31 +364,38 @@ void bl_power_on(int bl_flag)
 
 void bl_power_off(int bl_flag)
 {
+    struct lcd_bl_config_s *bconf;
     struct aml_bl_extern_driver_t *bl_extern_driver;
     int ret;
 
+    if (amlbl == NULL) {
+        BL_PR("no bl data\n");
+        return;
+    } else {
+        bconf = amlbl->bconf;
+    }
     mutex_lock(&bl_power_mutex);
 
     if (bl_flag == LCD_BL_FLAG)
-        bl_status = 0;
+        amlbl->state &= ~(BL_STATE_LCD_ON | BL_STATE_BL_ON); //bl_status = 0;
 
-    DPRINT("%s(bl_flag=%s): bl_level=%u, bl_status=%u, bl_real_status=%u\n", __FUNCTION__, (bl_flag ? "LCD_BL_FLAG" : "DRV_BL_FLAG"), bl_level, bl_status, bl_real_status);
-    if (bl_real_status == 0) {
+    DPRINT("%s(bl_flag=%s): bl_level=%u, state=0x%x\n", __func__, (bl_flag ? "LCD_BL_FLAG" : "DRV_BL_FLAG"), amlbl->level, amlbl->state);
+    if ((amlbl->state & BL_STATE_REAL_ON) == 0) {
         mutex_unlock(&bl_power_mutex);
         return;
     }
 
-    switch (bl_config.method) {
+    switch (bconf->method) {
         case BL_CTL_GPIO:
-            bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_off);
+            bl_gpio_direction_output(bconf->gpio, bconf->gpio_off);
             break;
         case BL_CTL_PWM_NEGATIVE:
         case BL_CTL_PWM_POSITIVE:
-            if (bl_config.pwm_gpio_used) {
-                if (bl_config.gpio)
-                    bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_off);
+            if (bconf->pwm_gpio_used) {
+                if (bconf->gpio)
+                    bl_gpio_direction_output(bconf->gpio, bconf->gpio_off);
             }
-            switch (bl_config.pwm_port) {
+            switch (bconf->pwm_port) {
                 case BL_PWM_A:
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //disable pwm_a
                     break;
@@ -471,7 +421,7 @@ void bl_power_off(int bl_flag)
             }
             break;
         case BL_CTL_PWM_COMBO:
-            switch (bl_config.combo_high_port) {
+            switch (bconf->combo_high_port) {
                 case BL_PWM_A:
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //disable pwm_a
                     break;
@@ -495,7 +445,7 @@ void bl_power_off(int bl_flag)
                 default:
                     break;
             }
-            switch (bl_config.combo_low_port) {
+            switch (bconf->combo_low_port) {
                 case BL_PWM_A:
                     aml_set_reg32_bits(P_PWM_MISC_REG_AB, 0, 0, 1);  //disable pwm_a
                     break;
@@ -520,6 +470,7 @@ void bl_power_off(int bl_flag)
                     break;
             }
             break;
+#ifdef CONFIG_AML_BACKLIGHT_EXTERN
         case BL_CTL_EXTERN:
             bl_extern_driver = aml_bl_extern_get_driver();
             if (bl_extern_driver == NULL) {
@@ -536,58 +487,66 @@ void bl_power_off(int bl_flag)
                 }
             }
             break;
+#endif
         default:
             break;
     }
-    bl_real_status = 0;
+    amlbl->state &= ~BL_STATE_REAL_ON; //bl_real_status = 0;
     printk("backlight power off\n");
     mutex_unlock(&bl_power_mutex);
 }
-#if (MESON_CPU_TYPE != MESON_CPU_TYPE_MESON6TV)&&(MESON_CPU_TYPE != MESON_CPU_TYPE_MESON6TVD)
+
 static DEFINE_MUTEX(bl_level_mutex);
 static void set_backlight_level(unsigned level)
 {
+    struct lcd_bl_config_s *bconf;
     unsigned pwm_hi = 0, pwm_lo = 0;
     struct aml_bl_extern_driver_t *bl_extern_driver;
     int ret;
 
+    if (amlbl == NULL) {
+        BL_PR("no bl data\n");
+        return;
+    } else {
+        bconf = amlbl->bconf;
+    }
     mutex_lock(&bl_level_mutex);
 
-    DPRINT("set_backlight_level: %u, last level: %u, bl_status: %u, bl_real_status: %u\n", level, bl_level, bl_status, bl_real_status);
-    level = (level > bl_config.level_max ? bl_config.level_max : (level < bl_config.level_min ? (level < BL_LEVEL_OFF ? 0 : bl_config.level_min) : level));
-    bl_level = level;
+    DPRINT("set_backlight_level: %u, last level: %u, state: 0x%x\n", level, amlbl->level, amlbl->state);
+    level = (level > bconf->level_max ? bconf->level_max : (level < bconf->level_min ? (level < BL_LEVEL_OFF ? 0 : bconf->level_min) : level));
+    amlbl->level = level;
 
-    if (bl_level == 0) {
-        if (bl_real_status == 1)
+    if (amlbl->level == 0) {
+        if (amlbl->state & BL_STATE_REAL_ON)//(bl_real_status == 1)
             bl_power_off(DRV_BL_FLAG);
     }
     else {
         //mapping
-        if (level > bl_config.level_mid)
-            level = ((level - bl_config.level_mid) * (bl_config.level_max - bl_config.level_mid_mapping)) / (bl_config.level_max - bl_config.level_mid) + bl_config.level_mid_mapping;
+        if (level > bconf->level_mid)
+            level = ((level - bconf->level_mid) * (bconf->level_max - bconf->level_mid_mapping)) / (bconf->level_max - bconf->level_mid) + bconf->level_mid_mapping;
         else
-            level = ((level - bl_config.level_min) * (bl_config.level_mid_mapping - bl_config.level_min)) / (bl_config.level_mid - bl_config.level_min) + bl_config.level_min;
+            level = ((level - bconf->level_min) * (bconf->level_mid_mapping - bconf->level_min)) / (bconf->level_mid - bconf->level_min) + bconf->level_min;
         DPRINT("level mapping=%u\n", level);
 
-        switch (bl_config.method) {
+        switch (bconf->method) {
             case BL_CTL_GPIO:
-                level = bl_config.dim_min - ((level - bl_config.level_min) * (bl_config.dim_min - bl_config.dim_max)) / (bl_config.level_max - bl_config.level_min);
+                level = bconf->dim_min - ((level - bconf->level_min) * (bconf->dim_min - bconf->dim_max)) / (bconf->level_max - bconf->level_min);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
                 aml_set_reg32_bits(P_LED_PWM_REG0, level, 0, 4);
 #endif
                 break;
             case BL_CTL_PWM_NEGATIVE:
             case BL_CTL_PWM_POSITIVE:
-                level = (bl_config.pwm_max - bl_config.pwm_min) * (level - bl_config.level_min) / (bl_config.level_max - bl_config.level_min) + bl_config.pwm_min;
-                if (bl_config.method == BL_CTL_PWM_NEGATIVE) {
-                    pwm_hi = bl_config.pwm_cnt - level;
+                level = (bconf->pwm_max - bconf->pwm_min) * (level - bconf->level_min) / (bconf->level_max - bconf->level_min) + bconf->pwm_min;
+                if (bconf->method == BL_CTL_PWM_NEGATIVE) {
+                    pwm_hi = bconf->pwm_cnt - level;
                     pwm_lo = level;
                 }
                 else {
                     pwm_hi = level;
-                    pwm_lo = bl_config.pwm_cnt - level;
+                    pwm_lo = bconf->pwm_cnt - level;
                 }
-                switch (bl_config.pwm_port) {
+                switch (bconf->pwm_port) {
                     case BL_PWM_A:
                         aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
                         break;
@@ -613,17 +572,17 @@ static void set_backlight_level(unsigned level)
                 }
                 break;
             case BL_CTL_PWM_COMBO:
-                if (level >= bl_config.combo_level_switch) {
+                if (level >= bconf->combo_level_switch) {
                     //pre_set combo_low duty max
-                    if (bl_config.combo_low_method == BL_CTL_PWM_NEGATIVE) {
-                        pwm_hi = bl_config.combo_low_cnt - bl_config.combo_low_duty_max;
-                        pwm_lo = bl_config.combo_low_duty_max;
+                    if (bconf->combo_low_method == BL_CTL_PWM_NEGATIVE) {
+                        pwm_hi = bconf->combo_low_cnt - bconf->combo_low_duty_max;
+                        pwm_lo = bconf->combo_low_duty_max;
                     }
                     else {
-                        pwm_hi = bl_config.combo_low_duty_max;
-                        pwm_lo = bl_config.combo_low_cnt - bl_config.combo_low_duty_max;
+                        pwm_hi = bconf->combo_low_duty_max;
+                        pwm_lo = bconf->combo_low_cnt - bconf->combo_low_duty_max;
                     }
-                    switch (bl_config.combo_low_port) {
+                    switch (bconf->combo_low_port) {
                         case BL_PWM_A:
                             aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
                             break;
@@ -649,16 +608,16 @@ static void set_backlight_level(unsigned level)
                     }
 
                     //set combo_high duty
-                    level = (bl_config.combo_high_duty_max - bl_config.combo_high_duty_min) * (level - bl_config.combo_level_switch) / (bl_config.level_max - bl_config.combo_level_switch) + bl_config.combo_high_duty_min;
-                    if (bl_config.combo_high_method == BL_CTL_PWM_NEGATIVE) {
-                        pwm_hi = bl_config.combo_high_cnt - level;
+                    level = (bconf->combo_high_duty_max - bconf->combo_high_duty_min) * (level - bconf->combo_level_switch) / (bconf->level_max - bconf->combo_level_switch) + bconf->combo_high_duty_min;
+                    if (bconf->combo_high_method == BL_CTL_PWM_NEGATIVE) {
+                        pwm_hi = bconf->combo_high_cnt - level;
                         pwm_lo = level;
                     }
                     else {
                         pwm_hi = level;
-                        pwm_lo = bl_config.combo_high_cnt - level;
+                        pwm_lo = bconf->combo_high_cnt - level;
                     }
-                    switch (bl_config.combo_high_port) {
+                    switch (bconf->combo_high_port) {
                         case BL_PWM_A:
                             aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
                             break;
@@ -685,15 +644,15 @@ static void set_backlight_level(unsigned level)
                 }
                 else {
                     //pre_set combo_high duty min
-                    if (bl_config.combo_high_method == BL_CTL_PWM_NEGATIVE) {
-                        pwm_hi = bl_config.combo_high_cnt - bl_config.combo_high_duty_min;
-                        pwm_lo = bl_config.combo_high_duty_min;
+                    if (bconf->combo_high_method == BL_CTL_PWM_NEGATIVE) {
+                        pwm_hi = bconf->combo_high_cnt - bconf->combo_high_duty_min;
+                        pwm_lo = bconf->combo_high_duty_min;
                     }
                     else {
-                        pwm_hi = bl_config.combo_high_duty_min;;
-                        pwm_lo = bl_config.combo_high_cnt - bl_config.combo_high_duty_min;
+                        pwm_hi = bconf->combo_high_duty_min;;
+                        pwm_lo = bconf->combo_high_cnt - bconf->combo_high_duty_min;
                     }
-                    switch (bl_config.combo_high_port) {
+                    switch (bconf->combo_high_port) {
                         case BL_PWM_A:
                             aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
                             break;
@@ -719,16 +678,16 @@ static void set_backlight_level(unsigned level)
                     }
 
                     //set combo_low duty
-                    level = (bl_config.combo_low_duty_max - bl_config.combo_low_duty_min) * (level - bl_config.level_min) / (bl_config.combo_level_switch - bl_config.level_min) + bl_config.combo_low_duty_min;
-                    if (bl_config.combo_low_method == BL_CTL_PWM_NEGATIVE) {
-                        pwm_hi = bl_config.combo_low_cnt - level;
+                    level = (bconf->combo_low_duty_max - bconf->combo_low_duty_min) * (level - bconf->level_min) / (bconf->combo_level_switch - bconf->level_min) + bconf->combo_low_duty_min;
+                    if (bconf->combo_low_method == BL_CTL_PWM_NEGATIVE) {
+                        pwm_hi = bconf->combo_low_cnt - level;
                         pwm_lo = level;
                     }
                     else {
                         pwm_hi = level;
-                        pwm_lo = bl_config.combo_low_cnt - level;
+                        pwm_lo = bconf->combo_low_cnt - level;
                     }
-                    switch (bl_config.combo_low_port) {
+                    switch (bconf->combo_low_port) {
                         case BL_PWM_A:
                             aml_write_reg32(P_PWM_PWM_A, (pwm_hi << 16) | (pwm_lo));
                             break;
@@ -754,6 +713,7 @@ static void set_backlight_level(unsigned level)
                     }
                 }
                 break;
+#ifdef CONFIG_AML_BACKLIGHT_EXTERN
             case BL_CTL_EXTERN:
                 bl_extern_driver = aml_bl_extern_get_driver();
                 if (bl_extern_driver == NULL) {
@@ -770,10 +730,11 @@ static void set_backlight_level(unsigned level)
                     }
                 }
                 break;
+#endif
             default:
                 break;
         }
-        if ((bl_status == 3) && (bl_real_status == 0))
+        if ((amlbl->state & BL_STATE_REAL_ON) == 0)//((bl_status == 3) && (bl_real_status == 0))
             bl_power_on(DRV_BL_FLAG);
     }
     mutex_unlock(&bl_level_mutex);
@@ -781,247 +742,32 @@ static void set_backlight_level(unsigned level)
 
 unsigned get_backlight_level(void)
 {
-    DPRINT("%s: %d\n", __FUNCTION__, bl_level);
-    return bl_level;
-}
-#endif
-#endif
-
-struct aml_bl {
-    const struct aml_bl_platform_data   *pdata;
-    struct backlight_device         *bldev;
-    struct platform_device          *pdev;
-};
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TVD)
-
- #define CONFIG_AML_BL_CTL_PWM 1
-
-#define BL_POWER_ON		0
-#define BL_POWER_OFF		1
-
-#define TV_BL_MAX_LEVEL    255
-#define TV_BL_MIN_LEVEL    0
-
-typedef struct {
-	unsigned int pwm_hz;
-	unsigned int ref_bl_level;
-
-	unsigned int bl_power_pin;
-	struct aml_bl *amlbl;
-	struct pinctrl *p;
-} TV_Bl_Config_t;
-
-static TV_Bl_Config_t tv_bl_config = {
-	.pwm_hz = 0,
-	.ref_bl_level = 0,
-	.bl_power_pin = -1,
-};
-
-#ifdef CONFIG_AML_BL_PWM_ATTR
-static void tv_init_bl(unsigned int pwm)
-{
-#ifdef CONFIG_AML_BL_CTL_PWM
-	char buf[8] = "pwm_a";
-	tv_bl_config.pwm_hz = pwm;
-	tv_bl_config.p = devm_pinctrl_get_select(&tv_bl_config.amlbl->pdev->dev, buf);
-	if (IS_ERR(tv_bl_config.p))
-		pr_err("get backlight pinmux pwm_a error.\n");
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_2, (READ_CBUS_REG(PERIPHS_PIN_MUX_2) | (1 << 0)) );
-#endif // CONFIG_AML_BL_CTL_PWM
-}
-#else
-static void tv_init_bl(void)
-{
-#ifdef CONFIG_AML_BL_CTL_PWM
-	char bufa[8] = "pwm_a";
-	tv_bl_config.p = devm_pinctrl_get_select(&tv_bl_config.amlbl->pdev->dev, bufa);
-	if (IS_ERR(tv_bl_config.p))
-		pr_err("get backlight pinmux pwm_a error.\n");
-	WRITE_CBUS_REG(PERIPHS_PIN_MUX_2, (READ_CBUS_REG(PERIPHS_PIN_MUX_2) | (1 << 0)) );
-#ifdef CONFIG_AML_BL_PWM_60HZ
-	char bufvs[8] = "pwm_vs";
-	tv_bl_config.p = devm_pinctrl_get_select(&tv_bl_config.amlbl->pdev->dev, bufvs);
-	if (IS_ERR(tv_bl_config.p))
-		pr_err("get backlight pinmux pwm_vs error.\n");
-#endif
-#endif // CONFIG_AML_BL_CTL_PWM
-}
-#endif
-
-static void tv_power_on_bl(void)
-{
-	bl_gpio_direction_output(tv_bl_config.bl_power_pin,BL_POWER_ON);
-	pr_info("%s\n", __func__);
-}
-
-static void tv_power_off_bl (void)
-{
-	bl_gpio_direction_output(tv_bl_config.bl_power_pin,BL_POWER_OFF);
-	pr_info("%s\n", __func__);
-}
-
-static unsigned tv_get_bl_level(void)
-{
-	return tv_bl_config.ref_bl_level;
-}
-
-void pwm_enable(void)
-{
-	WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_2,1,2,1);
-}
-EXPORT_SYMBOL(pwm_enable);
-
-void pwm_disable(void)
-{
-	aml_set_reg32_bits(P_PREG_PAD_GPIO1_EN_N,0,30,1);
-	aml_set_reg32_bits(P_PREG_PAD_GPIO1_O,0,30,1);
-	WRITE_CBUS_REG_BITS(PERIPHS_PIN_MUX_2,0,2,1);
-}
-EXPORT_SYMBOL(pwm_disable);
-
-#ifdef CONFIG_AML_BL_PWM_ATTR
-static void tv_set_bl_level(unsigned int level,unsigned int pwm)
-{
-	int pwm_max = 0;
-
-	if(pwm) {
-		tv_bl_config.pwm_hz = pwm;
-	}
-
-	pwm_max = (160 * 1248) / tv_bl_config.pwm_hz;
-
-	tv_bl_config.ref_bl_level = level;
-
-	if (level > TV_BL_MAX_LEVEL)
-		level = TV_BL_MAX_LEVEL;
-
-	if (level < TV_BL_MIN_LEVEL)
-		level = TV_BL_MIN_LEVEL;
-
-#ifdef CONFIG_AML_BL_CTL_GPIO
-	level = level * 15 / TV_BL_MAX_LEVEL;
-	level = 15 - level;
-	aml_set_reg32_bits(P_LED_PWM_REG0, level, 0, 4);
-#endif // CONFIG_AML_BL_CTL_GPIO
-
-#ifdef CONFIG_AML_BL_CTL_PWM
-	if(tv_bl_config.pwm_hz == 60) {
-		WRITE_CBUS_REG(0x2730,0x02320000);
-		WRITE_CBUS_REG(0x2734,0x000a000a);
-		WRITE_CBUS_REG(0x2730,(level*1000)/255<<16);
-	} else {
-		WRITE_CBUS_REG(PWM_MISC_REG_AB, ((READ_CBUS_REG(PWM_MISC_REG_AB) &~((1 << 15)|(0x7F << 8)|(0x3 << 4)))|(1 << 0))|\
-					((1 << 15)|(0x77 << 8)|(0x0<< 4)|(1 << 0)) ); //0xf701 120div=119
-		level = level * pwm_max / TV_BL_MAX_LEVEL ;
-		WRITE_CBUS_REG( PWM_PWM_A, ((level << 16) | ((pwm_max - level) << 0)) );
-		//pr_info("%s,%d PWM_A level=%d\n", __func__, __LINE__, level);
-	}
-#endif // CONFIG_AML_BL_CTL_PWM
-}
-#else
-static void tv_set_bl_level(unsigned int level)
-{
-	int pwm_max = 0;
-
-	tv_bl_config.ref_bl_level = level;
-
-	if (level > TV_BL_MAX_LEVEL)
-		level = TV_BL_MAX_LEVEL;
-
-	if (level < TV_BL_MIN_LEVEL)
-		level = TV_BL_MIN_LEVEL;
-
-	pwm_max = (160 * 1248) / tv_bl_config.pwm_hz;
-
-#ifdef CONFIG_AML_BL_CTL_GPIO
-	level = level * 15 / TV_BL_MAX_LEVEL;
-	level = 15 - level;
-	aml_set_reg32_bits(P_LED_PWM_REG0, level, 0, 4);
-#endif // CONFIG_AML_BL_CTL_GPIO
-
-#ifdef CONFIG_AML_BL_CTL_PWM
-	WRITE_CBUS_REG(PWM_MISC_REG_AB, ((READ_CBUS_REG(PWM_MISC_REG_AB) &~((1 << 15)|(0x7F << 8)|(0x3 << 4)))|(1 << 0)) |\
-				((1 << 15)|(0x77 << 8)|(0x0<< 4)|(1 << 0))); //0xf701 120div=119
-	level = level * pwm_max / TV_BL_MAX_LEVEL ;
-	WRITE_CBUS_REG( PWM_PWM_A, ((level << 16) | ((pwm_max - level) << 0)) );
-	//pr_info("%s,%d PWM_A level=%d\n", __func__, __LINE__, level);
-#ifdef CONFIG_AML_BL_PWM_60HZ
-	WRITE_CBUS_REG(0x2730,0x02320000);
-	WRITE_CBUS_REG(0x2734,0x000a000a);
-	WRITE_CBUS_REG(0x2730,(level*1000)/255<<16);
-#endif
-#endif // CONFIG_AML_BL_CTL_PWM
-}
-#endif // CONFIG_AML_BL_PWM_ATTR
-
-static int tv_get_backlight_config(struct platform_device *pdev)
-{
-	const char *gpio_name = NULL;
-	unsigned int bl_power_pin = -1;
-	unsigned int value;
-	int ret = 0;
-
-	if (pdev->dev.of_node) {
-		gpio_name = of_get_property(pdev->dev.of_node, "power_pin", NULL);
-		if(gpio_name) {
-			bl_power_pin = amlogic_gpio_name_map_num(gpio_name);
-			bl_gpio_request(bl_power_pin);
-			tv_bl_config.bl_power_pin = bl_power_pin;
-		} else {
-			pr_err("don't find to match \"power_pin\" \n");
-		}
-
-		ret = of_property_read_u32(pdev->dev.of_node, "pwm_hz", &value);
-		if(!ret) {
-			tv_bl_config.pwm_hz = value;
-		} else {
-			pr_err("don't find to match \"pwm_hz\" \n");
-		}
-	}
-	return ret;
-}
+    if (amlbl == NULL) {
+        BL_PR("no bl data\n");
+        return 0;
+    }
 
-static int tv_rm_backlight_config(struct platform_device *pdev)
-{
-	if (pdev->dev.of_node) {
-		if(tv_bl_config.bl_power_pin != -1) {
-			bl_gpio_free(tv_bl_config.bl_power_pin);
-		}
-	}
-	return 0;
+    BL_PR("aml bl state: 0x%x\n", amlbl->state);
+    return amlbl->level;
 }
-#endif // MESON_CPU_TYPE
 
 static int aml_bl_update_status(struct backlight_device *bd)
 {
-    struct aml_bl *amlbl = bl_get_data(bd);
     int brightness = bd->props.brightness;
 
-    //DPRINT("%s() brightness=%d\n", __FUNCTION__, brightness);
-    //DPRINT("%s() pdata->set_bl_level=%p\n", __FUNCTION__, amlbl->pdata->set_bl_level);
-
     if (brightness < 0)
         brightness = 0;
     else if (brightness > 255)
         brightness = 255;
 
-    if (amlbl->pdata->set_bl_level)
-        amlbl->pdata->set_bl_level(brightness);
+    set_backlight_level(brightness);
 
     return 0;
 }
 
 static int aml_bl_get_brightness(struct backlight_device *bd)
 {
-    struct aml_bl *amlbl = bl_get_data(bd);
-
-    DPRINT("%s() pdata->get_bl_level=%p\n", __FUNCTION__, amlbl->pdata->get_bl_level);
-
-    if (amlbl->pdata->get_bl_level)
-        return amlbl->pdata->get_bl_level();
-    else
-        return 0;
+    return get_backlight_level();
 }
 
 static const struct backlight_ops aml_bl_ops = {
@@ -1029,30 +775,8 @@ static const struct backlight_ops aml_bl_ops = {
     .update_status  = aml_bl_update_status,
 };
 
-#ifdef CONFIG_USE_OF
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TVD)
-static struct aml_bl_platform_data meson_backlight_platform = {
-	.bl_init            = tv_init_bl,
-	.power_on_bl        = tv_power_on_bl,
-	.power_off_bl       = tv_power_off_bl,
-	.get_bl_level       = tv_get_bl_level,
-	.set_bl_level       = tv_set_bl_level,
-	.max_brightness     = 255,
-	.dft_brightness     = 200,
-};
-#else
-static struct aml_bl_platform_data meson_backlight_platform =
-{
-    //.power_on_bl = power_on_backlight,
-    //.power_off_bl = power_off_backlight,
-    .get_bl_level = get_backlight_level,
-    .set_bl_level = set_backlight_level,
-    .max_brightness = BL_LEVEL_MAX,
-    .dft_brightness = BL_LEVEL_DEFAULT,
-};
-#endif
-
-#define AMLOGIC_BL_DRV_DATA ((kernel_ulong_t)&meson_backlight_platform)
+#ifdef CONFIG_OF
+#define AMLOGIC_BL_DRV_DATA ((kernel_ulong_t)&bl_config)
 
 static const struct of_device_id backlight_dt_match[] = {
     {
@@ -1065,21 +789,18 @@ static const struct of_device_id backlight_dt_match[] = {
 #define backlight_dt_match NULL
 #endif
 
-#ifdef CONFIG_USE_OF
-static inline struct aml_bl_platform_data *bl_get_driver_data(struct platform_device *pdev)
+#ifdef CONFIG_OF
+static inline struct lcd_bl_config_s *bl_get_driver_data(struct platform_device *pdev)
 {
     const struct of_device_id *match;
 
     if(pdev->dev.of_node) {
-        //DPRINT("***of_device: get backlight driver data.***\n");
         match = of_match_node(backlight_dt_match, pdev->dev.of_node);
-        return (struct aml_bl_platform_data *)match->data;
+        return (struct lcd_bl_config_s *)match->data;
     }
     return NULL;
 }
-#endif
 
-#ifdef CONFIG_AML_LCD_BACKLIGHT_SUPPORT
 static inline int _get_backlight_config(struct platform_device *pdev)
 {
     int ret=0;
@@ -1168,28 +889,28 @@ static inline int _get_backlight_config(struct platform_device *pdev)
             ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 1, &str);
             if (ret) {
                 printk("faild to get bl_gpio_port_on!\n");
-                bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+                bl_config.gpio_on = BL_GPIO_OUTPUT_HIGH;
             }
             else {
                 if (strcmp(str, "2") == 0)
-                    bl_config.gpio_on = LCD_POWER_GPIO_INPUT;
+                    bl_config.gpio_on = BL_GPIO_INPUT;
                 else if(strcmp(str, "0") == 0)
-                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_LOW;
+                    bl_config.gpio_on = BL_GPIO_OUTPUT_LOW;
                 else
-                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+                    bl_config.gpio_on = BL_GPIO_OUTPUT_HIGH;
             }
             ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 2, &str);
             if (ret) {
                 printk("faild to get bl_gpio_port_off!\n");
-                bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+                bl_config.gpio_off = BL_GPIO_OUTPUT_LOW;
             }
             else {
                 if (strcmp(str, "2") == 0)
-                    bl_config.gpio_off = LCD_POWER_GPIO_INPUT;
+                    bl_config.gpio_off = BL_GPIO_INPUT;
                 else if(strcmp(str, "1") == 0)
-                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_HIGH;
+                    bl_config.gpio_off = BL_GPIO_OUTPUT_HIGH;
                 else
-                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+                    bl_config.gpio_off = BL_GPIO_OUTPUT_LOW;
             }
             DPRINT("bl gpio_on=%u, bl gpio_off=%u\n", bl_config.gpio_on, bl_config.gpio_off);
             ret = of_property_read_u32_array(pdev->dev.of_node,"bl_gpio_dim_max_min",&bl_para[0],2);
@@ -1242,28 +963,28 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                           ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 1, &str);
             if (ret) {
                 printk("faild to get bl_gpio_port_on!\n");
-                bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+                bl_config.gpio_on = BL_GPIO_OUTPUT_HIGH;
             }
             else {
                 if (strcmp(str, "2") == 0)
-                    bl_config.gpio_on = LCD_POWER_GPIO_INPUT;
+                    bl_config.gpio_on = BL_GPIO_INPUT;
                 else if(strcmp(str, "0") == 0)
-                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_LOW;
+                    bl_config.gpio_on = BL_GPIO_OUTPUT_LOW;
                 else
-                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+                    bl_config.gpio_on = BL_GPIO_OUTPUT_HIGH;
             }
             ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 2, &str);
             if (ret) {
                 printk("faild to get bl_gpio_port_off!\n");
-                bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+                bl_config.gpio_off = BL_GPIO_OUTPUT_LOW;
             }
             else {
                 if (strcmp(str, "2") == 0)
-                    bl_config.gpio_off = LCD_POWER_GPIO_INPUT;
+                    bl_config.gpio_off = BL_GPIO_INPUT;
                 else if(strcmp(str, "1") == 0)
-                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_HIGH;
+                    bl_config.gpio_off = BL_GPIO_OUTPUT_HIGH;
                 else
-                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+                    bl_config.gpio_off = BL_GPIO_OUTPUT_LOW;
             }
             DPRINT("gpio_on=%u, gpio_off=%u\n", bl_config.gpio_on, bl_config.gpio_off);
           }
@@ -1465,112 +1186,44 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 }
 #endif
 
-//****************************
-#ifdef CONFIG_AML_LCD_BACKLIGHT_SUPPORT
-static struct class *bl_debug_class = NULL;
-static ssize_t bl_status_read(struct class *class, struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "read backlight status: bl_real_status=%s(%d), bl_status=%s(%d), bl_level=%d\n", (bl_real_status ? "ON" : "OFF"), bl_real_status, 
-						((bl_status == 0) ? "OFF" : ((bl_status == 1) ? "lcd_on_bl_off" : "lcd_on_bl_on")), bl_status, bl_level);
-}
-
-static struct class_attribute bl_debug_class_attrs[] = {
-	__ATTR(status,  S_IRUGO | S_IWUSR, bl_status_read, NULL),
-};
-
-static int creat_bl_attr(void)
-{
-    int i;
-
-    bl_debug_class = class_create(THIS_MODULE, "lcd_bl");
-    if(IS_ERR(bl_debug_class)) {
-        printk("create lcd_bl debug class fail\n");
-        return -1;
-    }
-
-    for(i=0;i<ARRAY_SIZE(bl_debug_class_attrs);i++) {
-        if (class_create_file(bl_debug_class, &bl_debug_class_attrs[i])) {
-            printk("create lcd_bl debug attribute %s fail\n", bl_debug_class_attrs[i].attr.name);
-        }
-    }
-
-    return 0;
-}
-
-static int remove_bl_attr(void)
-{
-    int i;
-
-    if (bl_debug_class == NULL)
-        return -1;
-
-    for(i=0;i<ARRAY_SIZE(bl_debug_class_attrs);i++) {
-        class_remove_file(bl_debug_class, &bl_debug_class_attrs[i]);
-    }
-    class_destroy(bl_debug_class);
-    bl_debug_class = NULL;
-
-    return 0;
-}
-#endif
-//****************************
-
 static int aml_bl_probe(struct platform_device *pdev)
 {
     struct backlight_properties props;
-    const struct aml_bl_platform_data *pdata;
+    struct lcd_bl_config_s *pdata;
     struct backlight_device *bldev;
-    struct aml_bl *amlbl;
     int retval;
 
     DTRACE();
 
-    amlbl = kzalloc(sizeof(struct aml_bl), GFP_KERNEL);
+    amlbl = kzalloc(sizeof(struct aml_bl_s), GFP_KERNEL);
     if (!amlbl)
     {
-        printk(KERN_ERR "%s() kzalloc error\n", __FUNCTION__);
+        printk(KERN_ERR "%s() kzalloc error\n", __func__);
         return -ENOMEM;
     }
 
-    amlbl->pdev = pdev;
+    //amlbl->pdev = pdev;
 
-#ifdef CONFIG_USE_OF
+#ifdef CONFIG_OF
+    _get_backlight_config(pdev);
     pdata = bl_get_driver_data(pdev);
 #else
     pdata = pdev->dev.platform_data;
 #endif
     if (!pdata) {
-        printk(KERN_ERR "%s() missing platform data\n", __FUNCTION__);
+        printk(KERN_ERR "%s() missing platform data\n", __func__);
         retval = -ENODEV;
         goto err;
     }
 
-#ifdef CONFIG_USE_OF
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TVD)
-	tv_bl_config.amlbl = amlbl;
-	tv_get_backlight_config(pdev);
-#else
-	_get_backlight_config(pdev);
-#endif
-#endif
-
-    amlbl->pdata = pdata;
-
-    DPRINT("%s() pdata->bl_init=%p\n", __FUNCTION__, pdata->bl_init);
-    DPRINT("%s() pdata->power_on_bl=%p\n", __FUNCTION__, pdata->power_on_bl);
-    DPRINT("%s() pdata->power_off_bl=%p\n", __FUNCTION__, pdata->power_off_bl);
-    DPRINT("%s() pdata->set_bl_level=%p\n", __FUNCTION__, pdata->set_bl_level);
-    DPRINT("%s() pdata->get_bl_level=%p\n", __FUNCTION__, pdata->get_bl_level);
-    DPRINT("%s() pdata->max_brightness=%d\n", __FUNCTION__, pdata->max_brightness);
-    DPRINT("%s() pdata->dft_brightness=%d\n", __FUNCTION__, pdata->dft_brightness);
+    amlbl->bconf = pdata;
 
     memset(&props, 0, sizeof(struct backlight_properties));
-#ifdef CONFIG_USE_OF
-    props.max_brightness = (bl_config.level_max > 0 ? bl_config.level_max : BL_LEVEL_MAX);
-#else
-    props.max_brightness = (pdata->max_brightness > 0 ? pdata->max_brightness : BL_LEVEL_MAX);
-#endif
     props.type = BACKLIGHT_RAW;
+    props.power = FB_BLANK_UNBLANK; /* full on */
+    props.max_brightness = (pdata->level_max > 0 ? pdata->level_max : BL_LEVEL_MAX);
+    props.brightness = (pdata->level_default > 0 ? pdata->level_default : BL_LEVEL_DEFAULT);
+
     bldev = backlight_device_register("aml-bl", &pdev->dev, amlbl, &aml_bl_ops, &props);
     if (IS_ERR(bldev)) {
         printk(KERN_ERR "failed to register backlight\n");
@@ -1579,36 +1232,20 @@ static int aml_bl_probe(struct platform_device *pdev)
     }
 
     amlbl->bldev = bldev;
-
-    platform_set_drvdata(pdev, amlbl);
-
-    bldev->props.power = FB_BLANK_UNBLANK;
-#ifdef CONFIG_USE_OF
-    bldev->props.brightness = (bl_config.level_default > 0 ? bl_config.level_default : BL_LEVEL_DEFAULT);
-#else
-    bldev->props.brightness = (pdata->dft_brightness > 0 ? pdata->dft_brightness : BL_LEVEL_DEFAULT);
-#endif
+    //platform_set_drvdata(pdev, amlbl);
 
     //init workqueue
-    INIT_DELAYED_WORK(&bl_config.bl_delayed_work, bl_delayd_on);
-    //bl_config.workqueue = create_singlethread_workqueue("bl_power_on_queue");
-    bl_config.workqueue = create_workqueue("bl_power_on_queue");
-    if (bl_config.workqueue == NULL) {
+    INIT_DELAYED_WORK(&amlbl->bl_delayed_work, bl_delayd_on);
+    //amlbl->workqueue = create_singlethread_workqueue("bl_power_on_queue");
+    amlbl->workqueue = create_workqueue("bl_power_on_queue");
+    if (amlbl->workqueue == NULL) {
         printk("can't create bl work queue\n");
     }
 
-    if (pdata->bl_init)
-        pdata->bl_init();
-    if (pdata->power_on_bl)
-        pdata->power_on_bl();
-    if (pdata->set_bl_level)
-        pdata->set_bl_level(bldev->props.brightness);
-
-#ifdef CONFIG_AML_LCD_BACKLIGHT_SUPPORT
-    creat_bl_attr();
-#endif
+    amlbl->state = (BL_STATE_LCD_ON | BL_STATE_BL_ON | BL_STATE_REAL_ON);
+    aml_bl_update_status(amlbl->bldev);
 
-    printk("aml bl probe OK.\n");
+    printk("aml bl probe OK\n");
     return 0;
 
 err:
@@ -1618,20 +1255,12 @@ err:
 
 static int __exit aml_bl_remove(struct platform_device *pdev)
 {
-    struct aml_bl *amlbl = platform_get_drvdata(pdev);
+    //struct aml_bl_s *amlbl = platform_get_drvdata(pdev);
 
     DTRACE();
 
-#ifdef CONFIG_AML_LCD_BACKLIGHT_SUPPORT
-    remove_bl_attr();
-#endif
-
-    if (bl_config.workqueue)
-        destroy_workqueue(bl_config.workqueue);
-
-#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV)||(MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TVD)
-	tv_rm_backlight_config(pdev);
-#endif
+    if (amlbl->workqueue)
+        destroy_workqueue(amlbl->workqueue);
 
     backlight_device_unregister(amlbl->bldev);
     platform_set_drvdata(pdev, NULL);
@@ -1644,7 +1273,7 @@ static struct platform_driver aml_bl_driver = {
     .driver = {
         .name = "aml-bl",
         .owner = THIS_MODULE,
-#ifdef CONFIG_USE_OF
+#ifdef CONFIG_OF
         .of_match_table = backlight_dt_match,
 #endif
     },
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/Kconfig b/drivers/amlogic/display/backlight/aml_bl_extern/Kconfig
new file mode 100644
index 000000000000..8bc47f8dcab7
--- /dev/null
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/Kconfig
@@ -0,0 +1,23 @@
+
+menu "Amlogic Backlight Extern Support"
+
+config AML_BL_EXTERN_PMU_AML1218
+	boolean "AML bl extern pmu_aml1218 support"
+	default y
+	help
+		AML bl extern pmu_aml1218 support
+
+config AML_BL_EXTERN_MIPI_LT070ME05
+	boolean "AML bl extern mipi_LT070ME05 support"
+	default n
+	help
+		AML bl extern mipi_LT070ME05 support
+
+config AML_BL_EXTERN_I2C_LP8556
+	boolean "AML bl extern i2c_lp8556 support"
+	default n
+	help
+		AML bl extern i2c_lp8556 support
+
+
+endmenu
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/Makefile b/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
index 9d057e56bf61..a88abfd2096b 100644
--- a/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
@@ -1,6 +1,5 @@
 
 obj-y	+= aml_bl_extern.o
-obj-y	+= i2c_lp8556.o
-obj-y	+= pmu_aml1218.o
-obj-y	+= mipi_LT070ME05.o
-
+obj-$(CONFIG_AML_BL_EXTERN_PMU_AML1218)      += pmu_aml1218.o
+obj-$(CONFIG_AML_BL_EXTERN_MIPI_LT070ME05)   += mipi_LT070ME05.o
+obj-$(CONFIG_AML_BL_EXTERN_I2C_LP8556)       += i2c_lp8556.o
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c b/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c
index c638bc07eec1..eddd0863e9e2 100755
--- a/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c
@@ -10,8 +10,8 @@
 #include <linux/of.h>
 #include <mach/am_regs.h>
 #include <mach/gpio.h>
+#include <linux/amlogic/aml_lcd_bl.h>
 #include <linux/amlogic/aml_bl_extern.h>
-#include <linux/amlogic/vout/lcdoutc.h>
 
 //#define BL_EXT_DEBUG_INFO
 #ifdef BL_EXT_DEBUG_INFO
@@ -95,11 +95,11 @@ int get_bl_extern_dt_data(struct device_node* of_node, struct bl_extern_config_t
     }
     else {
         if (strncmp(str, "2", 1) == 0)
-            pdata->gpio_on = LCD_POWER_GPIO_INPUT;
+            pdata->gpio_on = BL_GPIO_INPUT;
         else if (strncmp(str, "0", 1) == 0)
-            pdata->gpio_on = LCD_POWER_GPIO_OUTPUT_LOW;
+            pdata->gpio_on = BL_GPIO_OUTPUT_LOW;
         else
-            pdata->gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+            pdata->gpio_on = BL_GPIO_OUTPUT_HIGH;
     }
     ret = of_property_read_string_index(of_node, "gpio_enable_on_off", 2, &str);
     if (ret) {
@@ -107,11 +107,11 @@ int get_bl_extern_dt_data(struct device_node* of_node, struct bl_extern_config_t
     }
     else {
         if (strncmp(str, "2", 1) == 0)
-            pdata->gpio_off = LCD_POWER_GPIO_INPUT;
+            pdata->gpio_off = BL_GPIO_INPUT;
         else if (strncmp(str, "1", 1) == 0)
-            pdata->gpio_off = LCD_POWER_GPIO_OUTPUT_HIGH;
+            pdata->gpio_off = BL_GPIO_OUTPUT_HIGH;
         else
-            pdata->gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+            pdata->gpio_off = BL_GPIO_OUTPUT_LOW;
     }
     DBG_PRINT("%s: gpio_on = %d, gpio_off = %d \n", pdata->name, pdata->gpio_on, pdata->gpio_off);
     switch (pdata->type) {
diff --git a/include/linux/amlogic/aml_lcd_bl.h b/include/linux/amlogic/aml_lcd_bl.h
index 149f18f46864..902796f7d09f 100755
--- a/include/linux/amlogic/aml_lcd_bl.h
+++ b/include/linux/amlogic/aml_lcd_bl.h
@@ -1 +1 @@
-/* * AMLOGIC lcd backlight support header file for backlight driver. * * * Author:  Evoke Zhang <evoke.zhang@amlogic.com> * */#ifndef __AML_LCD_BACKLIGHT_H#define __AML_LCD_BACKLIGHT_H#define	DRV_BL_FLAG		0#define LCD_BL_FLAG		1#define BL_LEVEL_MAX    		255#define BL_LEVEL_MIN    		10#define BL_LEVEL_OFF			1#define BL_LEVEL_MID    		128#define BL_LEVEL_MID_MAPPED		102extern void bl_power_on(int bl_flag);extern void bl_power_off(int bl_flag);extern unsigned get_backlight_level(void);#endif
\ No newline at end of file
+/* * AMLOGIC lcd backlight support header file for backlight driver. * * * Author:  Evoke Zhang <evoke.zhang@amlogic.com> * */#ifndef __AML_LCD_BACKLIGHT_H#define __AML_LCD_BACKLIGHT_H#include <linux/backlight.h>#include <linux/workqueue.h>#include <mach/cpu.h>#include <linux/amlogic/aml_gpio_consumer.h>#include <linux/pinctrl/consumer.h>#define DRV_BL_FLAG		0#define LCD_BL_FLAG		1#define BL_LEVEL_MAX    		255#define BL_LEVEL_MIN    		10#define BL_LEVEL_OFF			1#define BL_LEVEL_MID    		128#define BL_LEVEL_MID_MAPPED		102/* for lcd backlight power */typedef enum {    BL_CTL_GPIO = 0,    BL_CTL_PWM_NEGATIVE = 1,    BL_CTL_PWM_POSITIVE = 2,    BL_CTL_PWM_COMBO = 3,    BL_CTL_EXTERN = 4,    BL_CTL_MAX = 5,} BL_Ctrl_Method_t;typedef enum {    BL_PWM_A = 0,    BL_PWM_B,    BL_PWM_C,    BL_PWM_D,#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)    BL_PWM_E,    BL_PWM_F,#endif    BL_PWM_MAX,} BL_PWM_t;struct lcd_bl_config_s {    unsigned level_default;    unsigned level_mid;    unsigned level_mid_mapping;    unsigned level_min;    unsigned level_max;    unsigned short power_on_delay;    unsigned char method;    int gpio;    unsigned char gpio_on;    unsigned char gpio_off;    unsigned dim_max;    unsigned dim_min;    unsigned char pwm_port;    unsigned char pwm_gpio_used;    unsigned pwm_cnt;    unsigned pwm_pre_div;    unsigned pwm_max;    unsigned pwm_min;    unsigned combo_level_switch;    unsigned char combo_high_port;    unsigned char combo_high_method;    unsigned char combo_low_port;    unsigned char combo_low_method;    unsigned combo_high_cnt;    unsigned combo_high_pre_div;    unsigned combo_high_duty_max;    unsigned combo_high_duty_min;    unsigned combo_low_cnt;    unsigned combo_low_pre_div;    unsigned combo_low_duty_max;    unsigned combo_low_duty_min;    struct pinctrl *p;};/* backlight_properties: state *//* Flags used to signal drivers of state changes *//* Upper 4 bits are reserved for driver internal use */#define BL_STATE_LCD_ON     (1 << 3)#define BL_STATE_BL_ON      (1 << 2)#define BL_STATE_REAL_ON    (1 << 0)struct aml_bl_s {    unsigned int level;    unsigned int state;    struct lcd_bl_config_s      *bconf;    struct backlight_device     *bldev;    //struct platform_device      *pdev;    struct workqueue_struct *workqueue;    struct delayed_work bl_delayed_work;};#define BL_GPIO_OUTPUT_LOW        0#define BL_GPIO_OUTPUT_HIGH       1#define BL_GPIO_INPUT             2#define BL_LEVEL_DEFAULT			BL_LEVEL_MID#define BL_NAME 				"backlight"#define bl_gpio_request(gpio) 			amlogic_gpio_request(gpio, BL_NAME)#define bl_gpio_free(gpio) 			amlogic_gpio_free(gpio, BL_NAME)#define bl_gpio_direction_input(gpio) 		amlogic_gpio_direction_input(gpio, BL_NAME)#define bl_gpio_direction_output(gpio, val)	amlogic_gpio_direction_output(gpio, val, BL_NAME)#define bl_gpio_get_value(gpio) 		amlogic_get_value(gpio, BL_NAME)#define bl_gpio_set_value(gpio,val) 		amlogic_set_value(gpio, val, BL_NAME)extern void bl_power_on(int bl_flag);extern void bl_power_off(int bl_flag);extern unsigned get_backlight_level(void);#endif
\ No newline at end of file
-- 
2.19.0

