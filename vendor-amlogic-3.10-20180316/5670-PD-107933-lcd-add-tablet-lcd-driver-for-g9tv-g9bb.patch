From f45771d6c03d1d9778fb45ed0546e5bd24712f79 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Mon, 8 Jun 2015 17:59:22 +0800
Subject: [PATCH 5670/5965] PD#107933: lcd: add tablet lcd driver for g9tv &
 g9bb

Change-Id: I1762b6bbe91fe9f16a89d235058289600aba320a
---
 .../mach-mesong9bb/include/mach/edp_tx_reg.h  |  178 --
 .../arm/mach-mesong9bb/include/mach/lcd_reg.h |   36 +-
 .../arm/mach-mesong9bb/include/mach/lcdoutc.h |   22 +-
 .../include/mach/mipi_dsi_reg.h               |  101 --
 .../mach-mesong9bb/include/mach/mlvds_regs.h  |  200 ---
 arch/arm/mach-mesong9bb/lcd/Makefile          |    1 +
 arch/arm/mach-mesong9bb/lcd/lcd_config.c      | 1472 +++++++++++++++++
 arch/arm/mach-mesong9bb/lcd/lcd_config.h      |  240 +++
 arch/arm/mach-mesong9tv/Makefile              |    2 +
 .../arm/mach-mesong9tv/include/mach/lcd_reg.h |   27 +
 .../arm/mach-mesong9tv/include/mach/lcdoutc.h |    2 +
 .../mach-mesong9tv/include/mach/mlvds_regs.h  |  200 ---
 arch/arm/mach-mesong9tv/lcd/Makefile          |    1 +
 arch/arm/mach-mesong9tv/lcd/lcd_config.c      | 1472 +++++++++++++++++
 arch/arm/mach-mesong9tv/lcd/lcd_config.h      |  240 +++
 drivers/amlogic/display/lcd/aml_lcd.c         |    1 -
 drivers/amlogic/display/lcd/aml_lcd_v2.c      |    7 +-
 drivers/amlogic/display/vout/lcdoutc.c        |  109 +-
 include/linux/amlogic/vout/lcd.h              |    9 +
 include/linux/amlogic/vout/lcd_aml.h          |    0
 include/linux/amlogic/vout/lcdoutc.h          |   19 +-
 21 files changed, 3593 insertions(+), 746 deletions(-)
 delete mode 100644 arch/arm/mach-mesong9bb/include/mach/edp_tx_reg.h
 delete mode 100644 arch/arm/mach-mesong9bb/include/mach/mipi_dsi_reg.h
 delete mode 100644 arch/arm/mach-mesong9bb/include/mach/mlvds_regs.h
 create mode 100644 arch/arm/mach-mesong9bb/lcd/Makefile
 create mode 100644 arch/arm/mach-mesong9bb/lcd/lcd_config.c
 create mode 100644 arch/arm/mach-mesong9bb/lcd/lcd_config.h
 create mode 100644 arch/arm/mach-mesong9tv/include/mach/lcd_reg.h
 delete mode 100755 arch/arm/mach-mesong9tv/include/mach/mlvds_regs.h
 create mode 100644 arch/arm/mach-mesong9tv/lcd/Makefile
 create mode 100644 arch/arm/mach-mesong9tv/lcd/lcd_config.c
 create mode 100644 arch/arm/mach-mesong9tv/lcd/lcd_config.h
 mode change 100755 => 100644 drivers/amlogic/display/lcd/aml_lcd.c
 mode change 100755 => 100644 drivers/amlogic/display/lcd/aml_lcd_v2.c
 mode change 100755 => 100644 drivers/amlogic/display/vout/lcdoutc.c
 mode change 100755 => 100644 include/linux/amlogic/vout/lcd.h
 mode change 100755 => 100644 include/linux/amlogic/vout/lcd_aml.h
 mode change 100755 => 100644 include/linux/amlogic/vout/lcdoutc.h

diff --git a/arch/arm/mach-mesong9bb/include/mach/edp_tx_reg.h b/arch/arm/mach-mesong9bb/include/mach/edp_tx_reg.h
deleted file mode 100644
index cb8047496de0..000000000000
--- a/arch/arm/mach-mesong9bb/include/mach/edp_tx_reg.h
+++ /dev/null
@@ -1,178 +0,0 @@
-#ifndef EDP_TX_REG_H
-#define EDP_TX_REG_H
-
-#define EDP_TX_LINK_BW_SET								0x0000
-#define EDP_TX_LINK_COUNT_SET							0x0004
-#define EDP_TX_ENHANCED_FRAME_EN						0x0008
-#define EDP_TX_TRAINING_PATTERN_SET						0x000c
-#define EDP_TX_LINK_QUAL_PATTERN_SET					0x0010
-#define EDP_TX_SCRAMBLING_DISABLE						0x0014
-#define EDP_TX_DOWNSPREAD_CTRL							0x0018
-#define EDP_TX_ALTERNATE_SCRAMBLER_RESET				0x001c
-#define EDP_TX_PANEL_SELF_REFRESH						0x0020
-
-#define EDP_TX_TRANSMITTER_OUTPUT_ENABLE				0x0080
-#define EDP_TX_MAIN_STREAM_ENABLE						0x0084
-#define EDP_TX_SECONDARY_STREAM_ENABLE					0x0088
-#define EDP_TX_FORCE_SCRAMBLER_RESET					0x00c0
-#define EDP_TX_USER_CONTROL_STATUS						0x00c4
-
-#define EDP_TX_CORE_CAPBILITIES							0x00f8
-#define EDP_TX_CORE_ID									0x00fc
-
-#define EDP_TX_AUX_COMMAND								0x0100
-#define EDP_TX_AUX_WRITE_FIFO							0x0104
-#define EDP_TX_AUX_ADDRESS								0x0108
-#define EDP_TX_AUX_CLOCK_DIVIDER						0x010c
-#define EDP_TX_AUX_STATE								0x0130
-#define EDP_TX_AUX_REPLY_DATA							0x0134
-#define EDP_TX_AUX_REPLY_CODE							0x0138
-#define EDP_TX_AUX_REPLY_COUNT							0x013c
-#define EDP_TX_AUX_INTERRUPT_STATUS						0x0140
-#define EDP_TX_AUX_INTERRUPT_MASK						0x0144
-#define EDP_TX_AUX_REPLY_DATA_COUNT						0x0148
-#define EDP_TX_AUX_STATUS								0x014c
-#define EDP_TX_AUX_REPLY_CLOCK_WIDTH					0x0150
-
-#define EDP_TX_MAIN_STREAM_HTOTAL						0x0180
-#define EDP_TX_MAIN_STREAM_VTOTAL						0x0184
-#define EDP_TX_MAIN_STREAM_POLARITY						0x0188
-#define EDP_TX_MAIN_STREAM_HSWIDTH						0x018c
-#define EDP_TX_MAIN_STREAM_VSWIDTH						0x0190
-#define EDP_TX_MAIN_STREAM_HRES							0x0194
-#define EDP_TX_MAIN_STREAM_VRES							0x0198
-#define EDP_TX_MAIN_STREAM_HSTART						0x019c
-#define EDP_TX_MAIN_STREAM_VSTART						0x01a0
-#define EDP_TX_MAIN_STREAM_MISC0						0x01a4
-#define EDP_TX_MAIN_STREAM_MISC1						0x01a8
-#define EDP_TX_MAIN_STREAM_M_VID						0x01ac
-#define EDP_TX_MAIN_STREAM_TRANSFER_UNIT_SIZE			0x01b0
-#define EDP_TX_MAIN_STREAM_N_VID						0x01b4
-#define EDP_TX_MAIN_STREAM_USER_PIXEL_WIDTH				0x01b8
-#define EDP_TX_MAIN_STREAM_DATA_COUNT_PER_LANE			0x01bc
-#define EDP_TX_MAIN_STREAM_INTERLACED					0x01c0
-#define EDP_TX_MAIN_STREAM_USER_SYNC_POLARITY			0x01c4
-
-#define EDP_TX_PHY_RESET								0x0200
-#define EDP_TX_PHY_PRE_EMPHASIS_LANE_0					0x0210
-#define EDP_TX_PHY_PRE_EMPHASIS_LANE_1					0x0214
-#define EDP_TX_PHY_PRE_EMPHASIS_LANE_2					0x0218
-#define EDP_TX_PHY_PRE_EMPHASIS_LANE_3					0x021c
-#define EDP_TX_PHY_VOLTAGE_DIFF_LANE_0					0x0220
-#define EDP_TX_PHY_VOLTAGE_DIFF_LANE_1					0x0224
-#define EDP_TX_PHY_VOLTAGE_DIFF_LANE_2					0x0228
-#define EDP_TX_PHY_VOLTAGE_DIFF_LANE_3					0x022c
-#define EDP_TX_PHY_TRANSMIT_PRBS7						0x0230
-#define EDP_TX_PHY_POWER_DOWN							0x0238
-#define EDP_TX_PHY_POST_EMPHASIS_LANE_0					0x0240
-#define EDP_TX_PHY_POST_EMPHASIS_LANE_1					0x0244
-#define EDP_TX_PHY_POST_EMPHASIS_LANE_2					0x024c
-#define EDP_TX_PHY_POST_EMPHASIS_LANE_3					0x024c
-#define EDP_TX_PHY_STATUS								0x0280
-
-#define EDP_TX_HDCP_ENABLE								0x0400
-#define EDP_TX_HDCP_KM_LOWER							0x0410
-#define EDP_TX_HDCP_KM_UPPER							0x0414
-#define EDP_TX_HDCP_AN_LOWER							0x0418
-#define EDP_TX_HDCP_AN_UPPER							0x041c
-#define EDP_TX_HDCP_AUTO_AN_VALUE_LOWER					0x0420
-#define EDP_TX_HDCP_AUTO_AN_VALUE_UPPER					0x0424
-#define EDP_TX_HDCP_STATUS								0x0428
-
-
-//***************************************************************************************************//
-//******note: below address are not eDP Tx core register's, but eDP sink device DPCD register's******//
-//***************************************************************************************************//
-//AUX offset address
-//DPCD information
-//***************************************************************************************************//
-#define EDP_DPCD_REVISION							0x0000
-#define EDP_DPCD_MAX_LINK_RATE						0x0001
-#define EDP_DPCD_MAX_LANE_COUNT						0x0002
-#define EDP_DPCD_MAX_DOWNSPREAD						0x0003
-#define EDP_DPCD_NUM_RX_PORTS						0x0004
-#define EDP_DPCD_DOWNSTREAM_PORTS_PRESENT			0x0005
-#define EDP_DPCD_MAIN_LINK_CODING					0x0006
-#define EDP_DPCD_NUM_DOWNSTREAM_PORTS				0x0007
-#define EDP_DPCD_RX_PORT0_CAPS_0					0x0008
-#define EDP_DPCD_RX_PORT0_CAPS_1					0x0009
-#define EDP_DPCD_RX_PORT1_CAPS_0					0x000A
-#define EDP_DPCD_RX_PORT1_CAPS_1					0x000B
-#define EDP_DPCD_I2C_SPEED_CAP						0x000C	//v1.2?
-#define EDP_DPCD_CONFIGURATION_CAP					0x000D	//v1.2?
-#define EDP_DPCD_TRAINING_AUX_RD_INTERVAL			0x000E	//v1.2?
-#define EDP_DPCD_MUTI_STREAM_TRANSPORT_CAP			0x0021	//v1.2
-#define EDP_DPCD_PSR_SUPPORT						0x0070	//v1.2?
-#define EDP_DPCD_PSR_CAPS							0x0071	//v1.2?
-#define EDP_DPCD_DOWNSTREAM_PORT_CAPS				0x0080 // Downstream Port 0 - 15 Capabilities
-
-#define EDP_DPCD_LINK_BANDWIDTH_SET					0x0100
-#define EDP_DPCD_LANE_COUNT_SET						0x0101
-#define EDP_DPCD_TRAINING_PATTERN_SET				0x0102
-#define EDP_DPCD_TRAINING_LANE0_SET					0x0103
-#define EDP_DPCD_TRAINING_LANE1_SET					0x0104
-#define EDP_DPCD_TRAINING_LANE2_SET					0x0105
-#define EDP_DPCD_TRAINING_LANE3_SET					0x0106
-#define EDP_DPCD_DOWNSPREAD_CONTROL					0x0107
-#define EDP_DPCD_MAIN_LINK_CODING_SET				0x0108
-#define EDP_DPCD_CONFIGURATION_SET					0x010A
-
-#define EDP_DPCD_SINK_COUNT							0x0200
-#define EDP_DPCD_DEVICE_SERVICE_IRQ					0x0201
-#define EDP_DPCD_STATUS_LANE_0_1					0x0202
-#define EDP_DPCD_STATUS_LANE_2_3					0x0203
-#define EDP_DPCD_LANE_ALIGNMENT_STATUS_UPDATED		0x0204
-#define EDP_DPCD_SINK_STATUS						0x0205
-#define EDP_DPCD_ADJUST_REQUEST_LANE_0_1			0x0206
-#define EDP_DPCD_ADJUST_REQUEST_LANE_2_3			0x0207
-#define EDP_DPCD_TRAINING_SCORE_LANE_0				0x0208
-#define EDP_DPCD_TRAINING_SCORE_LANE_1				0x0209
-#define EDP_DPCD_TRAINING_SCORE_LANE_2				0x020A
-#define EDP_DPCD_TRAINING_SCORE_LANE_3				0x020B
-
-#define EDP_DPCD_SYMBOL_ERROR_COUNT_LANE_0			0x0210
-#define EDP_DPCD_SYMBOL_ERROR_COUNT_LANE_1			0x0212
-#define EDP_DPCD_SYMBOL_ERROR_COUNT_LANE_2			0x0214
-#define EDP_DPCD_SYMBOL_ERROR_COUNT_LANE_3			0x0216
-
-#define EDP_DPCD_TEST_REQUEST						0x0218
-#define EDP_DPCD_TEST_LINK_RATE						0x0219
-#define EDP_DPCD_TEST_LANE_COUNT					0x0220
-#define EDP_DPCD_TEST_PATTERN						0x0221
-#define EDP_DPCD_TEST_RESPONSE						0x0260
-#define EDP_DPCD_TEST_EDID_CHECKSUM					0x0261
-
-// Source Device-Specific Field 0x0303 - 0x003FF : Reserved for vendor-specific usage
-#define EDP_DPCD_SOURCE_IEEE_OUI_0					0x0300 // Source IEEE OUI 7:0
-#define EDP_DPCD_SOURCE_IEEE_OUI_1					0x0301 // Source IEEE OUI 15:8
-#define EDP_DPCD_SOURCE_IEEE_OUI_2					0x0302 // Source IEEE OUI 23:16
-
-// Sink Device-Specific Field    0x0403 - 0x004FF : Reserved for vendor-specific usage
-#define EDP_DPCD_SINK_IEEE_OUT_0					0x0400 // Sink IEEE OUI 7:0
-#define EDP_DPCD_SINK_IEEE_OUT_1					0x0401 // Sink IEEE OUI 15:8
-#define EDP_DPCD_SINK_IEEE_OUT_2					0x0402 // Sink IEEE OUI 23:16
-
-// Branch Device-Specific Field  0x0503 - 0x005FF : Reserved for vendor-specific usage
-#define EDP_DPCD_BRANCH_DEVICE_IEEE_OUI_0			0x0500 // Branch Device IEEE OUI 7:0
-#define EDP_DPCD_BRANCH_DEVICE_IEEE_OUI_1			0x0501 // Branch Device IEEE OUI 15:8
-#define EDP_DPCD_BRANCH_DEVICE_IEEE_OUI_2			0x0502 // Branch Device IEEE OUI 23:16
-#define EDP_DPCD_SET_POWER							0x0600 // Set Power
-
-//HDCP field in DPCD
-#define EDP_DPCD_HDCP_BKSV							0x68000
-#define EDP_DPCD_HDCP_ROPRIME						0x68005
-#define EDP_DPCD_HDCP_AKSV							0x68007
-#define EDP_DPCD_HDCP_AN							0x6800c
-#define EDP_DPCD_HDCP_VPRIME_H1						0x68014
-#define EDP_DPCD_HDCP_VPRIME_H2						0x68018
-#define EDP_DPCD_HDCP_VPRIME_H3						0x6801c
-#define EDP_DPCD_HDCP_VPRIME_H4						0x68020
-#define EDP_DPCD_HDCP_VPRIME_H5						0x68024
-#define EDP_DPCD_HDCP_BCAPS							0x68028
-#define EDP_DPCD_HDCP_BSTATUS						0x68029
-#define EDP_DPCD_HDCP_BINFO							0x6802a
-#define EDP_DPCD_HDCP_KSVFIFO						0x6802c
-#define EDP_DPCD_HDCP_RESERVED						0x6803b
-#define EDP_DPCD_HDCP_DEBUG							0x680c0
-
-#endif
\ No newline at end of file
diff --git a/arch/arm/mach-mesong9bb/include/mach/lcd_reg.h b/arch/arm/mach-mesong9bb/include/mach/lcd_reg.h
index 31208b6c30bf..c29c432b7ccd 100644
--- a/arch/arm/mach-mesong9bb/include/mach/lcd_reg.h
+++ b/arch/arm/mach-mesong9bb/include/mach/lcd_reg.h
@@ -2,32 +2,26 @@
 #define LCD_CONTROLLER_REG_H
 #include <mach/io.h>
 
-#define LCD_REG_BASE_ADDR				IO_VPU_BUS_BASE	//#define IO_VPU_BUS_BASE	(IO_APB_BUS_BASE + 0x100000)
+#define LCD_VPU_BUS_BASE				(IO_APB_BUS_BASE + 0x100000)
+#define LCD_REG_BASE_ADDR				LCD_VPU_BUS_BASE
 #define LCD_CBUS_BASE_ADDR				IO_CBUS_BASE
-#define LCD_DSI_BASE_ADDR				IO_MIPI_DSI_BASE
 
 #define LCD_REG_OFFSET(reg)				(reg << 2)
-#define LCD_CBUS_OFFSET(reg)			(reg << 2)
-#define LCD_DSI_OFFSET(reg)				(reg << 2)
+#define LCD_CBUS_OFFSET(reg)				(reg << 2)
 
-#define LCD_REG_ADDR(reg)				(LCD_REG_BASE_ADDR + LCD_REG_OFFSET(reg))
-#define LCD_CBUS_ADDR(reg)				(LCD_CBUS_BASE_ADDR + LCD_CBUS_OFFSET(reg))
-#define LCD_DSI_ADDR(reg)				(LCD_DSI_BASE_ADDR + LCD_DSI_OFFSET(reg))
+#define LCD_REG_ADDR(reg)				VCBUS_REG_ADDR(reg)//(LCD_REG_BASE_ADDR + LCD_REG_OFFSET(reg))
+#define LCD_CBUS_ADDR(reg)				CBUS_REG_ADDR(reg)//(LCD_CBUS_BASE_ADDR + LCD_CBUS_OFFSET(reg))
 
-#define WRITE_LCD_REG(reg, val) 					aml_write_reg32(LCD_REG_ADDR(reg), (val))
-#define READ_LCD_REG(reg) 							aml_read_reg32(LCD_REG_ADDR(reg))
-#define WRITE_LCD_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_REG_ADDR(reg), (val),start,len)
-#define CLR_LCD_REG_MASK(reg, mask)   				aml_clr_reg32_mask(LCD_REG_ADDR(reg), (mask))
-#define SET_LCD_REG_MASK(reg, mask)     			aml_set_reg32_mask(LCD_REG_ADDR(reg), (mask))
+#define WRITE_LCD_REG(reg, val) 			aml_write_reg32(LCD_REG_ADDR(reg), (val))
+#define READ_LCD_REG(reg) 				aml_read_reg32(LCD_REG_ADDR(reg))
+#define WRITE_LCD_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_REG_ADDR(reg), (val), start, len)
+#define CLR_LCD_REG_MASK(reg, mask)   			aml_clr_reg32_mask(LCD_REG_ADDR(reg), (mask))
+#define SET_LCD_REG_MASK(reg, mask)     		aml_set_reg32_mask(LCD_REG_ADDR(reg), (mask))
 
-#define WRITE_LCD_CBUS_REG(reg, val) 					aml_write_reg32(LCD_CBUS_ADDR(reg), (val))
-#define READ_LCD_CBUS_REG(reg) 							aml_read_reg32(LCD_CBUS_ADDR(reg))
-#define WRITE_LCD_CBUS_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_CBUS_ADDR(reg), (val),start,len)
-#define CLR_LCD_CBUS_REG_MASK(reg, mask)   				aml_clr_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
-#define SET_LCD_CBUS_REG_MASK(reg, mask)     			aml_set_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+#define WRITE_LCD_CBUS_REG(reg, val) 			aml_write_reg32(LCD_CBUS_ADDR(reg), (val))
+#define READ_LCD_CBUS_REG(reg) 				aml_read_reg32(LCD_CBUS_ADDR(reg))
+#define WRITE_LCD_CBUS_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_CBUS_ADDR(reg), (val), start, len)
+#define CLR_LCD_CBUS_REG_MASK(reg, mask)   		aml_clr_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+#define SET_LCD_CBUS_REG_MASK(reg, mask)     		aml_set_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
 
-#define WRITE_DSI_REG(reg, val) *(volatile unsigned *)LCD_DSI_ADDR(reg) = (val)
-#define READ_DSI_REG(reg) (*(volatile unsigned *)LCD_DSI_ADDR(reg))
-#define WRITE_DSI_REG_BITS(reg, val, start, len) \
-	WRITE_DSI_REG(reg, (READ_DSI_REG(reg) & ~(((1L<<(len))-1)<<(start))) | ((unsigned)((val)&((1L<<(len))-1)) << (start)))
 #endif
diff --git a/arch/arm/mach-mesong9bb/include/mach/lcdoutc.h b/arch/arm/mach-mesong9bb/include/mach/lcdoutc.h
index b9f7ceb44200..a4f9639f7868 100644
--- a/arch/arm/mach-mesong9bb/include/mach/lcdoutc.h
+++ b/arch/arm/mach-mesong9bb/include/mach/lcdoutc.h
@@ -2,32 +2,14 @@
 #ifndef MACH_LCDOUTC_H
 #define MACH_LCDOUTC_H
 
+#define CONFIG_LCD_TYPE_TV_VALID
 #define CONFIG_LCD_TYPE_MID_VALID
 #define CONFIG_LCD_IF_TTL_VALID
 #define CONFIG_LCD_IF_LVDS_VALID
-#define CONFIG_LCD_IF_MIPI_VALID
+
 /*
 // lcd driver global API, special by CPU
 */
-//*************************************************************
-// For mipi-dsi external driver use
-//*************************************************************
-//mipi command(payload)
-//format:  data_type, num, data....
-//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
-
-// ----------------------------------------------------------------------------
-//                           Function: dsi_write_cmd
-// Supported Data Type: DT_GEN_SHORT_WR_0, DT_GEN_SHORT_WR_1, DT_GEN_SHORT_WR_2,
-//                      DT_DCS_SHORT_WR_0, DT_DCS_SHORT_WR_1,
-//                      DT_GEN_LONG_WR, DT_DCS_LONG_WR,
-//                      DT_SET_MAX_RET_PKT_SIZE
-//                      DT_GEN_RD_0, DT_GEN_RD_1, DT_GEN_RD_2,
-//                      DT_DCS_RD_0
-// Return:              command number
-// ----------------------------------------------------------------------------
-extern int dsi_write_cmd(unsigned char* payload);
 
-//*************************************************************
 
 #endif
diff --git a/arch/arm/mach-mesong9bb/include/mach/mipi_dsi_reg.h b/arch/arm/mach-mesong9bb/include/mach/mipi_dsi_reg.h
deleted file mode 100644
index a6c2c5688cfe..000000000000
--- a/arch/arm/mach-mesong9bb/include/mach/mipi_dsi_reg.h
+++ /dev/null
@@ -1,101 +0,0 @@
-#ifndef MIPI_DSI_PHY_REG
-#define MIPI_DSI_PHY_REG
-#define MIPI_DSI_PHY_START      0xd0150000
-#define MIPI_DSI_PHY_END        0xd015ffff
-
-#define MIPI_DSI_PHY_CTRL       0x0
-  //bit 31.  soft reset for the phy. 1 = reset. 0 = dessert the reset.
-  //bit 30.  clock lane soft reset.
-  //bit 29.  data byte lane 3 soft reset.
-  //bit 28.  data byte lane 2 soft reset.
-  //bit 27.  data byte lane 1 soft reset.
-  //bit 26.  data byte lane 0 soft reset.
-  //bit 25.   mipi dsi pll clock selection.   1:  clock from fixed 850Mhz clock source. 0: from VID2 PLL.
-  //bit 12.   mipi HSbyteclk enable.
-  //bit 11.   mipi divider clk selection.  1: select the mipi DDRCLKHS from clock divider.  0: from PLL clock.
-  //bit 10.   mipi clock divider control. 1 : /4. 0: /2.
-  //bit 9.    mipi divider output enable.
-  //bit 8.    mipi divider counter enable.
-  //bit 7.   PLL clock enable.
-  //bit 5.   LPDT data endian.  1 = transfer the high bit first. 0 : transfer the low bit first.
-  //bit 4.   HS data endian.
-  //bit 3.  force data byte lane in stop mode.
-  //bit 2.  force data byte lane 0 in reciever mode.
-  //bit 1. write 1 to sync the txclkesc input. the internal logic have to use txclkesc to decide Txvalid and Txready.
-  //bit 0.  enalbe the MIPI DSI PHY TxDDRClk.
-
-#define MIPI_DSI_CHAN_CTRL      0x1
-  //bit 31.   clk lane tx_hs_en control selection.  1 = from register. 0 use clk lane state machine.
-  //bit 30.   register bit for clock lane tx_hs_en.
-  //bit 29.  clk lane tx_lp_en contrl selection.  1 = from register. 0 from clk lane state machine.
-  //bit 28.  register bit for clock lane tx_lp_en.
-  //bit 27.  chan0 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 26.  register bit for chan0 tx_hs_en.
-  //bit 25.  chan0 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 24. register bit from chan0 tx_lp_en.
-  //bit 23.  chan0 rx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 22. register bit from chan0 rx_lp_en.
-  //bit 21.  chan0 contention detection enable control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 20. register bit from chan0 contention dectection enable.
-  //bit 19.  chan1 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 18.  register bit for chan1 tx_hs_en.
-  //bit 17.  chan1 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 16. register bit from chan1 tx_lp_en.
-  //bit 15.  chan2 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 14.  register bit for chan2 tx_hs_en.
-  //bit 13.  chan2 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 12. register bit from chan2 tx_lp_en.
-  //bit 11. chan3 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 10. register bit for chan3 tx_hs_en.
-  //bit 9.  chan3 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
-  //bit 8. register bit from chan3 tx_lp_en.
-  //bit 4.  clk chan power down. this bit is also used as the power down of the whole MIPI_DSI_PHY.
-  //bit 3.  chan3 power down.
-  //bit 2.  chan2 power down.
-  //bit 1.  chan1 power down.
-  //bit 0.  chan0 power down.
-#define MIPI_DSI_CHAN_STS       0x2
- //bit 24.     rx turn watch dog triggered.
- //bit 23      rx esc watchdog  triggered.
-  // bit 22    mbias ready.
-  //bit 21     txclkesc  synced and ready.
- //bit 20:17  clk lane state. {mbias_ready, tx_stop, tx_ulps, tx_hs_active}
- //bit 16:13 chan3 state{0, tx_stop, tx_ulps, tx_hs_active}
-  //bit 12:9 chan2 state.{0, tx_stop, tx_ulps, tx_hs_active}
- //bit 8:5  chan1 state. {0, tx_stop, tx_ulps, tx_hs_active}
- //bit 4:0  chan0 state. {TX_STOP, tx_ULPS, hs_active, direction, rxulpsesc}
-#define MIPI_DSI_CLK_TIM        0x3
-  //bit 31:24. TCLK_PREPARE.
-  //bit 23:16. TCLK_ZERO.
-  //bit 15:8.  TCLK_POST.
-  //bit 7:0.   TCLK_TRAIL.
-#define MIPI_DSI_HS_TIM         0x4
-  //bit 31:24. THS_PREPARE.
-  //bit 23:16. THS_ZERO.
-  //bit 15:8.  THS_TRAIL.
-  //bit 7:0.   THS_EXIT.
-#define MIPI_DSI_LP_TIM         0x5
-  //bit 31:24. tTA_GET.
-  //bit 23:16. tTA_GO.
-  //bit 15:8.  tTA_SURE.
-  //bit 7:0.   tLPX.
-#define MIPI_DSI_ANA_UP_TIM     0x6
-  //wait time to  MIPI DIS analog ready.
-#define MIPI_DSI_INIT_TIM       0x7
-  // TINIT.
-#define MIPI_DSI_WAKEUP_TIM     0x8
-  //TWAKEUP.
-#define MIPI_DSI_LPOK_TIM       0x9
-  //when in RxULPS check state, after the the logic enable the analog, how long we should wait to check the lP state .
-#define MIPI_DSI_LP_WCHDOG      0xa
-  //Watchdog for RX low power state no finished.
-#define MIPI_DSI_ANA_CTRL       0xb
-  //tMBIAS,  after send power up signals to analog, how long we should wait for analog powered up.
-#define MIPI_DSI_CLK_TIM1       0xc
-  //bit 31:8.  reserved for future.
-  //bit 7:0.   tCLK_PRE.
-#define MIPI_DSI_TURN_WCHDOG    0xd
-   //watchdog for turn around waiting time.
-#define MIPI_DSI_ULPS_CHECK     0xe
-   //When in RxULPS state, how frequency we should to check if the TX side out of ULPS state.
-#endif
diff --git a/arch/arm/mach-mesong9bb/include/mach/mlvds_regs.h b/arch/arm/mach-mesong9bb/include/mach/mlvds_regs.h
deleted file mode 100644
index 76d7eea780fa..000000000000
--- a/arch/arm/mach-mesong9bb/include/mach/mlvds_regs.h
+++ /dev/null
@@ -1,200 +0,0 @@
-#ifndef __MLVDS_REGS_H
-#define __MLVDS_REGS_H
-
-#define MLVDS_TCON0 0
-#define MLVDS_TCON1 1
-#define MLVDS_TCON2 2
-#define MLVDS_TCON3 3
-#define MLVDS_TCON4 4
-#define MLVDS_TCON5 5
-#define MLVDS_TCON6 6
-#define MLVDS_TCON7 7
-
-//the following register function is a little different as before
-//but the address is same
-//MTCON0-3 is full function, and MTCON4-7 is reduced.
-#define MTCON0_1ST_HS_ADDR                         0x1410  //L_STH1_HS_ADDR
-#define P_MTCON0_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON0_1ST_HE_ADDR                         0x1411  //L_STH1_HE_ADDR
-#define P_MTCON0_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON0_1ST_VS_ADDR                         0x1412  //L_STH1_VS_ADDR
-#define P_MTCON0_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON0_1ST_VE_ADDR                         0x1413  //L_STH1_VE_ADDR
-#define P_MTCON0_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_HS_ADDR                         0x1414  //L_STH2_HS_ADDR
-#define P_MTCON0_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_HE_ADDR                         0x1415  //L_STH2_HE_ADDR
-#define P_MTCON0_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_VS_ADDR                         0x1416  //L_STH2_VS_ADDR
-#define P_MTCON0_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_VE_ADDR                         0x1417  //L_STH2_VE_ADDR
-#define P_MTCON0_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON1_1ST_HS_ADDR                         0x141f  //L_CPV1_HS_ADDR
-#define P_MTCON1_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON1_1ST_HE_ADDR                         0x1420  //L_CPV1_HE_ADDR
-#define P_MTCON1_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON1_1ST_VS_ADDR                         0x1421  //L_CPV1_VS_ADDR
-#define P_MTCON1_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON1_1ST_VE_ADDR                         0x1422  //L_CPV1_VE_ADDR
-#define P_MTCON1_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_HS_ADDR                         0x1423  //L_CPV2_HS_ADDR
-#define P_MTCON1_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_HE_ADDR                         0x1424  //L_CPV2_HE_ADDR
-#define P_MTCON1_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_VS_ADDR                         0x1425  //L_CPV2_VS_ADDR
-#define P_MTCON1_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_VE_ADDR                         0x1426  //L_CPV2_VE_ADDR
-#define P_MTCON1_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON2_1ST_HS_ADDR                         0x1427  //L_STV1_HS_ADDR
-#define P_MTCON2_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON2_1ST_HE_ADDR                         0x1428  //L_STV1_HE_ADDR
-#define P_MTCON2_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON2_1ST_VS_ADDR                         0x1429  //L_STV1_VS_ADDR
-#define P_MTCON2_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON2_1ST_VE_ADDR                         0x142a  //L_STV1_VE_ADDR
-#define P_MTCON2_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_HS_ADDR                         0x142b  //L_STV2_HS_ADDR
-#define P_MTCON2_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_HE_ADDR                         0x142c  //L_STV2_HE_ADDR
-#define P_MTCON2_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_VS_ADDR                         0x142d  //L_STV2_VS_ADDR
-#define P_MTCON2_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_VE_ADDR                         0x142e  //L_STV2_VE_ADDR
-#define P_MTCON2_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON3_1ST_HS_ADDR                         0x142f  //L_OEV1_HS_ADDR
-#define P_MTCON3_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON3_1ST_HE_ADDR                         0x1430  //L_OEV1_HE_ADDR
-#define P_MTCON3_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON3_1ST_VS_ADDR                         0x1431  //L_OEV1_VS_ADDR
-#define P_MTCON3_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON3_1ST_VE_ADDR                         0x1432  //L_OEV1_VE_ADDR
-#define P_MTCON3_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_HS_ADDR                         0x1433  //L_OEV2_HS_ADDR
-#define P_MTCON3_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_HE_ADDR                         0x1434  //L_OEV2_HE_ADDR
-#define P_MTCON3_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_VS_ADDR                         0x1435  //L_OEV2_VS_ADDR
-#define P_MTCON3_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_VE_ADDR                         0x1436  //L_OEV2_VE_ADDR
-#define P_MTCON3_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON4_1ST_HS_ADDR                         0x1455  //L_HSYNC_HS_ADDR
-#define P_MTCON4_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON4_1ST_HE_ADDR                         0x1456  //L_HSYNC_HE_ADDR
-#define P_MTCON4_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON4_1ST_VS_ADDR                         0x1457  //L_HSYNC_VS_ADDR
-#define P_MTCON4_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON4_1ST_VE_ADDR                         0x1458  //L_HSYNC_VE_ADDR
-#define P_MTCON4_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON5_1ST_HS_ADDR                         0x1459  //L_VSYNC_HS_ADDR
-#define P_MTCON5_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON5_1ST_HE_ADDR                         0x145a  //L_VSYNC_HE_ADDR
-#define P_MTCON5_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON5_1ST_VS_ADDR                         0x145b  //L_VSYNC_VS_ADDR
-#define P_MTCON5_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON5_1ST_VE_ADDR                         0x145c  //L_VSYNC_VE_ADDR
-#define P_MTCON5_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON6_1ST_HS_ADDR                         0x1418  //L_OEH_HS_ADDR
-#define P_MTCON6_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON6_1ST_HE_ADDR                         0x1419  //L_OEH_HE_ADDR
-#define P_MTCON6_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON6_1ST_VS_ADDR                         0x141a  //L_OEH_VS_ADDR
-#define P_MTCON6_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON6_1ST_VE_ADDR                         0x141b  //L_OEH_VE_ADDR
-#define P_MTCON6_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON7_1ST_HS_ADDR                         0x1437  //L_OEV3_HS_ADDR
-#define P_MTCON7_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON7_1ST_HE_ADDR                         0x1438  //L_OEV3_HE_ADDR
-#define P_MTCON7_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON7_1ST_VS_ADDR                         0x1439  //L_OEV3_VS_ADDR
-#define P_MTCON7_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON7_1ST_VE_ADDR                         0x143a  //L_OEV3_VE_ADDR
-#define P_MTCON7_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_VE_ADDR) 	///../ucode/register.h
-
-//#define MLVDS_CONTROL                              0x14c3
-   #define     mLVDS_RESERVED  15    // 15
-   #define     mLVDS_double_pattern  14    // 14
-   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
-   #define     mLVDS_dual_gate  7
-   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
-   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
-   #define     mLVDS_msb_first  4
-   #define     mLVDS_PORT_SWAP  3
-   #define     mLVDS_MLSB_SWAP  2
-   #define     mLVDS_PN_SWAP    1
-   #define     mLVDS_en         0
-
-//#define MLVDS_CONFIG_HI                            0x14c7
-//#define MLVDS_CONFIG_LO                            0x14c8
-   #define     mLVDS_reset_offset         29 // Bit 31:29
-   #define     mLVDS_reset_length         23 // Bit 28:23
-   #define     mLVDS_config_reserved      20 // Bit 22:20
-   #define     mLVDS_reset_start_bit12    19 // Bit 19
-   #define     mLVDS_data_write_toggle    18
-   #define     mLVDS_data_write_ini       17
-   #define     mLVDS_data_latch_1_toggle  16
-   #define     mLVDS_data_latch_1_ini     15
-   #define     mLVDS_data_latch_0_toggle  14
-   #define     mLVDS_data_latch_0_ini     13
-   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
-   #define     mLVDS_reset_start           0 // Bit 11:0
-
-//#define TCON_DOUBLE_CTL                            0x14c9
-   #define     tcon_double_ini          8 // Bit 7:0
-   #define     tcon_double_inv          0 // Bit 7:0
-//#define TCON_PATTERN_HI                            0x14ca
-//#define TCON_PATTERN_LO                            0x14cb
-   #define     tcon_pattern_loop_data     16 // Bit 15:0
-   #define     tcon_pattern_loop_start    12 // Bit 3:0
-   #define     tcon_pattern_loop_end       8 // Bit 3:0
-   #define     tcon_pattern_enable         0 // Bit 7:0
-//#define TCON_CONTROL_HI                            0x14cc
-//#define TCON_CONTROL_LO                            0x14cd
-   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
-   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
-   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
-
-//#define MLVDS_DUAL_GATE_CTL_HI                     0x14fb
-//#define MLVDS_DUAL_GATE_CTL_LO                     0x14fc
-   #define     mlvds_tcon_field_en        24 // Bit 7:0
-   #define     mlvds_dual_gate_reserved   21 // Bit 2:0
-   #define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
-   #define     mlvds_scan_mode_odd        16 // Bit 3:0
-   #define     mlvds_scan_mode_even       12 // Bit 3:0
-   #define     mlvds_scan_mode_start_line  0 // Bit 11:0
-//#define MLVDS_RESET_CONFIG_HI                      0x14fd
-//#define MLVDS_RESET_CONFIG_LO                      0x14fe
-   #define     mLVDS_reset_range_enable   31 // Bit 0
-   #define     mLVDS_reset_range_inv      30 // Bit 0
-   #define     mLVDS_reset_config_res1    29 // Bit 0
-   #define     mLVDS_reset_range_line_0   16 // Bit 11:0
-   #define     mLVDS_reset_config_res3    13 // Bit 2:0
-   #define     mLVDS_reset_range_line_1    0 // Bit 11:0
-
-//#define MLVDS_CLK_CTL_HI                           0x14f4
-//#define MLVDS_CLK_CTL_LO                           0x14f5
-   #define     mlvds_clk_pattern_reserved 31 // Bit 31
-   #define     mpclk_dly                  28 // Bit 2:0
-   #define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
-   #define     use_mpclk                  25 // Bit 0
-   #define     mlvds_clk_half_delay       24 // Bit 0
-   #define     mlvds_clk_pattern           0 // Bit 23:0
-//#define MLVDS_DUAL_GATE_WR_START                   0x14f6
-   #define     mlvds_dual_gate_wr_start    0 // Bit 12:0
-//#define MLVDS_DUAL_GATE_WR_END                     0x14f7
-   #define     mlvds_dual_gate_wr_end      0 // Bit 12:0
-//#define MLVDS_DUAL_GATE_RD_START                   0x14f8
-   #define     mlvds_dual_gate_rd_start    0 // Bit 12:0
-//#define MLVDS_DUAL_GATE_RD_END                     0x14f9
-   #define     mlvds_dual_gate_rd_end      0 // Bit 12:0
-//#define MLVDS_SECOND_RESET_CTL                     0x14fa
-   #define     mLVDS_2nd_reset_start       0 // Bit 12:0
-
-#endif
-
diff --git a/arch/arm/mach-mesong9bb/lcd/Makefile b/arch/arm/mach-mesong9bb/lcd/Makefile
new file mode 100644
index 000000000000..47e41434403b
--- /dev/null
+++ b/arch/arm/mach-mesong9bb/lcd/Makefile
@@ -0,0 +1 @@
+obj-y		+= lcd_config.o
diff --git a/arch/arm/mach-mesong9bb/lcd/lcd_config.c b/arch/arm/mach-mesong9bb/lcd/lcd_config.c
new file mode 100644
index 000000000000..05ca437817dc
--- /dev/null
+++ b/arch/arm/mach-mesong9bb/lcd/lcd_config.c
@@ -0,0 +1,1472 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
+ * compatible dts
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <linux/amlogic/vout/aml_lcd_common.h>
+#include <mach/clock.h>
+#include <mach/vpu.h>
+#include <mach/mod_gate.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include "lcd_config.h"
+
+#define VPP_OUT_SATURATE	(1 << 0)
+
+static spinlock_t gamma_write_lock;
+static spinlock_t lcd_clk_lock;
+
+static Lcd_Config_t *lcd_conf;
+
+#define SS_LEVEL_MAX	1
+static char *lcd_ss_level_table[] = {
+	"0",
+	"0.5%",
+	"1%",
+	"1.5%",
+	"2%",
+};
+
+#define LVDS_VSWING_LEVEL_MAX  5
+static unsigned int lvds_vswing_ctrl[] = {
+/* vswing_ctrl   level   voltage */
+	0x1,   /* 0      0.2V */
+	0x3,   /* 1      0.4V */
+	0x5,   /* 2      0.6V */
+	0x6,   /* 3      0.7V */
+	0x7,   /* 4      0.8V */
+};
+
+static void print_lcd_driver_version(void)
+{
+	printk("lcd driver version: %s%s\n\n", LCD_DRV_DATE, LCD_DRV_TYPE);
+}
+
+static void lcd_ports_ctrl_lvds(Bool_t status)
+{
+	unsigned int phy_reg, phy_bit, phy_width;
+	unsigned int lane_cnt;
+	LVDS_Config_t *lconf;
+
+	lconf = lcd_conf->lcd_control.lvds_config;
+	if (status) {
+		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); /*enable lvds fifo*/
+		phy_reg = HHI_DIF_CSI_PHY_CNTL3;
+		phy_bit = BIT_PHY_LANE;
+		phy_width = WIDTH_PHY_LANE;
+		if (lconf->port_sel == LVDS_PORT_A)
+			lane_cnt = LVDS_PORT_A;
+		else if (lconf->port_sel == LVDS_PORT_B)
+			lane_cnt = LVDS_PORT_B;
+		else
+			lane_cnt = LVDS_PORT_AB;
+		WRITE_LCD_CBUS_REG_BITS(phy_reg, lane_cnt, phy_bit, phy_width);
+	} else {
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x0);
+	}
+
+	lcd_print("%s: %s\n", __func__, (status ? "ON" : "OFF"));
+}
+
+/* the string must match pinctrl-names in dts */
+const char *lcd_ports_ttl_pinmux_str[] = {
+	"ttl_6bit_hvsync_on",      /* 0 */
+	"ttl_6bit_de_on",          /* 1 */
+	"ttl_6bit_hvsync_de_on",   /* 2 */
+	"ttl_8bit_hvsync_on",      /* 3 */
+	"ttl_8bit_de_on",          /* 4 */
+	"ttl_8bit_hvsync_de_on",   /* 5 */
+	"ttl_6bit_hvsync_de_off",  /* 6 */
+	"ttl_8bit_hvsync_de_off",  /* 7 */
+};
+
+static void lcd_ports_ctrl_ttl(Bool_t status)
+{
+	struct pinctrl *pin;
+	struct pinctrl_state *s;
+	unsigned int pinmux_num;
+	int ret;
+
+	if (IS_ERR(lcd_conf->lcd_misc_ctrl.pin)) {
+		pr_info("set ttl_ports_ctrl pinmux error.\n");
+		return;
+	}
+	/* get pinmux control */
+	pin = lcd_conf->lcd_misc_ctrl.pin;
+
+	if (status) {
+		if (lcd_conf->lcd_basic.lcd_bits == 6) {
+			if (lcd_conf->lcd_timing.de_valid == 0)
+				pinmux_num = 0;
+			else if (lcd_conf->lcd_timing.hvsync_valid == 0)
+				pinmux_num = 1;
+			else
+				pinmux_num = 2;
+		} else {
+			if (lcd_conf->lcd_timing.de_valid == 0)
+				pinmux_num = 3;
+			else if (lcd_conf->lcd_timing.hvsync_valid == 0)
+				pinmux_num = 4;
+			else
+				pinmux_num = 5;
+		}
+	} else {
+		if (lcd_conf->lcd_basic.lcd_bits == 6)
+			pinmux_num = 6;
+		else
+			pinmux_num = 7;
+	}
+
+	/* select pinmux */
+	s = pinctrl_lookup_state(pin, lcd_ports_ttl_pinmux_str[pinmux_num]);
+	if (IS_ERR(s)) {
+		printk("set ttl_ports_ctrl pinmux error\n");
+		devm_pinctrl_put(pin); /* pinctrl_put(pin); //release pins */
+		return;
+	}
+
+	/* set pinmux and lock pins */
+	ret = pinctrl_select_state(pin, s);
+	if (ret < 0) {
+		printk("set ttl_ports_ctrl pinmux error\n");
+		devm_pinctrl_put(pin);
+		return;
+	}
+
+	lcd_print("%s: %s\n", __func__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl(Bool_t status)
+{
+	switch (lcd_conf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		lcd_ports_ctrl_lvds(status);
+		break;
+	case LCD_DIGITAL_TTL:
+		lcd_ports_ctrl_ttl(status);
+		break;
+	default:
+		printk("Invalid LCD type\n");
+		break;
+	}
+}
+
+#define LCD_GAMMA_RETRY_CNT            1000
+static unsigned char lcd_gamma_init_err = 0;
+static void write_gamma_table(u16 *data, u32 rgb_mask, u16 gamma_coeff, u32 gamma_reverse)
+{
+	int i;
+	int cnt = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&gamma_write_lock, flags);
+	rgb_mask = gamma_sel_table[rgb_mask];
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
+	if (gamma_reverse == 0) {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[i] * gamma_coeff / 100));
+		}
+	}
+	else {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[255-i] * gamma_coeff / 100));
+		}
+	}
+	cnt = 0;
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
+
+	if (cnt >= LCD_GAMMA_RETRY_CNT)
+		lcd_gamma_init_err = 1;
+
+	spin_unlock_irqrestore(&gamma_write_lock, flags);
+}
+
+static void set_gamma_table_lcd(unsigned int gamma_en)
+{
+	unsigned int reverse, coeff;
+	unsigned short *gtable;
+
+	lcd_print("%s\n", __func__);
+
+	lcd_gamma_init_err = 0;
+	reverse = ((lcd_conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1);
+	gtable = lcd_conf->lcd_effect.GammaTableR;
+	coeff = lcd_conf->lcd_effect.gamma_r_coeff;
+	write_gamma_table(gtable, GAMMA_SEL_R, coeff, reverse);
+	gtable = lcd_conf->lcd_effect.GammaTableG;
+	coeff = lcd_conf->lcd_effect.gamma_g_coeff;
+	write_gamma_table(gtable, GAMMA_SEL_G, coeff, reverse);
+	gtable = lcd_conf->lcd_effect.GammaTableB;
+	coeff = lcd_conf->lcd_effect.gamma_b_coeff;
+	write_gamma_table(gtable, GAMMA_SEL_B, coeff, reverse);
+
+	if (lcd_gamma_init_err) {
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 0, 1);
+		printk("[warning]: write gamma table error, gamma table disabled\n");
+	}
+	else
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, gamma_en, 0, 1);
+}
+
+static void set_tcon_lcd(Lcd_Config_t *pconf)
+{
+	Lcd_Timing_t *tcon_adr = &(pconf->lcd_timing);
+	unsigned int tcon_pol_ctrl;
+	unsigned hs_pol_adj, vs_pol_adj, clk_pol;
+	unsigned int gamma_en;
+
+	lcd_print("%s\n", __func__);
+
+	gamma_en = (pconf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1;
+	set_gamma_table_lcd(gamma_en);
+
+	WRITE_LCD_REG(L_RGB_BASE_ADDR,  pconf->lcd_effect.rgb_base_addr);
+	WRITE_LCD_REG(L_RGB_COEFF_ADDR, pconf->lcd_effect.rgb_coeff_addr);
+	if (pconf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(L_DITH_CNTL_ADDR,
+			pconf->lcd_effect.dith_cntl_addr);
+	} else {
+		if (pconf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
+	}
+
+	tcon_pol_ctrl = pconf->lcd_timing.pol_ctrl;
+	clk_pol = (tcon_pol_ctrl >> POL_CTRL_CLK) & 1;
+	WRITE_LCD_REG(L_POL_CNTL_ADDR, (clk_pol << LCD_CPH1_POL));
+
+	hs_pol_adj = (((tcon_pol_ctrl >> POL_CTRL_HS) & 1) ? 0 : 1);
+	vs_pol_adj = (((tcon_pol_ctrl >> POL_CTRL_VS) & 1) ? 0 : 1);
+	/* adjust hvsync pol */
+	SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((0 << LCD_DE_POL) |
+		(vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)));
+	/* enable tcon DE, Hsync, Vsync */
+	SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((1 << LCD_TCON_DE_SEL) |
+		(1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)));
+
+	/* DE signal for lvds */
+	WRITE_LCD_REG(L_DE_HS_ADDR,    tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_DE_HE_ADDR,    tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_DE_VS_ADDR,    tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_DE_VE_ADDR,    tcon_adr->de_ve_addr);
+	/* DE signal for TTL */
+	WRITE_LCD_REG(L_OEV1_HS_ADDR,  tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_OEV1_HE_ADDR,  tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_OEV1_VS_ADDR,  tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_OEV1_VE_ADDR,  tcon_adr->de_ve_addr);
+	WRITE_LCD_REG(L_OEH_HS_ADDR,  tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_OEH_HE_ADDR,  tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_OEH_VS_ADDR,  tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_OEH_VE_ADDR,  tcon_adr->de_ve_addr);
+
+	/* Hsync signal */
+	WRITE_LCD_REG(L_HSYNC_HS_ADDR, tcon_adr->hs_hs_addr);
+	WRITE_LCD_REG(L_HSYNC_HE_ADDR, tcon_adr->hs_he_addr);
+	WRITE_LCD_REG(L_HSYNC_VS_ADDR, tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(L_HSYNC_VE_ADDR, tcon_adr->hs_ve_addr);
+	if ((tcon_pol_ctrl >> POL_CTRL_HS) & 1) {
+		WRITE_LCD_REG(L_STH1_HS_ADDR, tcon_adr->hs_hs_addr);
+		WRITE_LCD_REG(L_STH1_HE_ADDR, tcon_adr->hs_he_addr);
+	} else {
+		WRITE_LCD_REG(L_STH1_HS_ADDR, tcon_adr->hs_he_addr);
+		WRITE_LCD_REG(L_STH1_HE_ADDR, tcon_adr->hs_hs_addr);
+	}
+	WRITE_LCD_REG(L_STH1_VS_ADDR, tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(L_STH1_VE_ADDR, tcon_adr->hs_ve_addr);
+
+	/* Vsync signal */
+	WRITE_LCD_REG(L_VSYNC_HS_ADDR, tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(L_VSYNC_HE_ADDR, tcon_adr->vs_he_addr);
+	WRITE_LCD_REG(L_VSYNC_VS_ADDR, tcon_adr->vs_vs_addr);
+	WRITE_LCD_REG(L_VSYNC_VE_ADDR, tcon_adr->vs_ve_addr);
+	WRITE_LCD_REG(L_STV1_HS_ADDR, tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(L_STV1_HE_ADDR, tcon_adr->vs_he_addr);
+	if ((tcon_pol_ctrl >> POL_CTRL_VS) & 1) {
+		WRITE_LCD_REG(L_STV1_VS_ADDR, tcon_adr->vs_vs_addr);
+		WRITE_LCD_REG(L_STV1_VE_ADDR, tcon_adr->vs_ve_addr);
+	} else {
+		WRITE_LCD_REG(L_STV1_VS_ADDR, tcon_adr->vs_ve_addr);
+		WRITE_LCD_REG(L_STV1_VE_ADDR, tcon_adr->vs_vs_addr);
+	}
+
+	WRITE_LCD_REG(L_INV_CNT_ADDR,       0);
+	WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR,
+		((1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL)));
+
+	if (pconf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+}
+
+static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
+{
+	unsigned m, n, od1, od2, od3, frac;
+	int wait_loop = PLL_WAIT_LOCK_CNT;
+	unsigned pll_lock = 0;
+	unsigned pll_ctrl, pll_ctrl2;
+
+	lcd_print("%s\n", __func__);
+
+	m = (pll_reg >> PLL_CTRL_M) & 0x1ff;
+	n = (pll_reg >> PLL_CTRL_N) & 0x1f;
+	od1 = (pll_reg >> PLL_CTRL_OD1) & 0x3;
+	od2 = (pll_reg >> PLL_CTRL_OD2) & 0x3;
+	od3 = (pll_reg >> PLL_CTRL_OD3) & 0x3;
+	frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
+
+	pll_ctrl = ((1 << 30) | (n << 9) | (m << 0));
+	pll_ctrl2 = ((od1 << 16) | (od2 << 22) | (od3 << 18));
+	if (frac > 0)
+		pll_ctrl2 |= ((1 << 14) | (frac << 0));
+
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL, pll_ctrl | (1 << 28));
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL2, pll_ctrl2);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL4, 0x801da72c);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL5, 0x71486980);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL6, 0x00000a55);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL, pll_ctrl);
+
+	do {
+		udelay(50);
+		pll_lock = (READ_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL) >> 31) & 0x1;
+		wait_loop--;
+	} while ((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		pr_info("[error]: hpll lock failed\n");
+}
+
+static unsigned int lcd_clk_div_table[][3] = {
+	/* divider,        shift_val,  shift_sel */
+	{CLK_DIV_SEL_1,    0xffff,     0,},
+	{CLK_DIV_SEL_2,    0x0aaa,     0,},
+	{CLK_DIV_SEL_3,    0x0db6,     0,},
+	{CLK_DIV_SEL_3p5,  0x36cc,     1,},
+	{CLK_DIV_SEL_3p75, 0x6666,     2,},
+	{CLK_DIV_SEL_4,    0x0ccc,     0,},
+	{CLK_DIV_SEL_5,    0x739c,     2,},
+	{CLK_DIV_SEL_6,    0x0e38,     0,},
+	{CLK_DIV_SEL_6p25, 0x0000,     3,},
+	{CLK_DIV_SEL_7,    0x3c78,     1,},
+	{CLK_DIV_SEL_7p5,  0x78f0,     2,},
+	{CLK_DIV_SEL_12,   0x0fc0,     0,},
+	{CLK_DIV_SEL_14,   0x3f80,     1,},
+	{CLK_DIV_SEL_15,   0x7f80,     2,},
+	{CLK_DIV_SEL_2p5,  0x5294,     2,},
+	{CLK_DIV_SEL_MAX,  0xffff,     0,},
+};
+
+static void lcd_set_clk_div(unsigned long vid_div_reg)
+{
+	unsigned int  clk_div;
+	unsigned int shift_val, shift_sel;
+	int i;
+	lcd_print("%s\n", __func__);
+
+	clk_div = (vid_div_reg >> DIV_CTRL_CLK_DIV) & 0xf;
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);
+	udelay(5);
+
+	/* Disable the div output clock */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+	i = 0;
+	while (lcd_clk_div_table[i][0] != CLK_DIV_SEL_MAX) {
+		if (clk_div == lcd_clk_div_table[i][0])
+			break;
+		i++;
+	}
+	if (lcd_clk_div_table[i][0] == CLK_DIV_SEL_MAX)
+		pr_info("invalid clk divider\n");
+	shift_val = lcd_clk_div_table[i][1];
+	shift_sel = lcd_clk_div_table[i][2];
+
+	if (shift_val == 0xffff) { /* if divide by 1 */
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+	} else {
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+	}
+	/* Enable the final output clock */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+static void lcd_set_vclk_crt(unsigned int clk_ctrl_reg)
+{
+	unsigned int xd;
+	lcd_print("%s\n", __func__);
+
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xff;
+	/* setup the XD divider value */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, (xd-1), 0, 8);
+	udelay(5);
+	/* Bit[18:16] - v2_cntl_clk_in_sel */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 16, 3);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 19, 1);
+	udelay(2);
+
+	/* [15:12] encl_clk_sel, select vclk2_div1 */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4);
+	/* release vclk2_div_reset and enable vclk2_div */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 0, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 15, 1);
+	udelay(10);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 15, 1);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 3, 1);
+}
+
+static void set_vclk_lcd(Lcd_Config_t *pconf)
+{
+	unsigned pll_reg, div_reg, clk_reg;
+	int xd;
+	int lcd_type;
+	unsigned long flags = 0;
+
+	lcd_print("%s\n", __func__);
+
+	pll_reg = pconf->lcd_timing.pll_ctrl;
+	div_reg = pconf->lcd_timing.div_ctrl;
+	clk_reg = pconf->lcd_timing.clk_ctrl;
+	xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
+
+	lcd_type = pconf->lcd_basic.lcd_type;
+
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		xd = 1;
+		break;
+	default:
+		break;
+	}
+	clk_reg = (pconf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) |
+		(xd << CLK_CTRL_XD);
+
+	spin_lock_irqsave(&lcd_clk_lock, flags);
+	lcd_set_pll(pll_reg, clk_reg);
+	lcd_set_clk_div(div_reg);
+	lcd_set_vclk_crt(clk_reg);
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
+}
+
+static void set_venc_lcd(Lcd_Config_t *pconf)
+{
+	lcd_print("%s\n", __func__);
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
+#ifdef CONFIG_AM_TV_OUTPUT2
+	if (pconf->lcd_misc_ctrl.vpp_sel) {
+		/* viu2 select encl */
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);
+	} else {
+		/* viu1 select encl */
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);
+	}
+#else
+	/* viu1, viu2 select encl */
+	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);
+#endif
+
+	WRITE_LCD_REG(ENCL_VIDEO_MODE,        0);
+	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,    0x8); /* Sampling rate: 1 */
+
+	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,   0x1000); /* bypass filter */
+
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,   pconf->lcd_basic.h_period - 1);
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,   pconf->lcd_basic.v_period - 1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN, pconf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,   pconf->lcd_basic.h_active - 1 +
+		pconf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE, pconf->lcd_timing.video_on_line);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE, pconf->lcd_basic.v_active - 1 +
+		pconf->lcd_timing.video_on_line);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,   10);
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,     16);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,   pconf->lcd_timing.vso_hstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,     pconf->lcd_timing.vso_hstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,   pconf->lcd_timing.vso_vstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,   pconf->lcd_timing.vso_vstart + 2);
+
+	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL,  (1 << 0)); /*bit[0] 1:RGB, 0:YUV*/
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN,          1);
+}
+
+static void clk_util_lvds_set_clk_div(Lcd_Config_t *pconf)
+{
+	unsigned int phy_div2, wr_mode;
+
+	if (pconf->lcd_control.lvds_config->dual_port == 0) {
+		phy_div2 = 0;
+		wr_mode = 1;
+	} else {
+		phy_div2 = 1;
+		wr_mode = 3;
+	}
+
+	/* ---------------------------------------------
+	// Configure the LVDS PHY
+	// ---------------------------------------------
+	// wire    [4:0]   cntl_ser_en         = control[20:16];
+	// wire            cntl_prbs_en        = control[13];
+	// wire            cntl_prbs_err_en    = control[12];
+	// wire    [1:0]   cntl_mode_set_high  = control[11:10];
+	// wire    [1:0]   cntl_mode_set_low   = control[9:8];
+	//
+	// wire    [1:0]   fifo_clk_sel        = control[7;6]
+	//
+	// wire            mode_port_rev       = control[4];
+	// wire            mode_bit_rev        = control[3];
+	// wire            mode_inv_p_n        = control[2];
+	// wire            phy_clk_en          = control[1];
+	// wire            soft_reset_int      = control[0];
+	// enable all serializers, divide by 7 */
+	WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL0, (0xfff << 16) | (0x1 << 6));
+	WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL1,
+			(1 << 30) | (phy_div2 << 25) | (1 << 24));
+
+	/*    lvds_gen_cntl       <= {10'h0,     // [15:4] unused
+	//                            2'h1,      // [5:4] divide by 7 in the PHY
+	//                            1'b0,      // [3] fifo_en
+	//                            1'b0,      // [2] wr_bist_gate
+	//                            2'b00};    // [1:0] fifo_wr mode
+	//FIFO_CLK_SEL = 1; // div7 */
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2); /* lvds fifo clk div 7 */
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, wr_mode, 0, 2);  /* fifo wr mode */
+
+	/* lvds phy div reset */
+	WRITE_LCD_CBUS_REG_BITS(HHI_LVDS_TX_PHY_CNTL0, 1, 0, 1);
+	udelay(5);
+	/* Release lvds div reset */
+	WRITE_LCD_CBUS_REG_BITS(HHI_LVDS_TX_PHY_CNTL0, 0, 0, 1);
+}
+
+static void set_control_lvds(Lcd_Config_t *pconf)
+{
+	unsigned int lvds_repack, pn_swap, bit_num;
+	unsigned int dual_port, port_swap;
+	unsigned int data32;
+
+	lcd_print("%s\n", __func__);
+	clk_util_lvds_set_clk_div(pconf);
+
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
+
+	data32 = (0x00 << LVDS_BLANK_DATA_R) |
+		(0x00 << LVDS_BLANK_DATA_G) |
+		(0x00 << LVDS_BLANK_DATA_B);
+	WRITE_LCD_REG(LVDS_BLANK_DATA_HI, (data32 >> 16));
+	WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
+
+	dual_port = pconf->lcd_control.lvds_config->dual_port;
+	port_swap = pconf->lcd_control.lvds_config->port_swap;
+	lvds_repack = (pconf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	pn_swap = (pconf->lcd_control.lvds_config->pn_swap) & 0x1;
+
+	switch (pconf->lcd_basic.lcd_bits) {
+	case 10:
+		bit_num = 0;
+		break;
+	case 8:
+		bit_num = 1;
+		break;
+	case 6:
+		bit_num = 2;
+		break;
+	case 4:
+		bit_num = 3;
+		break;
+	default:
+		bit_num = 1;
+		break;
+	}
+
+	WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR,
+		(lvds_repack << 0) | /* repack */
+		(port_swap << 2) | /* odd_even */
+		(0 << 3) | /* reserve */
+		(0 << 4) | /* lsb first */
+		(pn_swap << 5) | /* pn swap */
+		(dual_port << 6) | /* dual port */
+		(0 << 7) | /* use tcon control */
+		(bit_num << 8) | /* 0:10bits, 1:8bits, 2:6bits, 3:4bits. */
+		(0 << 10) | /*r_select  //0:R, 1:G, 2:B, 3:0 */
+		(1 << 12) | /*g_select  //0:R, 1:G, 2:B, 3:0 */
+		(2 << 14));  /*b_select  //0:R, 1:G, 2:B, 3:0;  */
+
+	/* WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);  //enable fifo */
+}
+
+static void set_control_ttl(Lcd_Config_t *pconf)
+{
+	unsigned rb_port_swap, rgb_bit_swap;
+
+	rb_port_swap = (unsigned)(pconf->lcd_control.ttl_config->rb_swap);
+	rgb_bit_swap = (unsigned)(pconf->lcd_control.ttl_config->bit_swap);
+
+	WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR,
+		(rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
+}
+
+static void init_phy_lvds(Lcd_Config_t *pconf)
+{
+	unsigned int swing_level;
+	unsigned int temp;
+	lcd_print("%s\n", __func__);
+
+	WRITE_LCD_REG(LVDS_SER_EN, 0xfff); /* Enable the serializers */
+
+	WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff);
+	WRITE_LCD_REG(LVDS_PHY_CNTL1, 0xff00);
+	WRITE_LCD_REG(LVDS_PHY_CNTL4, 0x007f);
+
+	swing_level = pconf->lcd_control.lvds_config->lvds_vswing;
+	swing_level = (swing_level >= LVDS_VSWING_LEVEL_MAX) ?
+		(LVDS_VSWING_LEVEL_MAX - 1) : swing_level;
+
+	temp = 0x606cca80 | (lvds_vswing_ctrl[swing_level] << 26);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, temp);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00000800);
+}
+
+static void init_dphy(Lcd_Config_t *pconf)
+{
+	unsigned lcd_type = (unsigned)(pconf->lcd_basic.lcd_type);
+
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);
+		init_phy_lvds(pconf);
+		break;
+	default:
+		break;
+	}
+}
+
+static void _init_lcd_driver(Lcd_Config_t *pconf)
+{
+	int lcd_type = pconf->lcd_basic.lcd_type;
+	unsigned char ss_level;
+
+	print_lcd_driver_version();
+	request_vpu_clk_vmod(pconf->lcd_timing.lcd_clk, VMODE_LCD);
+	switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_ON);
+	switch_lcd_mod_gate(ON);
+
+	ss_level = (pconf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+	pr_info("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz\n",
+	pconf->lcd_basic.model_name, lcd_type_table[lcd_type],
+	lcd_type, pconf->lcd_basic.lcd_bits, pconf->lcd_basic.h_active,
+	pconf->lcd_basic.v_active, (pconf->lcd_timing.sync_duration_num / 10),
+	(pconf->lcd_timing.sync_duration_num % 10));
+	pr_info("ss_level=%u(%s)\n", ss_level, lcd_ss_level_table[ss_level]);
+
+	set_vclk_lcd(pconf);
+	set_venc_lcd(pconf);
+	set_tcon_lcd(pconf);
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		set_control_lvds(pconf);
+		init_dphy(pconf);
+		break;
+	case LCD_DIGITAL_TTL:
+		set_control_ttl(pconf);
+		break;
+	default:
+		pr_info("Invalid LCD type.\n");
+		break;
+	}
+	pr_info("%s finished.\n", __func__);
+}
+
+static void _disable_lcd_driver(Lcd_Config_t *pconf)
+{
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0); /* disable encl */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 0, 3, 1);
+	/* close vclk2 gate: 0x104b[4:0] */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);
+	/* close vid2_pll gate: 0x104c[16] */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);
+	/* disable vid_pll: 0x10c8[30] */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 30, 1);
+
+	switch_lcd_mod_gate(OFF);
+	switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_DOWN);
+	release_vpu_clk_vmod(VMODE_LCD);
+	pr_info("disable lcd display driver.\n");
+}
+
+static void _enable_vsync_interrupt(void)
+{
+	WRITE_LCD_REG(VENC_INTCTRL, 0x200);
+}
+
+#define LCD_ENC_TST_NUM_MAX    8
+static char *lcd_enc_tst_str[] = {
+	"None",        /* 0 */
+	"Color Bar",   /* 1 */
+	"Thin Line",   /* 2 */
+	"Dot Grid",    /* 3 */
+	"Gray",        /* 4 */
+	"Red",         /* 5 */
+	"Green",       /* 6 */
+	"Blue",        /* 7 */
+};
+
+static unsigned int lcd_enc_tst[][6] = {
+/*	tst_mode,  Y,       Cb,     Cr,    tst_en, vfifo_en */
+	{0,       0x200,   0x200,  0x200,   0,      1},  /* 0 */
+	{1,       0x200,   0x200,  0x200,   1,      0},  /* 1 */
+	{2,       0x200,   0x200,  0x200,   1,      0},  /* 2 */
+	{3,       0x200,   0x200,  0x200,   1,      0},  /* 3 */
+	{0,       0x200,   0x200,  0x200,   1,      0},  /* 4 */
+	{0,       0x130,   0x153,  0x3fd,   1,      0},  /* 5 */
+	{0,       0x256,   0x0ae,  0x055,   1,      0},  /* 6 */
+	{0,       0x074,   0x3fd,  0x1ad,   1,      0},  /* 7 */
+};
+
+static void lcd_test(unsigned int num)
+{
+	num = (num >= LCD_ENC_TST_NUM_MAX) ? 0 : num;
+
+	WRITE_LCD_REG(ENCL_TST_MDSEL, lcd_enc_tst[num][0]);
+	WRITE_LCD_REG(ENCL_TST_Y, lcd_enc_tst[num][1]);
+	WRITE_LCD_REG(ENCL_TST_CB, lcd_enc_tst[num][2]);
+	WRITE_LCD_REG(ENCL_TST_CR, lcd_enc_tst[num][3]);
+	WRITE_LCD_REG(ENCL_TST_CLRBAR_STRT,
+		lcd_conf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_TST_CLRBAR_WIDTH,
+		(lcd_conf->lcd_basic.h_active / 9));
+	WRITE_LCD_REG(ENCL_TST_EN, lcd_enc_tst[num][4]);
+	WRITE_LCD_REG_BITS(ENCL_VIDEO_MODE_ADV, lcd_enc_tst[num][5], 3, 1);
+
+	if (num > 0) {
+		pr_info("show test pattern %d: %s\n",
+			num, lcd_enc_tst_str[num]);
+	} else
+		pr_info("disable test pattern\n");
+}
+
+static unsigned int gamma_tst_y[18] = {
+/*  Y_val    test_level   gray_level */
+	0x000,   /* 1          //0 */
+	0x072,   /* 2          //15 */
+	0x0a4,   /* 3          //30 */
+	0x0d7,   /* 4          //45 */
+	0x10b,   /* 5          //60 */
+	0x13f,   /* 6          //75 */
+	0x175,   /* 7          //90 */
+	0x1a8,   /* 8          //105 */
+	0x1dc,   /* 9          //120 */
+	0x210,   /* 10         //135 */
+	0x23f,   /* 11         //150 */
+	0x274,   /* 12         //165 */
+	0x2a8,   /* 13         //180 */
+	0x2da,   /* 14         //195 */
+	0x30e,   /* 15         //210 */
+	0x342,   /* 16         //225 */
+	0x376,   /* 17         //240 */
+	0x3aa,   /* 18         //255 */
+};
+
+static void lcd_gamma_test(unsigned int num)
+{
+	if ((num >= 1) && (num <= 18)) {
+		WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+		WRITE_LCD_REG(ENCL_TST_Y,  gamma_tst_y[num-1]);
+		WRITE_LCD_REG(ENCL_TST_CB, 0x200);
+		WRITE_LCD_REG(ENCL_TST_CR, 0x200);
+		WRITE_LCD_REG(ENCL_TST_EN, 1);
+		WRITE_LCD_REG_BITS(ENCL_VIDEO_MODE_ADV, 0, 3, 1);
+		pr_info("gamma test level: %d, gray level: %d\n",
+			num, ((num - 1) * 15));
+	} else {
+		WRITE_LCD_REG_BITS(ENCL_VIDEO_MODE_ADV, 1, 3, 1);
+		WRITE_LCD_REG(ENCL_TST_EN, 0);
+		pr_info("gamma test pattern disabled\n");
+	}
+}
+
+/* ***********************************************
+// sysfs api for video
+// *********************************************** */
+static ssize_t lcd_video_vso_read(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read vso start: %u\n",
+		lcd_conf->lcd_timing.vso_vstart);
+}
+
+static ssize_t lcd_video_vso_write(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int temp;
+
+	temp = 10;
+	ret = sscanf(buf, "%u", &temp);
+	lcd_conf->lcd_timing.vso_vstart = (unsigned short)temp;
+	lcd_conf->lcd_timing.vso_user = 1;
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE, lcd_conf->lcd_timing.vso_vstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,
+		lcd_conf->lcd_timing.vso_vstart + 2);
+	pr_info("set vso start: %u\n", lcd_conf->lcd_timing.vso_vstart);
+
+	if ((ret != 1) || (ret != 2))
+		return -EINVAL;
+
+	return count;
+	/* return 0; */
+}
+
+static struct class_attribute lcd_video_class_attrs[] = {
+	__ATTR(vso,  S_IRUGO | S_IWUSR,
+		lcd_video_vso_read, lcd_video_vso_write),
+};
+
+static int creat_lcd_video_attr(Lcd_Config_t *pconf)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lcd_video_class_attrs); i++) {
+		if (class_create_file(pconf->lcd_misc_ctrl.debug_class,
+			&lcd_video_class_attrs[i])) {
+			pr_info("create lcd_video attribute %s fail\n",
+				lcd_video_class_attrs[i].attr.name);
+		}
+	}
+
+	return 0;
+}
+
+static int remove_lcd_video_attr(Lcd_Config_t *pconf)
+{
+	int i;
+
+	if (pconf->lcd_misc_ctrl.debug_class == NULL)
+		return -1;
+
+	for (i = 0; i < ARRAY_SIZE(lcd_video_class_attrs); i++) {
+		class_remove_file(pconf->lcd_misc_ctrl.debug_class,
+			&lcd_video_class_attrs[i]);
+	}
+
+	return 0;
+}
+/* *********************************************** */
+
+static DEFINE_MUTEX(lcd_init_mutex);
+static void lcd_module_enable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+
+	_init_lcd_driver(lcd_conf);
+	lcd_conf->lcd_power_ctrl.power_ctrl(ON);
+	_enable_vsync_interrupt();
+	lcd_conf->lcd_misc_ctrl.lcd_status = 1;
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void lcd_module_disable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+	lcd_conf->lcd_misc_ctrl.lcd_status = 0;
+	lcd_conf->lcd_power_ctrl.power_ctrl(OFF);
+	_disable_lcd_driver(lcd_conf);
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static unsigned int clk_div_calc(unsigned int clk,
+		unsigned int div_sel, int dir)
+{
+	unsigned int clk_ret;
+
+	switch (div_sel) {
+	case CLK_DIV_SEL_1:
+		clk_ret = clk;
+		break;
+	case CLK_DIV_SEL_2:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 2;
+		else
+			clk_ret = clk * 2;
+		break;
+	case CLK_DIV_SEL_3:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 3;
+		else
+			clk_ret = clk * 3;
+		break;
+	case CLK_DIV_SEL_3p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 7;
+		else
+			clk_ret = clk * 7 / 2;
+		break;
+	case CLK_DIV_SEL_3p75:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 4 / 15;
+		else
+			clk_ret = clk * 15 / 4;
+		break;
+	case CLK_DIV_SEL_4:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 4;
+		else
+			clk_ret = clk * 4;
+		break;
+	case CLK_DIV_SEL_5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 5;
+		else
+			clk_ret = clk * 5;
+		break;
+	case CLK_DIV_SEL_6:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 6;
+		else
+			clk_ret = clk * 6;
+		break;
+	case CLK_DIV_SEL_6p25:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 4 / 25;
+		else
+			clk_ret = clk * 25 / 4;
+		break;
+	case CLK_DIV_SEL_7:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 7;
+		else
+			clk_ret = clk * 7;
+		break;
+	case CLK_DIV_SEL_7p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 15;
+		else
+			clk_ret = clk * 15 / 2;
+		break;
+	case CLK_DIV_SEL_12:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 12;
+		else
+			clk_ret = clk * 12;
+		break;
+	case CLK_DIV_SEL_14:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 14;
+		else
+			clk_ret = clk * 14;
+		break;
+	case CLK_DIV_SEL_15:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 15;
+		else
+			clk_ret = clk * 15;
+		break;
+	case CLK_DIV_SEL_2p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 5;
+		else
+			clk_ret = clk * 5 / 2;
+		break;
+	default:
+		clk_ret = clk;
+		printk("[Error]clk_div_sel:  Invalid parameter\n");
+		break;
+	}
+
+	return clk_ret;
+}
+
+struct pll_para_s {
+	unsigned int m;
+	unsigned int n;
+	unsigned int frac;
+	unsigned int od1_sel;
+	unsigned int od2_sel;
+	unsigned int od3_sel;
+};
+
+static int check_pll(struct pll_para_s *pll, unsigned int pll_fout)
+{
+	unsigned int fin, m, n;
+	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
+	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
+	unsigned int od_fb = 0, pll_frac;
+	int done;
+
+	done = 0;
+	fin = FIN_FREQ; /* kHz */
+	for (od3_sel = OD_SEL_MAX; od3_sel > 0; od3_sel--) {
+		od3 = od_table[od3_sel - 1];
+		pll_fod3_in = pll_fout * od3;
+		for (od2_sel = od3_sel; od2_sel > 0; od2_sel--) {
+			od2 = od_table[od2_sel - 1];
+			pll_fod2_in = pll_fod3_in * od2;
+			for (od1_sel = od2_sel; od1_sel > 0; od1_sel--) {
+				od1 = od_table[od1_sel - 1];
+				pll_fvco = pll_fod2_in * od1;
+				if ((pll_fvco < PLL_VCO_MIN) ||
+					(pll_fvco > PLL_VCO_MAX)) {
+					continue;
+				}
+				pll->od1_sel = od1_sel - 1;
+				pll->od2_sel = od2_sel - 1;
+				pll->od3_sel = od3_sel - 1;
+				lcd_print("od1_sel=%d, od2_sel=%d, od3_sel=%d,",
+					(od1_sel - 1), (od2_sel - 1),
+					(od3_sel - 1));
+				lcd_print(" pll_fvco=%d\n", pll_fvco);
+				n = 1;
+				od_fb = 0; /* pll default */
+				pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+				m = pll_fvco / fin;
+				pll_frac = (pll_fvco % fin) * 4096 / fin;
+				pll->m = m;
+				pll->n = n;
+				pll->frac = pll_frac;
+				lcd_print("pll_m=%d, pll_n=%d, pll_frac=%d\n",
+					m, n, pll_frac);
+				done = 1;
+			}
+		}
+	}
+	return done;
+}
+
+static void generate_clk_parameter(Lcd_Config_t *pconf)
+{
+	struct pll_para_s pll;
+	int ret = 0;
+
+	unsigned clk_div_sel, crt_xd;
+	unsigned crt_xd_max;
+	unsigned fout_pll, clk_div_out;
+	unsigned tmp;
+	unsigned fout;
+
+	fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+
+	if (fout > ENCL_MAX_CLK_IN)
+		goto generate_clk_done;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		clk_div_sel = CLK_DIV_SEL_1;//CLK_DIV_SEL_7;
+		crt_xd_max = CRT_VID_DIV_MAX;
+		crt_xd = 7;
+		clk_div_out = fout * crt_xd;
+		if (clk_div_out > CRT_VID_MAX_CLK_IN)
+			goto generate_clk_done;
+		lcd_print("fout=%d, crt_xd=%d, clk_div_out=%d\n",
+			fout, crt_xd, clk_div_out);
+		fout_pll = clk_div_calc(clk_div_out,
+				clk_div_sel, CLK_DIV_O2I);
+		if (fout_pll > CLK_DIV_MAX_CLK_IN)
+			goto generate_clk_done;
+		lcd_print("clk_div_sel=%d, fout_pll=%d\n",
+			clk_div_sel, fout_pll);
+		ret = check_pll(&pll, fout_pll);
+		if (ret)
+			goto generate_clk_done;
+		break;
+	case LCD_DIGITAL_TTL:
+		clk_div_sel = CLK_DIV_SEL_1;
+		crt_xd_max = CRT_VID_DIV_MAX;
+		for (crt_xd = 1; crt_xd <= crt_xd_max; crt_xd++) {
+			clk_div_out = fout * crt_xd;
+			if (clk_div_out > CRT_VID_MAX_CLK_IN)
+				continue;
+			lcd_print("fout=%d, crt_xd=%d, clk_div_out=%d\n",
+				fout, crt_xd, clk_div_out);
+			fout_pll = clk_div_calc(clk_div_out,
+					clk_div_sel, CLK_DIV_O2I);
+			if (fout_pll > CLK_DIV_MAX_CLK_IN)
+				continue;
+			lcd_print("clk_div_sel=%d, fout_pll=%d\n",
+				clk_div_sel, fout_pll);
+			ret = check_pll(&pll, fout_pll);
+			if (ret)
+				goto generate_clk_done;
+		}
+		break;
+	default:
+		break;
+	}
+
+generate_clk_done:
+	if (ret) {
+		pconf->lcd_timing.pll_ctrl =
+			(pll.od1_sel << PLL_CTRL_OD1) |
+			(pll.od2_sel << PLL_CTRL_OD2) |
+			(pll.od3_sel << PLL_CTRL_OD3) |
+			(pll.n << PLL_CTRL_N) |
+			(pll.m << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl = (clk_div_sel << DIV_CTRL_CLK_DIV);
+		tmp = (pconf->lcd_timing.clk_ctrl &
+			~((0xff << CLK_CTRL_XD) | (0xfff << CLK_CTRL_FRAC)));
+		pconf->lcd_timing.clk_ctrl = (tmp |
+			((crt_xd << CLK_CTRL_XD) |
+			(pll.frac << CLK_CTRL_FRAC)));
+	} else {
+		pconf->lcd_timing.pll_ctrl = (0 << PLL_CTRL_OD1) |
+			(1 << PLL_CTRL_OD2) | (1 << PLL_CTRL_OD3) |
+			(1 << PLL_CTRL_N) | (65 << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(CLK_DIV_SEL_1 << DIV_CTRL_CLK_DIV);
+		pconf->lcd_timing.clk_ctrl = (pconf->lcd_timing.clk_ctrl &
+			~(0xff << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+		pr_info("Out of clock range, reset to default setting!\n");
+	}
+}
+
+static void lcd_sync_duration(Lcd_Config_t *pconf)
+{
+	unsigned m, n, od1, od2, od3, od_fb, frac, clk_div, xd;
+	unsigned h_period, v_period, sync_duration_num, sync_duration_den;
+	unsigned pll_out_clk, lcd_clk;
+
+	m = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
+	n = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_N) & 0x1f;
+	od1 = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD1) & 0x3;
+	od2 = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD2) & 0x3;
+	od3 = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD3) & 0x3;
+	od1 = od_table[od1];
+	od2 = od_table[od2];
+	od3 = od_table[od3];
+	frac = ((pconf->lcd_timing.clk_ctrl) >> CLK_CTRL_FRAC) & 0xfff;
+	od_fb = 0;
+	clk_div = ((pconf->lcd_timing.div_ctrl) >> DIV_CTRL_CLK_DIV) & 0xff;
+	xd = ((pconf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
+
+	h_period = pconf->lcd_basic.h_period;
+	v_period = pconf->lcd_basic.v_period;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		xd = 1;
+		clk_div = CLK_DIV_SEL_7;
+		break;
+	case LCD_DIGITAL_TTL:
+		clk_div = CLK_DIV_SEL_1;
+		break;
+	default:
+		break;
+	}
+
+	od_fb = (od_fb + 1) * 2;
+	pll_out_clk = (frac * od_fb * FIN_FREQ) / 4096;
+	pll_out_clk = ((m * od_fb * FIN_FREQ + pll_out_clk) /
+		(n * od1 * od2 * od3));
+	lcd_clk = clk_div_calc(pll_out_clk, clk_div, CLK_DIV_I2O) / xd;
+	pconf->lcd_timing.lcd_clk = lcd_clk * 1000;
+	sync_duration_num = ((lcd_clk * 1000 / h_period) * 100) / v_period;
+	sync_duration_num = (sync_duration_num + 5) / 10;
+	sync_duration_den = 10;
+
+	pconf->lcd_timing.sync_duration_num = sync_duration_num;
+	pconf->lcd_timing.sync_duration_den = sync_duration_den;
+	pr_info("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz\n\n",
+		(lcd_clk / 1000), (lcd_clk % 1000),
+		(sync_duration_num / sync_duration_den),
+		((sync_duration_num * 10 / sync_duration_den) % 10));
+}
+
+static void lcd_tcon_config(Lcd_Config_t *pconf)
+{
+	unsigned short de_hstart, de_vstart;
+	unsigned short hstart, hend, vstart, vend;
+	unsigned short h_delay = 0;
+	unsigned short h_offset = 0, v_offset = 0, vsync_h_phase = 0;
+	unsigned short h_period, v_period, h_active, v_active;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		h_delay = LVDS_DELAY;
+		break;
+	case LCD_DIGITAL_TTL:
+		h_delay = TTL_DELAY;
+		break;
+	default:
+		h_delay = 0;
+		break;
+	}
+	h_period = pconf->lcd_basic.h_period;
+	v_period = pconf->lcd_basic.v_period;
+	h_active = pconf->lcd_basic.h_active;
+	v_active = pconf->lcd_basic.v_active;
+
+	pconf->lcd_timing.video_on_pixel = h_period - h_active - 1 - h_delay;
+	pconf->lcd_timing.video_on_line = v_period - v_active;
+
+	h_offset = (pconf->lcd_timing.h_offset & 0xffff);
+	v_offset = (pconf->lcd_timing.v_offset & 0xffff);
+	if ((pconf->lcd_timing.h_offset >> 31) & 1)
+		de_hstart = (h_period - h_active - 1 + h_period - h_offset) % h_period;
+	else
+		de_hstart = (h_period - h_active - 1 + h_offset) % h_period;
+	if ((pconf->lcd_timing.v_offset >> 31) & 1)
+		de_vstart = (v_period - v_active + v_period - v_offset) % v_period;
+	else
+		de_vstart = (v_period - v_active + v_offset) % v_period;
+
+	hstart = (de_hstart + h_period - pconf->lcd_timing.hsync_bp - pconf->lcd_timing.hsync_width) % h_period;
+	hend = (de_hstart + h_period - pconf->lcd_timing.hsync_bp) % h_period;
+	pconf->lcd_timing.hs_hs_addr = hstart;
+	pconf->lcd_timing.hs_he_addr = hend;
+	pconf->lcd_timing.hs_vs_addr = 0;
+	pconf->lcd_timing.hs_ve_addr = v_period - 1;
+
+	vsync_h_phase = (pconf->lcd_timing.vsync_h_phase & 0xffff);
+	if ((pconf->lcd_timing.vsync_h_phase >> 31) & 1) /* negative */
+		vsync_h_phase = (hstart + h_period - vsync_h_phase) % h_period;
+	else /* positive */
+		vsync_h_phase = (hstart + h_period + vsync_h_phase) % h_period;
+	pconf->lcd_timing.vs_hs_addr = vsync_h_phase;
+	pconf->lcd_timing.vs_he_addr = vsync_h_phase;
+	vstart = (de_vstart + v_period - pconf->lcd_timing.vsync_bp - pconf->lcd_timing.vsync_width) % v_period;
+	vend = (de_vstart + v_period - pconf->lcd_timing.vsync_bp) % v_period;
+	pconf->lcd_timing.vs_vs_addr = vstart;
+	pconf->lcd_timing.vs_ve_addr = vend;
+
+	pconf->lcd_timing.de_hs_addr = de_hstart;
+	pconf->lcd_timing.de_he_addr = (de_hstart + h_active) % h_period;
+	pconf->lcd_timing.de_vs_addr = de_vstart;
+	pconf->lcd_timing.de_ve_addr = (de_vstart + v_active - 1) % v_period;
+
+	if (pconf->lcd_timing.vso_user == 0) {
+		/*pconf->lcd_timing.vso_hstart = pconf->lcd_timing.vs_hs_addr;*/
+		pconf->lcd_timing.vso_vstart = pconf->lcd_timing.vs_vs_addr;
+	}
+
+	/*lcd_print("hs_hs_addr=%d, hs_he_addr=%d, ",
+		pconf->lcd_timing.hs_hs_addr, pconf->lcd_timing.hs_he_addr);
+	lcd_print("hs_vs_addr=%d, hs_ve_addr=%d\n",
+		pconf->lcd_timing.hs_vs_addr, pconf->lcd_timing.hs_ve_addr);
+	//lcd_print("vs_hs_addr=%d, vs_he_addr=%d, ",
+		pconf->lcd_timing.vs_hs_addr, pconf->lcd_timing.vs_he_addr);
+	lcd_print("vs_vs_addr=%d, vs_ve_addr=%d\n",
+		pconf->lcd_timing.vs_vs_addr, pconf->lcd_timing.vs_ve_addr);
+	//lcd_print("de_hs_addr=%d, de_he_addr=%d, ",
+		pconf->lcd_timing.de_hs_addr, pconf->lcd_timing.de_he_addr);
+	lcd_print("de_vs_addr=%d, de_ve_addr=%d\n",
+		pconf->lcd_timing.de_vs_addr, pconf->lcd_timing.de_ve_addr); */
+}
+
+static void lcd_control_config_pre(Lcd_Config_t *pconf)
+{
+	unsigned int ss_level;
+
+	/* prepare refer clock for frame_rate setting */
+	if (pconf->lcd_timing.lcd_clk < 200) {
+		pconf->lcd_timing.lcd_clk =
+			(pconf->lcd_timing.lcd_clk * pconf->lcd_basic.h_period *
+			pconf->lcd_basic.v_period);
+	}
+
+	ss_level = ((pconf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+	ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX - 1) : ss_level);
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		if (pconf->lcd_control.lvds_config->lvds_repack_user == 0) {
+			if (pconf->lcd_basic.lcd_bits == 6)
+				pconf->lcd_control.lvds_config->lvds_repack = 0;
+			else
+				pconf->lcd_control.lvds_config->lvds_repack = 1;
+		}
+		if (pconf->lcd_control.lvds_config->dual_port == 0) {
+			if (pconf->lcd_control.lvds_config->port_swap == 0) {
+				pconf->lcd_control.lvds_config->port_sel =
+					LVDS_PORT_A;
+			} else {
+				pconf->lcd_control.lvds_config->port_sel =
+					LVDS_PORT_B;
+			}
+		} else {
+			pconf->lcd_control.lvds_config->port_sel = LVDS_PORT_AB;
+		}
+		break;
+	default:
+		break;
+	}
+	pconf->lcd_timing.clk_ctrl = ((pconf->lcd_timing.clk_ctrl &
+		(~(0xf << CLK_CTRL_SS))) | (ss_level << CLK_CTRL_SS));
+}
+
+#ifdef CONFIG_USE_OF
+static LVDS_Config_t lcd_lvds_config = {
+	.lvds_vswing = 1,
+	.lvds_repack_user = 0,
+	.lvds_repack = 0,
+	.pn_swap = 0,
+};
+
+static TTL_Config_t lcd_ttl_config = {
+	.rb_swap = 0,
+	.bit_swap = 0,
+};
+
+static Lcd_Config_t lcd_config = {
+	.lcd_timing = {
+		.lcd_clk = 40000000,
+		.clk_ctrl = ((1 << CLK_CTRL_AUTO) | (0 << CLK_CTRL_SS)),
+		.hvsync_valid = 1,
+		.de_valid = 1,
+		.pol_ctrl = ((0 << POL_CTRL_CLK) | (1 << POL_CTRL_DE) | (0 << POL_CTRL_VS) | (0 << POL_CTRL_HS)),
+	},
+	.lcd_effect = {
+		.rgb_base_addr = 0xf0,
+		.rgb_coeff_addr = 0x74a,
+		.dith_user = 0,
+		.vadj_brightness = 0x0,
+		.vadj_contrast = 0x80,
+		.vadj_saturation = 0x100,
+		.gamma_ctrl = ((0 << GAMMA_CTRL_REVERSE) | (1 << GAMMA_CTRL_EN)),
+		.gamma_r_coeff = 100,
+		.gamma_g_coeff = 100,
+		.gamma_b_coeff = 100,
+		.set_gamma_table = set_gamma_table_lcd,
+		.gamma_test = lcd_gamma_test,
+	},
+	.lcd_control = {
+		.lvds_config = &lcd_lvds_config,
+		.ttl_config = &lcd_ttl_config,
+	},
+	.lcd_power_ctrl = {
+		.power_on_step = 0,
+		.power_off_step = 0,
+		.power_ctrl = NULL,
+	},
+};
+
+Lcd_Config_t *get_lcd_config(void)
+{
+	return &lcd_config;
+}
+#endif
+
+static void lcd_config_assign(Lcd_Config_t *pconf)
+{
+	pconf->lcd_timing.vso_hstart = 10; /* for video process */
+	pconf->lcd_timing.vso_vstart = 10; /* for video process */
+	pconf->lcd_timing.vso_user = 0; /* use default config */
+
+	pconf->lcd_power_ctrl.ports_ctrl = lcd_ports_ctrl;
+
+	pconf->lcd_misc_ctrl.vpp_sel = 0;
+	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1)
+		pconf->lcd_misc_ctrl.lcd_status = 1;
+	else
+		pconf->lcd_misc_ctrl.lcd_status = 0;
+	pconf->lcd_misc_ctrl.module_enable = lcd_module_enable;
+	pconf->lcd_misc_ctrl.module_disable = lcd_module_disable;
+	pconf->lcd_misc_ctrl.lcd_test = lcd_test;
+	pconf->lcd_misc_ctrl.print_version = print_lcd_driver_version;
+}
+
+void lcd_config_init(Lcd_Config_t *pconf)
+{
+	lcd_control_config_pre(pconf);
+
+	if ((pconf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
+		pr_info("\nAuto generate clock parameters.\n");
+		generate_clk_parameter(pconf);
+	} else {
+		pr_info("\nCustome clock parameters.\n");
+	}
+	pr_info("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n",
+		pconf->lcd_timing.pll_ctrl, pconf->lcd_timing.div_ctrl,
+		pconf->lcd_timing.clk_ctrl);
+
+	lcd_sync_duration(pconf);
+	lcd_tcon_config(pconf);
+}
+
+void lcd_config_probe(Lcd_Config_t *pconf)
+{
+	spin_lock_init(&gamma_write_lock);
+	spin_lock_init(&lcd_clk_lock);
+
+	lcd_conf = pconf;
+	lcd_config_assign(pconf);
+
+	creat_lcd_video_attr(pconf);
+}
+
+void lcd_config_remove(Lcd_Config_t *pconf)
+{
+	remove_lcd_video_attr(pconf);
+}
diff --git a/arch/arm/mach-mesong9bb/lcd/lcd_config.h b/arch/arm/mach-mesong9bb/lcd/lcd_config.h
new file mode 100644
index 000000000000..5124195c043b
--- /dev/null
+++ b/arch/arm/mach-mesong9bb/lcd/lcd_config.h
@@ -0,0 +1,240 @@
+
+#ifndef LCD_CONFIG_H
+#define LCD_CONFIG_H
+#include <linux/types.h>
+
+/* **********************************
+//lcd driver version
+// ********************************** */
+#define LCD_DRV_TYPE      "c9b"
+#define LCD_DRV_DATE      "20150525"
+/* ********************************** */
+
+/* for GAMMA_CNTL_PORT */
+	#define LCD_GAMMA_VCOM_POL       7
+	#define LCD_GAMMA_RVS_OUT        6
+	#define LCD_ADR_RDY              5
+	#define LCD_WR_RDY               4
+	#define LCD_RD_RDY               3
+	#define LCD_GAMMA_TR             2
+	#define LCD_GAMMA_SET            1
+	#define LCD_GAMMA_EN             0
+
+/* for GAMMA_ADDR_PORT */
+	#define LCD_H_RD                 12
+	#define LCD_H_AUTO_INC           11
+	#define LCD_H_SEL_R              10
+	#define LCD_H_SEL_G              9
+	#define LCD_H_SEL_B              8
+	#define LCD_HADR_MSB             7
+	#define LCD_HADR                 0
+
+/* for POL_CNTL_ADDR */
+	#define LCD_DCLK_SEL             14
+	#define LCD_TCON_VSYNC_SEL_DVI   11
+	#define LCD_TCON_HSYNC_SEL_DVI   10
+	#define LCD_TCON_DE_SEL_DVI      9
+	#define LCD_CPH3_POL             8
+	#define LCD_CPH2_POL             7
+	#define LCD_CPH1_POL             6
+	#define LCD_TCON_DE_SEL          5
+	#define LCD_TCON_VS_SEL          4
+	#define LCD_TCON_HS_SEL          3
+	#define LCD_DE_POL               2
+	#define LCD_VS_POL               1
+	#define LCD_HS_POL               0
+
+/* for DITH_CNTL_ADDR */
+	#define LCD_DITH10_EN            10
+	#define LCD_DITH8_EN             9
+	#define LCD_DITH_MD              8
+	#define LCD_DITH10_CNTL_MSB      7
+	#define LCD_DITH10_CNTL          4
+	#define LCD_DITH8_CNTL_MSB       3
+	#define LCD_DITH8_CNTL           0
+
+/* for INV_CNT_ADDR */
+	#define LCD_INV_EN               4
+	#define LCD_INV_CNT_MSB          3
+	#define LCD_INV_CNT              0
+
+/* for TCON_MISC_SEL_ADDR */
+	#define LCD_STH2_SEL             12
+	#define LCD_STH1_SEL             11
+	#define LCD_OEH_SEL              10
+	#define LCD_VCOM_SEL             9
+	#define LCD_DB_LINE_SW           8
+	#define LCD_CPV2_SEL             7
+	#define LCD_CPV1_SEL             6
+	#define LCD_STV2_SEL             5
+	#define LCD_STV1_SEL             4
+	#define LCD_OEV_UNITE            3
+	#define LCD_OEV3_SEL             2
+	#define LCD_OEV2_SEL             1
+	#define LCD_OEV1_SEL             0
+
+/* for DUAL_PORT_CNTL_ADDR */
+	#define LCD_ANALOG_SEL_CPH3      8
+	#define LCD_ANALOG_3PHI_CLK_SEL  7
+	#define LCD_LVDS_SEL54           6
+	#define LCD_LVDS_SEL27           5
+	#define LCD_TTL_SEL              4
+	#define LCD_DUAL_PIXEL           3
+	#define LCD_PORT_SWP             2
+	#define LCD_RGB_SWP              1
+	#define LCD_BIT_SWP              0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LCD_LD_CNT_MSB           7
+	#define LCD_LD_CNT               5
+	#define LCD_PN_SWP               4
+	#define LCD_RES                  3
+	#define LCD_LVDS_PORT_SWP        2
+	#define LCD_PACK_RVS             1
+	#define LCD_PACK_LITTLE          0
+
+/* for LVDS_BLANK_DATA */
+	#define LVDS_BLANK_DATA_RESERVED    30
+	#define LVDS_BLANK_DATA_R           20
+	#define LVDS_BLANK_DATA_G           10
+	#define LVDS_BLANK_DATA_B           0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LVDS_USE_TCON               7
+	#define LVDS_DUAL                   6
+	#define PN_SWP                      5
+	#define LSB_FIRST                   4
+	#define LVDS_RESV                   3
+	#define ODD_EVEN_SWP                2
+	#define LVDS_REPACK                 0
+
+static const unsigned gamma_sel_table[3] = {
+	LCD_H_SEL_R,
+	LCD_H_SEL_G,
+	LCD_H_SEL_B,
+};
+
+/* ******************************************** */
+/* for video encoder */
+	#define LVDS_DELAY			8
+	#define TTL_DELAY			19
+
+/* ********************************************
+// for clk parameter auto generation
+// ********************************************* */
+/**** clk parameters bit ***/
+	/* pll_ctrl */
+	#define PLL_CTRL_LOCK			31
+	#define PLL_CTRL_EN			30
+	#define PLL_CTRL_RST			28
+	#define PLL_CTRL_OD2			22 /* [23:22] */
+	#define PLL_CTRL_OD3			18 /* [19:18] */
+	#define PLL_CTRL_OD1			16 /* [17:16] */
+	#define PLL_CTRL_N			9 /* [13:9] */
+	#define PLL_CTRL_M			0 /* [8:0] */
+
+	/* div_ctrl */
+	#define DIV_CTRL_CLK_DIV		0 /* [7:0] */
+
+	/* clk_ctrl */
+	#define CLK_CTRL_FRAC			16 /* [27:16] */
+
+	#define PLL_WAIT_LOCK_CNT		200
+
+/**** clk frequency limit ***/
+	/* PLL */
+	#define PLL_M_MIN			2
+	#define PLL_M_MAX			511
+	#define PLL_N_MIN			1
+	#define PLL_N_MAX			1
+	#define PLL_FREF_MIN			(5 * 1000)
+	#define PLL_FREF_MAX			(25 * 1000)
+	#define PLL_VCO_MIN			(3000 * 1000)
+	#define PLL_VCO_MAX			(6000 * 1000)
+	/* VIDEO */
+	#define CLK_DIV_MAX_CLK_IN		(3000 * 1000)
+	#define CRT_VID_MAX_CLK_IN		(3000 * 1000)
+	#define ENCL_MAX_CLK_IN			(333 * 1000)
+
+	/* lcd interface video clk */
+	#define LVDS_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define TTL_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+
+	/* clk max error */
+	#define MAX_ERROR			(2 * 1000)
+
+#define CRT_VID_DIV_MAX				255
+
+#define OD_SEL_MAX				3
+
+static unsigned od_table[4] = {1, 2, 4, 8};
+
+/* g9tv, g9bb divider */
+#define CLK_DIV_I2O     0
+#define CLK_DIV_O2I     1
+enum div_sel_e {
+	CLK_DIV_SEL_1 = 0,
+	CLK_DIV_SEL_2,    /* 1 */
+	CLK_DIV_SEL_3,    /* 2 */
+	CLK_DIV_SEL_3p5,  /* 3 */
+	CLK_DIV_SEL_3p75, /* 4 */
+	CLK_DIV_SEL_4,    /* 5 */
+	CLK_DIV_SEL_5,    /* 6 */
+	CLK_DIV_SEL_6,    /* 7 */
+	CLK_DIV_SEL_6p25, /* 8 */
+	CLK_DIV_SEL_7,    /* 9 */
+	CLK_DIV_SEL_7p5,  /* 10 */
+	CLK_DIV_SEL_12,   /* 11 */
+	CLK_DIV_SEL_14,   /* 12 */
+	CLK_DIV_SEL_15,   /* 13 */
+	CLK_DIV_SEL_2p5,  /* 14 */
+	CLK_DIV_SEL_MAX,
+};
+/* ******************************************** */
+
+/* ********************************************
+//DPHY Config
+// ******************************************** */
+/* ******** G9TV,G9BB ******** */
+/* bit[15:11] */
+#define BIT_PHY_LANE         16
+#define WIDTH_PHY_LANE       12
+
+/* LVDS */
+#define LVDS_LANE_A0          (1 << 0)
+#define LVDS_LANE_A1          (1 << 1)
+#define LVDS_LANE_A2          (1 << 2)
+#define LVDS_LANE_ACLK        (1 << 3)
+#define LVDS_LANE_A3          (1 << 4)
+#define LVDS_LANE_A4          (1 << 5)
+#define LVDS_LANE_B0          (1 << 6)
+#define LVDS_LANE_B1          (1 << 7)
+#define LVDS_LANE_B2          (1 << 8)
+#define LVDS_LANE_BCLK        (1 << 9)
+#define LVDS_LANE_B3          (1 << 10)
+#define LVDS_LANE_B4          (1 << 11)
+#define LVDS_PORT_A           (LVDS_LANE_ACLK | LVDS_LANE_A0 |\
+				LVDS_LANE_A1 | LVDS_LANE_A2 |\
+				LVDS_LANE_A3 | LVDS_LANE_A4)
+#define LVDS_PORT_B           (LVDS_LANE_BCLK | LVDS_LANE_B0 |\
+				LVDS_LANE_B1 | LVDS_LANE_B2 |\
+				LVDS_LANE_B3 | LVDS_LANE_B4)
+#define LVDS_PORT_AB          (LVDS_PORT_A | LVDS_PORT_B)
+
+/* VBYONE */
+#define VBYONE_LANE_0         (1 << 4)
+#define VBYONE_LANE_1         (1 << 3)
+#define VBYONE_LANE_2         (1 << 1)
+#define VBYONE_LANE_3         (1 << 0)
+#define VBYONE_LANE_4         (1 << 2)
+#define VBYONE_LANE_5         (1 << 3)
+#define VBYONE_LANE_6         (1 << 1)
+#define VBYONE_LANE_7         (1 << 0)
+#define VBYONE_PORT           (VBYONE_LANE_0 | VBYONE_LANE_1 |\
+				VBYONE_LANE_2 | VBYONE_LANE_3 |\
+				VBYONE_LANE_4 | VBYONE_LANE_5 |\
+				VBYONE_LANE_6 | VBYONE_LANE_7)
+
+/* ******************************************** */
+
+#endif
diff --git a/arch/arm/mach-mesong9tv/Makefile b/arch/arm/mach-mesong9tv/Makefile
index e01c0cbd276a..5fcd032f8792 100644
--- a/arch/arm/mach-mesong9tv/Makefile
+++ b/arch/arm/mach-mesong9tv/Makefile
@@ -41,6 +41,8 @@ obj-$(CONFIG_AML_PLATFORM_THERMAL) += thermal.o
 
 obj-$(CONFIG_AML_HDMI_TX_20)   +=  hdmi_tx_hw_20/
 
+obj-$(CONFIG_AM_LCD_OUTPUT) +=  lcd/
+
 # ARM Trustzone
 obj-$(CONFIG_MESON_TRUSTZONE)	+= meson-smc.o meson-secure.o
 ifeq ($(CONFIG_MESON_TRUSTZONE),y)
diff --git a/arch/arm/mach-mesong9tv/include/mach/lcd_reg.h b/arch/arm/mach-mesong9tv/include/mach/lcd_reg.h
new file mode 100644
index 000000000000..c29c432b7ccd
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/include/mach/lcd_reg.h
@@ -0,0 +1,27 @@
+#ifndef LCD_CONTROLLER_REG_H
+#define LCD_CONTROLLER_REG_H
+#include <mach/io.h>
+
+#define LCD_VPU_BUS_BASE				(IO_APB_BUS_BASE + 0x100000)
+#define LCD_REG_BASE_ADDR				LCD_VPU_BUS_BASE
+#define LCD_CBUS_BASE_ADDR				IO_CBUS_BASE
+
+#define LCD_REG_OFFSET(reg)				(reg << 2)
+#define LCD_CBUS_OFFSET(reg)				(reg << 2)
+
+#define LCD_REG_ADDR(reg)				VCBUS_REG_ADDR(reg)//(LCD_REG_BASE_ADDR + LCD_REG_OFFSET(reg))
+#define LCD_CBUS_ADDR(reg)				CBUS_REG_ADDR(reg)//(LCD_CBUS_BASE_ADDR + LCD_CBUS_OFFSET(reg))
+
+#define WRITE_LCD_REG(reg, val) 			aml_write_reg32(LCD_REG_ADDR(reg), (val))
+#define READ_LCD_REG(reg) 				aml_read_reg32(LCD_REG_ADDR(reg))
+#define WRITE_LCD_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_REG_ADDR(reg), (val), start, len)
+#define CLR_LCD_REG_MASK(reg, mask)   			aml_clr_reg32_mask(LCD_REG_ADDR(reg), (mask))
+#define SET_LCD_REG_MASK(reg, mask)     		aml_set_reg32_mask(LCD_REG_ADDR(reg), (mask))
+
+#define WRITE_LCD_CBUS_REG(reg, val) 			aml_write_reg32(LCD_CBUS_ADDR(reg), (val))
+#define READ_LCD_CBUS_REG(reg) 				aml_read_reg32(LCD_CBUS_ADDR(reg))
+#define WRITE_LCD_CBUS_REG_BITS(reg, val, start, len) 	aml_set_reg32_bits(LCD_CBUS_ADDR(reg), (val), start, len)
+#define CLR_LCD_CBUS_REG_MASK(reg, mask)   		aml_clr_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+#define SET_LCD_CBUS_REG_MASK(reg, mask)     		aml_set_reg32_mask(LCD_CBUS_ADDR(reg), (mask))
+
+#endif
diff --git a/arch/arm/mach-mesong9tv/include/mach/lcdoutc.h b/arch/arm/mach-mesong9tv/include/mach/lcdoutc.h
index a058677d450a..a4f9639f7868 100644
--- a/arch/arm/mach-mesong9tv/include/mach/lcdoutc.h
+++ b/arch/arm/mach-mesong9tv/include/mach/lcdoutc.h
@@ -3,6 +3,8 @@
 #define MACH_LCDOUTC_H
 
 #define CONFIG_LCD_TYPE_TV_VALID
+#define CONFIG_LCD_TYPE_MID_VALID
+#define CONFIG_LCD_IF_TTL_VALID
 #define CONFIG_LCD_IF_LVDS_VALID
 
 /*
diff --git a/arch/arm/mach-mesong9tv/include/mach/mlvds_regs.h b/arch/arm/mach-mesong9tv/include/mach/mlvds_regs.h
deleted file mode 100755
index 76d7eea780fa..000000000000
--- a/arch/arm/mach-mesong9tv/include/mach/mlvds_regs.h
+++ /dev/null
@@ -1,200 +0,0 @@
-#ifndef __MLVDS_REGS_H
-#define __MLVDS_REGS_H
-
-#define MLVDS_TCON0 0
-#define MLVDS_TCON1 1
-#define MLVDS_TCON2 2
-#define MLVDS_TCON3 3
-#define MLVDS_TCON4 4
-#define MLVDS_TCON5 5
-#define MLVDS_TCON6 6
-#define MLVDS_TCON7 7
-
-//the following register function is a little different as before
-//but the address is same
-//MTCON0-3 is full function, and MTCON4-7 is reduced.
-#define MTCON0_1ST_HS_ADDR                         0x1410  //L_STH1_HS_ADDR
-#define P_MTCON0_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON0_1ST_HE_ADDR                         0x1411  //L_STH1_HE_ADDR
-#define P_MTCON0_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON0_1ST_VS_ADDR                         0x1412  //L_STH1_VS_ADDR
-#define P_MTCON0_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON0_1ST_VE_ADDR                         0x1413  //L_STH1_VE_ADDR
-#define P_MTCON0_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON0_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_HS_ADDR                         0x1414  //L_STH2_HS_ADDR
-#define P_MTCON0_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_HE_ADDR                         0x1415  //L_STH2_HE_ADDR
-#define P_MTCON0_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_VS_ADDR                         0x1416  //L_STH2_VS_ADDR
-#define P_MTCON0_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON0_2ND_VE_ADDR                         0x1417  //L_STH2_VE_ADDR
-#define P_MTCON0_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON0_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON1_1ST_HS_ADDR                         0x141f  //L_CPV1_HS_ADDR
-#define P_MTCON1_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON1_1ST_HE_ADDR                         0x1420  //L_CPV1_HE_ADDR
-#define P_MTCON1_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON1_1ST_VS_ADDR                         0x1421  //L_CPV1_VS_ADDR
-#define P_MTCON1_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON1_1ST_VE_ADDR                         0x1422  //L_CPV1_VE_ADDR
-#define P_MTCON1_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON1_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_HS_ADDR                         0x1423  //L_CPV2_HS_ADDR
-#define P_MTCON1_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_HE_ADDR                         0x1424  //L_CPV2_HE_ADDR
-#define P_MTCON1_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_VS_ADDR                         0x1425  //L_CPV2_VS_ADDR
-#define P_MTCON1_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON1_2ND_VE_ADDR                         0x1426  //L_CPV2_VE_ADDR
-#define P_MTCON1_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON1_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON2_1ST_HS_ADDR                         0x1427  //L_STV1_HS_ADDR
-#define P_MTCON2_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON2_1ST_HE_ADDR                         0x1428  //L_STV1_HE_ADDR
-#define P_MTCON2_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON2_1ST_VS_ADDR                         0x1429  //L_STV1_VS_ADDR
-#define P_MTCON2_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON2_1ST_VE_ADDR                         0x142a  //L_STV1_VE_ADDR
-#define P_MTCON2_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON2_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_HS_ADDR                         0x142b  //L_STV2_HS_ADDR
-#define P_MTCON2_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_HE_ADDR                         0x142c  //L_STV2_HE_ADDR
-#define P_MTCON2_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_VS_ADDR                         0x142d  //L_STV2_VS_ADDR
-#define P_MTCON2_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON2_2ND_VE_ADDR                         0x142e  //L_STV2_VE_ADDR
-#define P_MTCON2_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON2_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON3_1ST_HS_ADDR                         0x142f  //L_OEV1_HS_ADDR
-#define P_MTCON3_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON3_1ST_HE_ADDR                         0x1430  //L_OEV1_HE_ADDR
-#define P_MTCON3_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON3_1ST_VS_ADDR                         0x1431  //L_OEV1_VS_ADDR
-#define P_MTCON3_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON3_1ST_VE_ADDR                         0x1432  //L_OEV1_VE_ADDR
-#define P_MTCON3_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON3_1ST_VE_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_HS_ADDR                         0x1433  //L_OEV2_HS_ADDR
-#define P_MTCON3_2ND_HS_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_HS_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_HE_ADDR                         0x1434  //L_OEV2_HE_ADDR
-#define P_MTCON3_2ND_HE_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_HE_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_VS_ADDR                         0x1435  //L_OEV2_VS_ADDR
-#define P_MTCON3_2ND_VS_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_VS_ADDR) 	///../ucode/register.h
-#define MTCON3_2ND_VE_ADDR                         0x1436  //L_OEV2_VE_ADDR
-#define P_MTCON3_2ND_VE_ADDR 		CBUS_REG_ADDR(MTCON3_2ND_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON4_1ST_HS_ADDR                         0x1455  //L_HSYNC_HS_ADDR
-#define P_MTCON4_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON4_1ST_HE_ADDR                         0x1456  //L_HSYNC_HE_ADDR
-#define P_MTCON4_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON4_1ST_VS_ADDR                         0x1457  //L_HSYNC_VS_ADDR
-#define P_MTCON4_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON4_1ST_VE_ADDR                         0x1458  //L_HSYNC_VE_ADDR
-#define P_MTCON4_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON4_1ST_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON5_1ST_HS_ADDR                         0x1459  //L_VSYNC_HS_ADDR
-#define P_MTCON5_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON5_1ST_HE_ADDR                         0x145a  //L_VSYNC_HE_ADDR
-#define P_MTCON5_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON5_1ST_VS_ADDR                         0x145b  //L_VSYNC_VS_ADDR
-#define P_MTCON5_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON5_1ST_VE_ADDR                         0x145c  //L_VSYNC_VE_ADDR
-#define P_MTCON5_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON5_1ST_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON6_1ST_HS_ADDR                         0x1418  //L_OEH_HS_ADDR
-#define P_MTCON6_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON6_1ST_HE_ADDR                         0x1419  //L_OEH_HE_ADDR
-#define P_MTCON6_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON6_1ST_VS_ADDR                         0x141a  //L_OEH_VS_ADDR
-#define P_MTCON6_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON6_1ST_VE_ADDR                         0x141b  //L_OEH_VE_ADDR
-#define P_MTCON6_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON6_1ST_VE_ADDR) 	///../ucode/register.h
-
-#define MTCON7_1ST_HS_ADDR                         0x1437  //L_OEV3_HS_ADDR
-#define P_MTCON7_1ST_HS_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_HS_ADDR) 	///../ucode/register.h
-#define MTCON7_1ST_HE_ADDR                         0x1438  //L_OEV3_HE_ADDR
-#define P_MTCON7_1ST_HE_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_HE_ADDR) 	///../ucode/register.h
-#define MTCON7_1ST_VS_ADDR                         0x1439  //L_OEV3_VS_ADDR
-#define P_MTCON7_1ST_VS_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_VS_ADDR) 	///../ucode/register.h
-#define MTCON7_1ST_VE_ADDR                         0x143a  //L_OEV3_VE_ADDR
-#define P_MTCON7_1ST_VE_ADDR 		CBUS_REG_ADDR(MTCON7_1ST_VE_ADDR) 	///../ucode/register.h
-
-//#define MLVDS_CONTROL                              0x14c3
-   #define     mLVDS_RESERVED  15    // 15
-   #define     mLVDS_double_pattern  14    // 14
-   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
-   #define     mLVDS_dual_gate  7
-   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
-   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
-   #define     mLVDS_msb_first  4
-   #define     mLVDS_PORT_SWAP  3
-   #define     mLVDS_MLSB_SWAP  2
-   #define     mLVDS_PN_SWAP    1
-   #define     mLVDS_en         0
-
-//#define MLVDS_CONFIG_HI                            0x14c7
-//#define MLVDS_CONFIG_LO                            0x14c8
-   #define     mLVDS_reset_offset         29 // Bit 31:29
-   #define     mLVDS_reset_length         23 // Bit 28:23
-   #define     mLVDS_config_reserved      20 // Bit 22:20
-   #define     mLVDS_reset_start_bit12    19 // Bit 19
-   #define     mLVDS_data_write_toggle    18
-   #define     mLVDS_data_write_ini       17
-   #define     mLVDS_data_latch_1_toggle  16
-   #define     mLVDS_data_latch_1_ini     15
-   #define     mLVDS_data_latch_0_toggle  14
-   #define     mLVDS_data_latch_0_ini     13
-   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
-   #define     mLVDS_reset_start           0 // Bit 11:0
-
-//#define TCON_DOUBLE_CTL                            0x14c9
-   #define     tcon_double_ini          8 // Bit 7:0
-   #define     tcon_double_inv          0 // Bit 7:0
-//#define TCON_PATTERN_HI                            0x14ca
-//#define TCON_PATTERN_LO                            0x14cb
-   #define     tcon_pattern_loop_data     16 // Bit 15:0
-   #define     tcon_pattern_loop_start    12 // Bit 3:0
-   #define     tcon_pattern_loop_end       8 // Bit 3:0
-   #define     tcon_pattern_enable         0 // Bit 7:0
-//#define TCON_CONTROL_HI                            0x14cc
-//#define TCON_CONTROL_LO                            0x14cd
-   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
-   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clok divide 2,4,6,8)
-   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
-
-//#define MLVDS_DUAL_GATE_CTL_HI                     0x14fb
-//#define MLVDS_DUAL_GATE_CTL_LO                     0x14fc
-   #define     mlvds_tcon_field_en        24 // Bit 7:0
-   #define     mlvds_dual_gate_reserved   21 // Bit 2:0
-   #define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
-   #define     mlvds_scan_mode_odd        16 // Bit 3:0
-   #define     mlvds_scan_mode_even       12 // Bit 3:0
-   #define     mlvds_scan_mode_start_line  0 // Bit 11:0
-//#define MLVDS_RESET_CONFIG_HI                      0x14fd
-//#define MLVDS_RESET_CONFIG_LO                      0x14fe
-   #define     mLVDS_reset_range_enable   31 // Bit 0
-   #define     mLVDS_reset_range_inv      30 // Bit 0
-   #define     mLVDS_reset_config_res1    29 // Bit 0
-   #define     mLVDS_reset_range_line_0   16 // Bit 11:0
-   #define     mLVDS_reset_config_res3    13 // Bit 2:0
-   #define     mLVDS_reset_range_line_1    0 // Bit 11:0
-
-//#define MLVDS_CLK_CTL_HI                           0x14f4
-//#define MLVDS_CLK_CTL_LO                           0x14f5
-   #define     mlvds_clk_pattern_reserved 31 // Bit 31
-   #define     mpclk_dly                  28 // Bit 2:0
-   #define     mpclk_div                  26 // Bit 1:0 (control phy clok divide 2,4,6,8)
-   #define     use_mpclk                  25 // Bit 0
-   #define     mlvds_clk_half_delay       24 // Bit 0
-   #define     mlvds_clk_pattern           0 // Bit 23:0
-//#define MLVDS_DUAL_GATE_WR_START                   0x14f6
-   #define     mlvds_dual_gate_wr_start    0 // Bit 12:0
-//#define MLVDS_DUAL_GATE_WR_END                     0x14f7
-   #define     mlvds_dual_gate_wr_end      0 // Bit 12:0
-//#define MLVDS_DUAL_GATE_RD_START                   0x14f8
-   #define     mlvds_dual_gate_rd_start    0 // Bit 12:0
-//#define MLVDS_DUAL_GATE_RD_END                     0x14f9
-   #define     mlvds_dual_gate_rd_end      0 // Bit 12:0
-//#define MLVDS_SECOND_RESET_CTL                     0x14fa
-   #define     mLVDS_2nd_reset_start       0 // Bit 12:0
-
-#endif
-
diff --git a/arch/arm/mach-mesong9tv/lcd/Makefile b/arch/arm/mach-mesong9tv/lcd/Makefile
new file mode 100644
index 000000000000..47e41434403b
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/lcd/Makefile
@@ -0,0 +1 @@
+obj-y		+= lcd_config.o
diff --git a/arch/arm/mach-mesong9tv/lcd/lcd_config.c b/arch/arm/mach-mesong9tv/lcd/lcd_config.c
new file mode 100644
index 000000000000..081f735005e9
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/lcd/lcd_config.c
@@ -0,0 +1,1472 @@
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
+ * compatible dts
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <linux/amlogic/vout/aml_lcd_common.h>
+#include <mach/clock.h>
+#include <mach/vpu.h>
+#include <mach/mod_gate.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include "lcd_config.h"
+
+#define VPP_OUT_SATURATE	(1 << 0)
+
+static spinlock_t gamma_write_lock;
+static spinlock_t lcd_clk_lock;
+
+static Lcd_Config_t *lcd_conf;
+
+#define SS_LEVEL_MAX	1
+static char *lcd_ss_level_table[] = {
+	"0",
+	"0.5%",
+	"1%",
+	"1.5%",
+	"2%",
+};
+
+#define LVDS_VSWING_LEVEL_MAX  5
+static unsigned int lvds_vswing_ctrl[] = {
+/* vswing_ctrl   level   voltage */
+	0x1,   /* 0      0.2V */
+	0x3,   /* 1      0.4V */
+	0x5,   /* 2      0.6V */
+	0x6,   /* 3      0.7V */
+	0x7,   /* 4      0.8V */
+};
+
+static void print_lcd_driver_version(void)
+{
+	printk("lcd driver version: %s%s\n\n", LCD_DRV_DATE, LCD_DRV_TYPE);
+}
+
+static void lcd_ports_ctrl_lvds(Bool_t status)
+{
+	unsigned int phy_reg, phy_bit, phy_width;
+	unsigned int lane_cnt;
+	LVDS_Config_t *lconf;
+
+	lconf = lcd_conf->lcd_control.lvds_config;
+	if (status) {
+		WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1); /*enable lvds fifo*/
+		phy_reg = HHI_DIF_CSI_PHY_CNTL3;
+		phy_bit = BIT_PHY_LANE;
+		phy_width = WIDTH_PHY_LANE;
+		if (lconf->port_sel == LVDS_PORT_A)
+			lane_cnt = LVDS_PORT_A;
+		else if (lconf->port_sel == LVDS_PORT_B)
+			lane_cnt = LVDS_PORT_B;
+		else
+			lane_cnt = LVDS_PORT_AB;
+		WRITE_LCD_CBUS_REG_BITS(phy_reg, lane_cnt, phy_bit, phy_width);
+	} else {
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x0);
+		WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x0);
+	}
+
+	lcd_print("%s: %s\n", __func__, (status ? "ON" : "OFF"));
+}
+
+/* the string must match pinctrl-names in dts */
+const char *lcd_ports_ttl_pinmux_str[] = {
+	"ttl_6bit_hvsync_on",      /* 0 */
+	"ttl_6bit_de_on",          /* 1 */
+	"ttl_6bit_hvsync_de_on",   /* 2 */
+	"ttl_8bit_hvsync_on",      /* 3 */
+	"ttl_8bit_de_on",          /* 4 */
+	"ttl_8bit_hvsync_de_on",   /* 5 */
+	"ttl_6bit_hvsync_de_off",  /* 6 */
+	"ttl_8bit_hvsync_de_off",  /* 7 */
+};
+
+static void lcd_ports_ctrl_ttl(Bool_t status)
+{
+	struct pinctrl *pin;
+	struct pinctrl_state *s;
+	unsigned int pinmux_num;
+	int ret;
+
+	if (IS_ERR(lcd_conf->lcd_misc_ctrl.pin)) {
+		pr_info("set ttl_ports_ctrl pinmux error.\n");
+		return;
+	}
+	/* get pinmux control */
+	pin = lcd_conf->lcd_misc_ctrl.pin;
+
+	if (status) {
+		if (lcd_conf->lcd_basic.lcd_bits == 6) {
+			if (lcd_conf->lcd_timing.de_valid == 0)
+				pinmux_num = 0;
+			else if (lcd_conf->lcd_timing.hvsync_valid == 0)
+				pinmux_num = 1;
+			else
+				pinmux_num = 2;
+		} else {
+			if (lcd_conf->lcd_timing.de_valid == 0)
+				pinmux_num = 3;
+			else if (lcd_conf->lcd_timing.hvsync_valid == 0)
+				pinmux_num = 4;
+			else
+				pinmux_num = 5;
+		}
+	} else {
+		if (lcd_conf->lcd_basic.lcd_bits == 6)
+			pinmux_num = 6;
+		else
+			pinmux_num = 7;
+	}
+
+	/* select pinmux */
+	s = pinctrl_lookup_state(pin, lcd_ports_ttl_pinmux_str[pinmux_num]);
+	if (IS_ERR(s)) {
+		printk("set ttl_ports_ctrl pinmux error\n");
+		devm_pinctrl_put(pin); /* pinctrl_put(pin); //release pins */
+		return;
+	}
+
+	/* set pinmux and lock pins */
+	ret = pinctrl_select_state(pin, s);
+	if (ret < 0) {
+		printk("set ttl_ports_ctrl pinmux error\n");
+		devm_pinctrl_put(pin);
+		return;
+	}
+
+	lcd_print("%s: %s\n", __func__, (status ? "ON" : "OFF"));
+}
+
+static void lcd_ports_ctrl(Bool_t status)
+{
+	switch (lcd_conf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		lcd_ports_ctrl_lvds(status);
+		break;
+	case LCD_DIGITAL_TTL:
+		lcd_ports_ctrl_ttl(status);
+		break;
+	default:
+		printk("Invalid LCD type\n");
+		break;
+	}
+}
+
+#define LCD_GAMMA_RETRY_CNT            1000
+static unsigned char lcd_gamma_init_err = 0;
+static void write_gamma_table(u16 *data, u32 rgb_mask, u16 gamma_coeff, u32 gamma_reverse)
+{
+	int i;
+	int cnt = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&gamma_write_lock, flags);
+	rgb_mask = gamma_sel_table[rgb_mask];
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x0 << LCD_HADR));
+	if (gamma_reverse == 0) {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[i] * gamma_coeff / 100));
+		}
+	}
+	else {
+		for (i=0;i<256;i++) {
+			cnt = 0;
+			while ((!( READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_WR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+				udelay(10);
+				cnt++;
+			};
+			WRITE_LCD_REG(L_GAMMA_DATA_PORT, (data[255-i] * gamma_coeff / 100));
+		}
+	}
+	cnt = 0;
+	while ((!(READ_LCD_REG(L_GAMMA_CNTL_PORT) & (0x1 << LCD_ADR_RDY))) && (cnt < LCD_GAMMA_RETRY_CNT)) {
+		udelay(10);
+		cnt++;
+	};
+	WRITE_LCD_REG(L_GAMMA_ADDR_PORT, (0x1 << LCD_H_AUTO_INC) | (0x1 << rgb_mask) | (0x23 << LCD_HADR));
+
+	if (cnt >= LCD_GAMMA_RETRY_CNT)
+		lcd_gamma_init_err = 1;
+
+	spin_unlock_irqrestore(&gamma_write_lock, flags);
+}
+
+static void set_gamma_table_lcd(unsigned int gamma_en)
+{
+	unsigned int reverse, coeff;
+	unsigned short *gtable;
+
+	lcd_print("%s\n", __func__);
+
+	lcd_gamma_init_err = 0;
+	reverse = ((lcd_conf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1);
+	gtable = lcd_conf->lcd_effect.GammaTableR;
+	coeff = lcd_conf->lcd_effect.gamma_r_coeff;
+	write_gamma_table(gtable, GAMMA_SEL_R, coeff, reverse);
+	gtable = lcd_conf->lcd_effect.GammaTableG;
+	coeff = lcd_conf->lcd_effect.gamma_g_coeff;
+	write_gamma_table(gtable, GAMMA_SEL_G, coeff, reverse);
+	gtable = lcd_conf->lcd_effect.GammaTableB;
+	coeff = lcd_conf->lcd_effect.gamma_b_coeff;
+	write_gamma_table(gtable, GAMMA_SEL_B, coeff, reverse);
+
+	if (lcd_gamma_init_err) {
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, 0, 0, 1);
+		printk("[warning]: write gamma table error, gamma table disabled\n");
+	}
+	else
+		WRITE_LCD_REG_BITS(L_GAMMA_CNTL_PORT, gamma_en, 0, 1);
+}
+
+static void set_tcon_lcd(Lcd_Config_t *pconf)
+{
+	Lcd_Timing_t *tcon_adr = &(pconf->lcd_timing);
+	unsigned int tcon_pol_ctrl;
+	unsigned hs_pol_adj, vs_pol_adj, clk_pol;
+	unsigned int gamma_en;
+
+	lcd_print("%s\n", __func__);
+
+	gamma_en = (pconf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1;
+	set_gamma_table_lcd(gamma_en);
+
+	WRITE_LCD_REG(L_RGB_BASE_ADDR,  pconf->lcd_effect.rgb_base_addr);
+	WRITE_LCD_REG(L_RGB_COEFF_ADDR, pconf->lcd_effect.rgb_coeff_addr);
+	if (pconf->lcd_effect.dith_user) {
+		WRITE_LCD_REG(L_DITH_CNTL_ADDR,
+			pconf->lcd_effect.dith_cntl_addr);
+	} else {
+		if (pconf->lcd_basic.lcd_bits == 8)
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x400);
+		else
+			WRITE_LCD_REG(L_DITH_CNTL_ADDR,  0x600);
+	}
+
+	tcon_pol_ctrl = pconf->lcd_timing.pol_ctrl;
+	clk_pol = (tcon_pol_ctrl >> POL_CTRL_CLK) & 1;
+	WRITE_LCD_REG(L_POL_CNTL_ADDR, (clk_pol << LCD_CPH1_POL));
+
+	hs_pol_adj = (((tcon_pol_ctrl >> POL_CTRL_HS) & 1) ? 0 : 1);
+	vs_pol_adj = (((tcon_pol_ctrl >> POL_CTRL_VS) & 1) ? 0 : 1);
+	/* adjust hvsync pol */
+	SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((0 << LCD_DE_POL) |
+		(vs_pol_adj << LCD_VS_POL) | (hs_pol_adj << LCD_HS_POL)));
+	/* enable tcon DE, Hsync, Vsync */
+	SET_LCD_REG_MASK(L_POL_CNTL_ADDR, ((1 << LCD_TCON_DE_SEL) |
+		(1 << LCD_TCON_VS_SEL) | (1 << LCD_TCON_HS_SEL)));
+
+	/* DE signal for lvds */
+	WRITE_LCD_REG(L_DE_HS_ADDR,    tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_DE_HE_ADDR,    tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_DE_VS_ADDR,    tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_DE_VE_ADDR,    tcon_adr->de_ve_addr);
+	/* DE signal for TTL */
+	WRITE_LCD_REG(L_OEV1_HS_ADDR,  tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_OEV1_HE_ADDR,  tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_OEV1_VS_ADDR,  tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_OEV1_VE_ADDR,  tcon_adr->de_ve_addr);
+	WRITE_LCD_REG(L_OEH_HS_ADDR,  tcon_adr->de_hs_addr);
+	WRITE_LCD_REG(L_OEH_HE_ADDR,  tcon_adr->de_he_addr);
+	WRITE_LCD_REG(L_OEH_VS_ADDR,  tcon_adr->de_vs_addr);
+	WRITE_LCD_REG(L_OEH_VE_ADDR,  tcon_adr->de_ve_addr);
+
+	/* Hsync signal */
+	WRITE_LCD_REG(L_HSYNC_HS_ADDR, tcon_adr->hs_hs_addr);
+	WRITE_LCD_REG(L_HSYNC_HE_ADDR, tcon_adr->hs_he_addr);
+	WRITE_LCD_REG(L_HSYNC_VS_ADDR, tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(L_HSYNC_VE_ADDR, tcon_adr->hs_ve_addr);
+	if ((tcon_pol_ctrl >> POL_CTRL_HS) & 1) {
+		WRITE_LCD_REG(L_STH1_HS_ADDR, tcon_adr->hs_hs_addr);
+		WRITE_LCD_REG(L_STH1_HE_ADDR, tcon_adr->hs_he_addr);
+	} else {
+		WRITE_LCD_REG(L_STH1_HS_ADDR, tcon_adr->hs_he_addr);
+		WRITE_LCD_REG(L_STH1_HE_ADDR, tcon_adr->hs_hs_addr);
+	}
+	WRITE_LCD_REG(L_STH1_VS_ADDR, tcon_adr->hs_vs_addr);
+	WRITE_LCD_REG(L_STH1_VE_ADDR, tcon_adr->hs_ve_addr);
+
+	/* Vsync signal */
+	WRITE_LCD_REG(L_VSYNC_HS_ADDR, tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(L_VSYNC_HE_ADDR, tcon_adr->vs_he_addr);
+	WRITE_LCD_REG(L_VSYNC_VS_ADDR, tcon_adr->vs_vs_addr);
+	WRITE_LCD_REG(L_VSYNC_VE_ADDR, tcon_adr->vs_ve_addr);
+	WRITE_LCD_REG(L_STV1_HS_ADDR, tcon_adr->vs_hs_addr);
+	WRITE_LCD_REG(L_STV1_HE_ADDR, tcon_adr->vs_he_addr);
+	if ((tcon_pol_ctrl >> POL_CTRL_VS) & 1) {
+		WRITE_LCD_REG(L_STV1_VS_ADDR, tcon_adr->vs_vs_addr);
+		WRITE_LCD_REG(L_STV1_VE_ADDR, tcon_adr->vs_ve_addr);
+	} else {
+		WRITE_LCD_REG(L_STV1_VS_ADDR, tcon_adr->vs_ve_addr);
+		WRITE_LCD_REG(L_STV1_VE_ADDR, tcon_adr->vs_vs_addr);
+	}
+
+	WRITE_LCD_REG(L_INV_CNT_ADDR,       0);
+	WRITE_LCD_REG(L_TCON_MISC_SEL_ADDR,
+		((1 << LCD_STV1_SEL) | (1 << LCD_STV2_SEL)));
+
+	if (pconf->lcd_misc_ctrl.vpp_sel)
+		CLR_LCD_REG_MASK(VPP2_MISC, (VPP_OUT_SATURATE));
+	else
+		CLR_LCD_REG_MASK(VPP_MISC, (VPP_OUT_SATURATE));
+}
+
+static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
+{
+	unsigned m, n, od1, od2, od3, frac;
+	int wait_loop = PLL_WAIT_LOCK_CNT;
+	unsigned pll_lock = 0;
+	unsigned pll_ctrl, pll_ctrl2;
+
+	lcd_print("%s\n", __func__);
+
+	m = (pll_reg >> PLL_CTRL_M) & 0x1ff;
+	n = (pll_reg >> PLL_CTRL_N) & 0x1f;
+	od1 = (pll_reg >> PLL_CTRL_OD1) & 0x3;
+	od2 = (pll_reg >> PLL_CTRL_OD2) & 0x3;
+	od3 = (pll_reg >> PLL_CTRL_OD3) & 0x3;
+	frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
+
+	pll_ctrl = ((1 << 30) | (n << 9) | (m << 0));
+	pll_ctrl2 = ((od1 << 16) | (od2 << 22) | (od3 << 18));
+	if (frac > 0)
+		pll_ctrl2 |= ((1 << 14) | (frac << 0));
+
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL, pll_ctrl | (1 << 28));
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL2, pll_ctrl2);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL3, 0x135c5091);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL4, 0x801da72c);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL5, 0x71486900);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL6, 0x00000a55);
+	WRITE_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL, pll_ctrl);
+
+	do {
+		udelay(50);
+		pll_lock = (READ_LCD_CBUS_REG(HHI_HDMI_PLL_CNTL) >> 31) & 0x1;
+		wait_loop--;
+	} while ((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		pr_info("[error]: hpll lock failed\n");
+}
+
+static unsigned int lcd_clk_div_table[][3] = {
+	/* divider,        shift_val,  shift_sel */
+	{CLK_DIV_SEL_1,    0xffff,     0,},
+	{CLK_DIV_SEL_2,    0x0aaa,     0,},
+	{CLK_DIV_SEL_3,    0x0db6,     0,},
+	{CLK_DIV_SEL_3p5,  0x36cc,     1,},
+	{CLK_DIV_SEL_3p75, 0x6666,     2,},
+	{CLK_DIV_SEL_4,    0x0ccc,     0,},
+	{CLK_DIV_SEL_5,    0x739c,     2,},
+	{CLK_DIV_SEL_6,    0x0e38,     0,},
+	{CLK_DIV_SEL_6p25, 0x0000,     3,},
+	{CLK_DIV_SEL_7,    0x3c78,     1,},
+	{CLK_DIV_SEL_7p5,  0x78f0,     2,},
+	{CLK_DIV_SEL_12,   0x0fc0,     0,},
+	{CLK_DIV_SEL_14,   0x3f80,     1,},
+	{CLK_DIV_SEL_15,   0x7f80,     2,},
+	{CLK_DIV_SEL_2p5,  0x5294,     2,},
+	{CLK_DIV_SEL_MAX,  0xffff,     0,},
+};
+
+static void lcd_set_clk_div(unsigned long vid_div_reg)
+{
+	unsigned int  clk_div;
+	unsigned int shift_val, shift_sel;
+	int i;
+	lcd_print("%s\n", __func__);
+
+	clk_div = (vid_div_reg >> DIV_CTRL_CLK_DIV) & 0xf;
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 19, 1);
+	udelay(5);
+
+	/* Disable the div output clock */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+	i = 0;
+	while (lcd_clk_div_table[i][0] != CLK_DIV_SEL_MAX) {
+		if (clk_div == lcd_clk_div_table[i][0])
+			break;
+		i++;
+	}
+	if (lcd_clk_div_table[i][0] == CLK_DIV_SEL_MAX)
+		pr_info("invalid clk divider\n");
+	shift_val = lcd_clk_div_table[i][1];
+	shift_sel = lcd_clk_div_table[i][2];
+
+	if (shift_val == 0xffff) { /* if divide by 1 */
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+	} else {
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+		WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+	}
+	/* Enable the final output clock */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+static void lcd_set_vclk_crt(unsigned int clk_ctrl_reg)
+{
+	unsigned int xd;
+	lcd_print("%s\n", __func__);
+
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xff;
+	/* setup the XD divider value */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, (xd-1), 0, 8);
+	udelay(5);
+	/* Bit[18:16] - v2_cntl_clk_in_sel */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 16, 3);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 19, 1);
+	udelay(2);
+
+	/* [15:12] encl_clk_sel, select vclk2_div1 */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 8, 12, 4);
+	/* release vclk2_div_reset and enable vclk2_div */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 1, 16, 2);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 0, 1);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 1, 15, 1);
+	udelay(10);
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 15, 1);
+	udelay(5);
+
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 3, 1);
+}
+
+static void set_vclk_lcd(Lcd_Config_t *pconf)
+{
+	unsigned pll_reg, div_reg, clk_reg;
+	int xd;
+	int lcd_type;
+	unsigned long flags = 0;
+
+	lcd_print("%s\n", __func__);
+
+	pll_reg = pconf->lcd_timing.pll_ctrl;
+	div_reg = pconf->lcd_timing.div_ctrl;
+	clk_reg = pconf->lcd_timing.clk_ctrl;
+	xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
+
+	lcd_type = pconf->lcd_basic.lcd_type;
+
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		xd = 1;
+		break;
+	default:
+		break;
+	}
+	clk_reg = (pconf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) |
+		(xd << CLK_CTRL_XD);
+
+	spin_lock_irqsave(&lcd_clk_lock, flags);
+	lcd_set_pll(pll_reg, clk_reg);
+	lcd_set_clk_div(div_reg);
+	lcd_set_vclk_crt(clk_reg);
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
+}
+
+static void set_venc_lcd(Lcd_Config_t *pconf)
+{
+	lcd_print("%s\n", __func__);
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0);
+#ifdef CONFIG_AM_TV_OUTPUT2
+	if (pconf->lcd_misc_ctrl.vpp_sel) {
+		/* viu2 select encl */
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);
+	} else {
+		/* viu1 select encl */
+		WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);
+	}
+#else
+	/* viu1, viu2 select encl */
+	WRITE_LCD_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);
+#endif
+
+	WRITE_LCD_REG(ENCL_VIDEO_MODE,        0);
+	WRITE_LCD_REG(ENCL_VIDEO_MODE_ADV,    0x8); /* Sampling rate: 1 */
+
+	WRITE_LCD_REG(ENCL_VIDEO_FILT_CTRL,   0x1000); /* bypass filter */
+
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_PXCNT,   pconf->lcd_basic.h_period - 1);
+	WRITE_LCD_REG(ENCL_VIDEO_MAX_LNCNT,   pconf->lcd_basic.v_period - 1);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_BEGIN, pconf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_HAVON_END,   pconf->lcd_basic.h_active - 1 +
+		pconf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_BLINE, pconf->lcd_timing.video_on_line);
+	WRITE_LCD_REG(ENCL_VIDEO_VAVON_ELINE, pconf->lcd_basic.v_active - 1 +
+		pconf->lcd_timing.video_on_line);
+
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_BEGIN,   10);
+	WRITE_LCD_REG(ENCL_VIDEO_HSO_END,     16);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BEGIN,   pconf->lcd_timing.vso_hstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_END,     pconf->lcd_timing.vso_hstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE,   pconf->lcd_timing.vso_vstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,   pconf->lcd_timing.vso_vstart + 2);
+
+	WRITE_LCD_REG(ENCL_VIDEO_RGBIN_CTRL,  (1 << 0)); /*bit[0] 1:RGB, 0:YUV*/
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN,          1);
+}
+
+static void clk_util_lvds_set_clk_div(Lcd_Config_t *pconf)
+{
+	unsigned int phy_div2, wr_mode;
+
+	if (pconf->lcd_control.lvds_config->dual_port == 0) {
+		phy_div2 = 0;
+		wr_mode = 1;
+	} else {
+		phy_div2 = 1;
+		wr_mode = 3;
+	}
+
+	/* ---------------------------------------------
+	// Configure the LVDS PHY
+	// ---------------------------------------------
+	// wire    [4:0]   cntl_ser_en         = control[20:16];
+	// wire            cntl_prbs_en        = control[13];
+	// wire            cntl_prbs_err_en    = control[12];
+	// wire    [1:0]   cntl_mode_set_high  = control[11:10];
+	// wire    [1:0]   cntl_mode_set_low   = control[9:8];
+	//
+	// wire    [1:0]   fifo_clk_sel        = control[7;6]
+	//
+	// wire            mode_port_rev       = control[4];
+	// wire            mode_bit_rev        = control[3];
+	// wire            mode_inv_p_n        = control[2];
+	// wire            phy_clk_en          = control[1];
+	// wire            soft_reset_int      = control[0];
+	// enable all serializers, divide by 7 */
+	WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL0, (0xfff << 16) | (0x1 << 6));
+	WRITE_LCD_CBUS_REG(HHI_LVDS_TX_PHY_CNTL1,
+			(1 << 30) | (phy_div2 << 25) | (1 << 24));
+
+	/*    lvds_gen_cntl       <= {10'h0,     // [15:4] unused
+	//                            2'h1,      // [5:4] divide by 7 in the PHY
+	//                            1'b0,      // [3] fifo_en
+	//                            1'b0,      // [2] wr_bist_gate
+	//                            2'b00};    // [1:0] fifo_wr mode
+	//FIFO_CLK_SEL = 1; // div7 */
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 4, 2); /* lvds fifo clk div 7 */
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, wr_mode, 0, 2);  /* fifo wr mode */
+
+	/* lvds phy div reset */
+	WRITE_LCD_CBUS_REG_BITS(HHI_LVDS_TX_PHY_CNTL0, 1, 0, 1);
+	udelay(5);
+	/* Release lvds div reset */
+	WRITE_LCD_CBUS_REG_BITS(HHI_LVDS_TX_PHY_CNTL0, 0, 0, 1);
+}
+
+static void set_control_lvds(Lcd_Config_t *pconf)
+{
+	unsigned int lvds_repack, pn_swap, bit_num;
+	unsigned int dual_port, port_swap;
+	unsigned int data32;
+
+	lcd_print("%s\n", __func__);
+	clk_util_lvds_set_clk_div(pconf);
+
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
+
+	data32 = (0x00 << LVDS_BLANK_DATA_R) |
+		(0x00 << LVDS_BLANK_DATA_G) |
+		(0x00 << LVDS_BLANK_DATA_B);
+	WRITE_LCD_REG(LVDS_BLANK_DATA_HI, (data32 >> 16));
+	WRITE_LCD_REG(LVDS_BLANK_DATA_LO, (data32 & 0xffff));
+
+	dual_port = pconf->lcd_control.lvds_config->dual_port;
+	port_swap = pconf->lcd_control.lvds_config->port_swap;
+	lvds_repack = (pconf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	pn_swap = (pconf->lcd_control.lvds_config->pn_swap) & 0x1;
+
+	switch (pconf->lcd_basic.lcd_bits) {
+	case 10:
+		bit_num = 0;
+		break;
+	case 8:
+		bit_num = 1;
+		break;
+	case 6:
+		bit_num = 2;
+		break;
+	case 4:
+		bit_num = 3;
+		break;
+	default:
+		bit_num = 1;
+		break;
+	}
+
+	WRITE_LCD_REG(LVDS_PACK_CNTL_ADDR,
+		(lvds_repack << 0) | /* repack */
+		(port_swap << 2) | /* odd_even */
+		(0 << 3) | /* reserve */
+		(0 << 4) | /* lsb first */
+		(pn_swap << 5) | /* pn swap */
+		(dual_port << 6) | /* dual port */
+		(0 << 7) | /* use tcon control */
+		(bit_num << 8) | /* 0:10bits, 1:8bits, 2:6bits, 3:4bits. */
+		(0 << 10) | /*r_select  //0:R, 1:G, 2:B, 3:0 */
+		(1 << 12) | /*g_select  //0:R, 1:G, 2:B, 3:0 */
+		(2 << 14));  /*b_select  //0:R, 1:G, 2:B, 3:0;  */
+
+	/* WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 1, 3, 1);  //enable fifo */
+}
+
+static void set_control_ttl(Lcd_Config_t *pconf)
+{
+	unsigned rb_port_swap, rgb_bit_swap;
+
+	rb_port_swap = (unsigned)(pconf->lcd_control.ttl_config->rb_swap);
+	rgb_bit_swap = (unsigned)(pconf->lcd_control.ttl_config->bit_swap);
+
+	WRITE_LCD_REG(L_DUAL_PORT_CNTL_ADDR,
+		(rb_port_swap << LCD_RGB_SWP) | (rgb_bit_swap << LCD_BIT_SWP));
+}
+
+static void init_phy_lvds(Lcd_Config_t *pconf)
+{
+	unsigned int swing_level;
+	unsigned int temp;
+	lcd_print("%s\n", __func__);
+
+	WRITE_LCD_REG(LVDS_SER_EN, 0xfff); /* Enable the serializers */
+
+	WRITE_LCD_REG(LVDS_PHY_CNTL0, 0xffff);
+	WRITE_LCD_REG(LVDS_PHY_CNTL1, 0xff00);
+	WRITE_LCD_REG(LVDS_PHY_CNTL4, 0x007f);
+
+	swing_level = pconf->lcd_control.lvds_config->lvds_vswing;
+	swing_level = (swing_level >= LVDS_VSWING_LEVEL_MAX) ?
+		(LVDS_VSWING_LEVEL_MAX - 1) : swing_level;
+
+	temp = 0x606cca80 | (lvds_vswing_ctrl[swing_level] << 26);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL1, temp);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
+	WRITE_LCD_CBUS_REG(HHI_DIF_CSI_PHY_CNTL3, 0x00000800);
+}
+
+static void init_dphy(Lcd_Config_t *pconf)
+{
+	unsigned lcd_type = (unsigned)(pconf->lcd_basic.lcd_type);
+
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		WRITE_LCD_CBUS_REG(HHI_DSI_LVDS_EDP_CNTL0, lcd_type);
+		init_phy_lvds(pconf);
+		break;
+	default:
+		break;
+	}
+}
+
+static void _init_lcd_driver(Lcd_Config_t *pconf)
+{
+	int lcd_type = pconf->lcd_basic.lcd_type;
+	unsigned char ss_level;
+
+	print_lcd_driver_version();
+	request_vpu_clk_vmod(pconf->lcd_timing.lcd_clk, VMODE_LCD);
+	switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_ON);
+	switch_lcd_mod_gate(ON);
+
+	ss_level = (pconf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf;
+	pr_info("Init LCD mode: %s, %s(%u) %ubit, %ux%u@%u.%uHz\n",
+	pconf->lcd_basic.model_name, lcd_type_table[lcd_type],
+	lcd_type, pconf->lcd_basic.lcd_bits, pconf->lcd_basic.h_active,
+	pconf->lcd_basic.v_active, (pconf->lcd_timing.sync_duration_num / 10),
+	(pconf->lcd_timing.sync_duration_num % 10));
+	pr_info("ss_level=%u(%s)\n", ss_level, lcd_ss_level_table[ss_level]);
+
+	set_vclk_lcd(pconf);
+	set_venc_lcd(pconf);
+	set_tcon_lcd(pconf);
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		set_control_lvds(pconf);
+		init_dphy(pconf);
+		break;
+	case LCD_DIGITAL_TTL:
+		set_control_ttl(pconf);
+		break;
+	default:
+		pr_info("Invalid LCD type.\n");
+		break;
+	}
+	pr_info("%s finished.\n", __func__);
+}
+
+static void _disable_lcd_driver(Lcd_Config_t *pconf)
+{
+	WRITE_LCD_REG_BITS(LVDS_GEN_CNTL, 0, 3, 1); /* disable lvds fifo */
+
+	WRITE_LCD_REG(ENCL_VIDEO_EN, 0); /* disable encl */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 0, 3, 1);
+	/* close vclk2 gate: 0x104b[4:0] */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0, 0, 5);
+	/* close vid2_pll gate: 0x104c[16] */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0, 16, 1);
+	/* disable vid_pll: 0x10c8[30] */
+	WRITE_LCD_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 30, 1);
+
+	switch_lcd_mod_gate(OFF);
+	switch_vpu_mem_pd_vmod(VMODE_LCD, VPU_MEM_POWER_DOWN);
+	release_vpu_clk_vmod(VMODE_LCD);
+	pr_info("disable lcd display driver.\n");
+}
+
+static void _enable_vsync_interrupt(void)
+{
+	WRITE_LCD_REG(VENC_INTCTRL, 0x200);
+}
+
+#define LCD_ENC_TST_NUM_MAX    8
+static char *lcd_enc_tst_str[] = {
+	"None",        /* 0 */
+	"Color Bar",   /* 1 */
+	"Thin Line",   /* 2 */
+	"Dot Grid",    /* 3 */
+	"Gray",        /* 4 */
+	"Red",         /* 5 */
+	"Green",       /* 6 */
+	"Blue",        /* 7 */
+};
+
+static unsigned int lcd_enc_tst[][6] = {
+/*	tst_mode,  Y,       Cb,     Cr,    tst_en, vfifo_en */
+	{0,       0x200,   0x200,  0x200,   0,      1},  /* 0 */
+	{1,       0x200,   0x200,  0x200,   1,      0},  /* 1 */
+	{2,       0x200,   0x200,  0x200,   1,      0},  /* 2 */
+	{3,       0x200,   0x200,  0x200,   1,      0},  /* 3 */
+	{0,       0x200,   0x200,  0x200,   1,      0},  /* 4 */
+	{0,       0x130,   0x153,  0x3fd,   1,      0},  /* 5 */
+	{0,       0x256,   0x0ae,  0x055,   1,      0},  /* 6 */
+	{0,       0x074,   0x3fd,  0x1ad,   1,      0},  /* 7 */
+};
+
+static void lcd_test(unsigned int num)
+{
+	num = (num >= LCD_ENC_TST_NUM_MAX) ? 0 : num;
+
+	WRITE_LCD_REG(ENCL_TST_MDSEL, lcd_enc_tst[num][0]);
+	WRITE_LCD_REG(ENCL_TST_Y, lcd_enc_tst[num][1]);
+	WRITE_LCD_REG(ENCL_TST_CB, lcd_enc_tst[num][2]);
+	WRITE_LCD_REG(ENCL_TST_CR, lcd_enc_tst[num][3]);
+	WRITE_LCD_REG(ENCL_TST_CLRBAR_STRT,
+		lcd_conf->lcd_timing.video_on_pixel);
+	WRITE_LCD_REG(ENCL_TST_CLRBAR_WIDTH,
+		(lcd_conf->lcd_basic.h_active / 9));
+	WRITE_LCD_REG(ENCL_TST_EN, lcd_enc_tst[num][4]);
+	WRITE_LCD_REG_BITS(ENCL_VIDEO_MODE_ADV, lcd_enc_tst[num][5], 3, 1);
+
+	if (num > 0) {
+		pr_info("show test pattern %d: %s\n",
+			num, lcd_enc_tst_str[num]);
+	} else
+		pr_info("disable test pattern\n");
+}
+
+static unsigned int gamma_tst_y[18] = {
+/*  Y_val    test_level   gray_level */
+	0x000,   /* 1          //0 */
+	0x072,   /* 2          //15 */
+	0x0a4,   /* 3          //30 */
+	0x0d7,   /* 4          //45 */
+	0x10b,   /* 5          //60 */
+	0x13f,   /* 6          //75 */
+	0x175,   /* 7          //90 */
+	0x1a8,   /* 8          //105 */
+	0x1dc,   /* 9          //120 */
+	0x210,   /* 10         //135 */
+	0x23f,   /* 11         //150 */
+	0x274,   /* 12         //165 */
+	0x2a8,   /* 13         //180 */
+	0x2da,   /* 14         //195 */
+	0x30e,   /* 15         //210 */
+	0x342,   /* 16         //225 */
+	0x376,   /* 17         //240 */
+	0x3aa,   /* 18         //255 */
+};
+
+static void lcd_gamma_test(unsigned int num)
+{
+	if ((num >= 1) && (num <= 18)) {
+		WRITE_LCD_REG(ENCL_TST_MDSEL, 0);
+		WRITE_LCD_REG(ENCL_TST_Y,  gamma_tst_y[num-1]);
+		WRITE_LCD_REG(ENCL_TST_CB, 0x200);
+		WRITE_LCD_REG(ENCL_TST_CR, 0x200);
+		WRITE_LCD_REG(ENCL_TST_EN, 1);
+		WRITE_LCD_REG_BITS(ENCL_VIDEO_MODE_ADV, 0, 3, 1);
+		pr_info("gamma test level: %d, gray level: %d\n",
+			num, ((num - 1) * 15));
+	} else {
+		WRITE_LCD_REG_BITS(ENCL_VIDEO_MODE_ADV, 1, 3, 1);
+		WRITE_LCD_REG(ENCL_TST_EN, 0);
+		pr_info("gamma test pattern disabled\n");
+	}
+}
+
+/* ***********************************************
+// sysfs api for video
+// *********************************************** */
+static ssize_t lcd_video_vso_read(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read vso start: %u\n",
+		lcd_conf->lcd_timing.vso_vstart);
+}
+
+static ssize_t lcd_video_vso_write(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int temp;
+
+	temp = 10;
+	ret = sscanf(buf, "%u", &temp);
+	lcd_conf->lcd_timing.vso_vstart = (unsigned short)temp;
+	lcd_conf->lcd_timing.vso_user = 1;
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_BLINE, lcd_conf->lcd_timing.vso_vstart);
+	WRITE_LCD_REG(ENCL_VIDEO_VSO_ELINE,
+		lcd_conf->lcd_timing.vso_vstart + 2);
+	pr_info("set vso start: %u\n", lcd_conf->lcd_timing.vso_vstart);
+
+	if ((ret != 1) || (ret != 2))
+		return -EINVAL;
+
+	return count;
+	/* return 0; */
+}
+
+static struct class_attribute lcd_video_class_attrs[] = {
+	__ATTR(vso,  S_IRUGO | S_IWUSR,
+		lcd_video_vso_read, lcd_video_vso_write),
+};
+
+static int creat_lcd_video_attr(Lcd_Config_t *pconf)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lcd_video_class_attrs); i++) {
+		if (class_create_file(pconf->lcd_misc_ctrl.debug_class,
+			&lcd_video_class_attrs[i])) {
+			pr_info("create lcd_video attribute %s fail\n",
+				lcd_video_class_attrs[i].attr.name);
+		}
+	}
+
+	return 0;
+}
+
+static int remove_lcd_video_attr(Lcd_Config_t *pconf)
+{
+	int i;
+
+	if (pconf->lcd_misc_ctrl.debug_class == NULL)
+		return -1;
+
+	for (i = 0; i < ARRAY_SIZE(lcd_video_class_attrs); i++) {
+		class_remove_file(pconf->lcd_misc_ctrl.debug_class,
+			&lcd_video_class_attrs[i]);
+	}
+
+	return 0;
+}
+/* *********************************************** */
+
+static DEFINE_MUTEX(lcd_init_mutex);
+static void lcd_module_enable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+
+	_init_lcd_driver(lcd_conf);
+	lcd_conf->lcd_power_ctrl.power_ctrl(ON);
+	_enable_vsync_interrupt();
+	lcd_conf->lcd_misc_ctrl.lcd_status = 1;
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static void lcd_module_disable(void)
+{
+	mutex_lock(&lcd_init_mutex);
+	lcd_conf->lcd_misc_ctrl.lcd_status = 0;
+	lcd_conf->lcd_power_ctrl.power_ctrl(OFF);
+	_disable_lcd_driver(lcd_conf);
+	mutex_unlock(&lcd_init_mutex);
+}
+
+static unsigned int clk_div_calc(unsigned int clk,
+		unsigned int div_sel, int dir)
+{
+	unsigned int clk_ret;
+
+	switch (div_sel) {
+	case CLK_DIV_SEL_1:
+		clk_ret = clk;
+		break;
+	case CLK_DIV_SEL_2:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 2;
+		else
+			clk_ret = clk * 2;
+		break;
+	case CLK_DIV_SEL_3:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 3;
+		else
+			clk_ret = clk * 3;
+		break;
+	case CLK_DIV_SEL_3p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 7;
+		else
+			clk_ret = clk * 7 / 2;
+		break;
+	case CLK_DIV_SEL_3p75:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 4 / 15;
+		else
+			clk_ret = clk * 15 / 4;
+		break;
+	case CLK_DIV_SEL_4:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 4;
+		else
+			clk_ret = clk * 4;
+		break;
+	case CLK_DIV_SEL_5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 5;
+		else
+			clk_ret = clk * 5;
+		break;
+	case CLK_DIV_SEL_6:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 6;
+		else
+			clk_ret = clk * 6;
+		break;
+	case CLK_DIV_SEL_6p25:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 4 / 25;
+		else
+			clk_ret = clk * 25 / 4;
+		break;
+	case CLK_DIV_SEL_7:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 7;
+		else
+			clk_ret = clk * 7;
+		break;
+	case CLK_DIV_SEL_7p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 15;
+		else
+			clk_ret = clk * 15 / 2;
+		break;
+	case CLK_DIV_SEL_12:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 12;
+		else
+			clk_ret = clk * 12;
+		break;
+	case CLK_DIV_SEL_14:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 14;
+		else
+			clk_ret = clk * 14;
+		break;
+	case CLK_DIV_SEL_15:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 15;
+		else
+			clk_ret = clk * 15;
+		break;
+	case CLK_DIV_SEL_2p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 5;
+		else
+			clk_ret = clk * 5 / 2;
+		break;
+	default:
+		clk_ret = clk;
+		printk("[Error]clk_div_sel:  Invalid parameter\n");
+		break;
+	}
+
+	return clk_ret;
+}
+
+struct pll_para_s {
+	unsigned int m;
+	unsigned int n;
+	unsigned int frac;
+	unsigned int od1_sel;
+	unsigned int od2_sel;
+	unsigned int od3_sel;
+};
+
+static int check_pll(struct pll_para_s *pll, unsigned int pll_fout)
+{
+	unsigned int fin, m, n;
+	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
+	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
+	unsigned int od_fb = 0, pll_frac;
+	int done;
+
+	done = 0;
+	fin = FIN_FREQ; /* kHz */
+	for (od3_sel = OD_SEL_MAX; od3_sel > 0; od3_sel--) {
+		od3 = od_table[od3_sel - 1];
+		pll_fod3_in = pll_fout * od3;
+		for (od2_sel = od3_sel; od2_sel > 0; od2_sel--) {
+			od2 = od_table[od2_sel - 1];
+			pll_fod2_in = pll_fod3_in * od2;
+			for (od1_sel = od2_sel; od1_sel > 0; od1_sel--) {
+				od1 = od_table[od1_sel - 1];
+				pll_fvco = pll_fod2_in * od1;
+				if ((pll_fvco < PLL_VCO_MIN) ||
+					(pll_fvco > PLL_VCO_MAX)) {
+					continue;
+				}
+				pll->od1_sel = od1_sel - 1;
+				pll->od2_sel = od2_sel - 1;
+				pll->od3_sel = od3_sel - 1;
+				lcd_print("od1_sel=%d, od2_sel=%d, od3_sel=%d,",
+					(od1_sel - 1), (od2_sel - 1),
+					(od3_sel - 1));
+				lcd_print(" pll_fvco=%d\n", pll_fvco);
+				n = 1;
+				od_fb = 0; /* pll default */
+				pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+				m = pll_fvco / fin;
+				pll_frac = (pll_fvco % fin) * 4096 / fin;
+				pll->m = m;
+				pll->n = n;
+				pll->frac = pll_frac;
+				lcd_print("pll_m=%d, pll_n=%d, pll_frac=%d\n",
+					m, n, pll_frac);
+				done = 1;
+			}
+		}
+	}
+	return done;
+}
+
+static void generate_clk_parameter(Lcd_Config_t *pconf)
+{
+	struct pll_para_s pll;
+	int ret = 0;
+
+	unsigned clk_div_sel, crt_xd;
+	unsigned crt_xd_max;
+	unsigned fout_pll, clk_div_out;
+	unsigned tmp;
+	unsigned fout;
+
+	fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+
+	if (fout > ENCL_MAX_CLK_IN)
+		goto generate_clk_done;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		clk_div_sel = CLK_DIV_SEL_1;//CLK_DIV_SEL_7;
+		crt_xd_max = CRT_VID_DIV_MAX;
+		crt_xd = 7;
+		clk_div_out = fout * crt_xd;
+		if (clk_div_out > CRT_VID_MAX_CLK_IN)
+			goto generate_clk_done;
+		lcd_print("fout=%d, crt_xd=%d, clk_div_out=%d\n",
+			fout, crt_xd, clk_div_out);
+		fout_pll = clk_div_calc(clk_div_out,
+				clk_div_sel, CLK_DIV_O2I);
+		if (fout_pll > CLK_DIV_MAX_CLK_IN)
+			goto generate_clk_done;
+		lcd_print("clk_div_sel=%d, fout_pll=%d\n",
+			clk_div_sel, fout_pll);
+		ret = check_pll(&pll, fout_pll);
+		if (ret)
+			goto generate_clk_done;
+		break;
+	case LCD_DIGITAL_TTL:
+		clk_div_sel = CLK_DIV_SEL_1;
+		crt_xd_max = CRT_VID_DIV_MAX;
+		for (crt_xd = 1; crt_xd <= crt_xd_max; crt_xd++) {
+			clk_div_out = fout * crt_xd;
+			if (clk_div_out > CRT_VID_MAX_CLK_IN)
+				continue;
+			lcd_print("fout=%d, crt_xd=%d, clk_div_out=%d\n",
+				fout, crt_xd, clk_div_out);
+			fout_pll = clk_div_calc(clk_div_out,
+					clk_div_sel, CLK_DIV_O2I);
+			if (fout_pll > CLK_DIV_MAX_CLK_IN)
+				continue;
+			lcd_print("clk_div_sel=%d, fout_pll=%d\n",
+				clk_div_sel, fout_pll);
+			ret = check_pll(&pll, fout_pll);
+			if (ret)
+				goto generate_clk_done;
+		}
+		break;
+	default:
+		break;
+	}
+
+generate_clk_done:
+	if (ret) {
+		pconf->lcd_timing.pll_ctrl =
+			(pll.od1_sel << PLL_CTRL_OD1) |
+			(pll.od2_sel << PLL_CTRL_OD2) |
+			(pll.od3_sel << PLL_CTRL_OD3) |
+			(pll.n << PLL_CTRL_N) |
+			(pll.m << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl = (clk_div_sel << DIV_CTRL_CLK_DIV);
+		tmp = (pconf->lcd_timing.clk_ctrl &
+			~((0xff << CLK_CTRL_XD) | (0xfff << CLK_CTRL_FRAC)));
+		pconf->lcd_timing.clk_ctrl = (tmp |
+			((crt_xd << CLK_CTRL_XD) |
+			(pll.frac << CLK_CTRL_FRAC)));
+	} else {
+		pconf->lcd_timing.pll_ctrl = (0 << PLL_CTRL_OD1) |
+			(1 << PLL_CTRL_OD2) | (1 << PLL_CTRL_OD3) |
+			(1 << PLL_CTRL_N) | (65 << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(CLK_DIV_SEL_1 << DIV_CTRL_CLK_DIV);
+		pconf->lcd_timing.clk_ctrl = (pconf->lcd_timing.clk_ctrl &
+			~(0xff << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+		pr_info("Out of clock range, reset to default setting!\n");
+	}
+}
+
+static void lcd_sync_duration(Lcd_Config_t *pconf)
+{
+	unsigned m, n, od1, od2, od3, od_fb, frac, clk_div, xd;
+	unsigned h_period, v_period, sync_duration_num, sync_duration_den;
+	unsigned pll_out_clk, lcd_clk;
+
+	m = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_M) & 0x1ff;
+	n = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_N) & 0x1f;
+	od1 = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD1) & 0x3;
+	od2 = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD2) & 0x3;
+	od3 = ((pconf->lcd_timing.pll_ctrl) >> PLL_CTRL_OD3) & 0x3;
+	od1 = od_table[od1];
+	od2 = od_table[od2];
+	od3 = od_table[od3];
+	frac = ((pconf->lcd_timing.clk_ctrl) >> CLK_CTRL_FRAC) & 0xfff;
+	od_fb = 0;
+	clk_div = ((pconf->lcd_timing.div_ctrl) >> DIV_CTRL_CLK_DIV) & 0xff;
+	xd = ((pconf->lcd_timing.clk_ctrl) >> CLK_CTRL_XD) & 0xff;
+
+	h_period = pconf->lcd_basic.h_period;
+	v_period = pconf->lcd_basic.v_period;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		xd = 1;
+		clk_div = CLK_DIV_SEL_7;
+		break;
+	case LCD_DIGITAL_TTL:
+		clk_div = CLK_DIV_SEL_1;
+		break;
+	default:
+		break;
+	}
+
+	od_fb = (od_fb + 1) * 2;
+	pll_out_clk = (frac * od_fb * FIN_FREQ) / 4096;
+	pll_out_clk = ((m * od_fb * FIN_FREQ + pll_out_clk) /
+		(n * od1 * od2 * od3));
+	lcd_clk = clk_div_calc(pll_out_clk, clk_div, CLK_DIV_I2O) / xd;
+	pconf->lcd_timing.lcd_clk = lcd_clk * 1000;
+	sync_duration_num = ((lcd_clk * 1000 / h_period) * 100) / v_period;
+	sync_duration_num = (sync_duration_num + 5) / 10;
+	sync_duration_den = 10;
+
+	pconf->lcd_timing.sync_duration_num = sync_duration_num;
+	pconf->lcd_timing.sync_duration_den = sync_duration_den;
+	pr_info("lcd_clk=%u.%03uMHz, frame_rate=%u.%uHz\n\n",
+		(lcd_clk / 1000), (lcd_clk % 1000),
+		(sync_duration_num / sync_duration_den),
+		((sync_duration_num * 10 / sync_duration_den) % 10));
+}
+
+static void lcd_tcon_config(Lcd_Config_t *pconf)
+{
+	unsigned short de_hstart, de_vstart;
+	unsigned short hstart, hend, vstart, vend;
+	unsigned short h_delay = 0;
+	unsigned short h_offset = 0, v_offset = 0, vsync_h_phase = 0;
+	unsigned short h_period, v_period, h_active, v_active;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		h_delay = LVDS_DELAY;
+		break;
+	case LCD_DIGITAL_TTL:
+		h_delay = TTL_DELAY;
+		break;
+	default:
+		h_delay = 0;
+		break;
+	}
+	h_period = pconf->lcd_basic.h_period;
+	v_period = pconf->lcd_basic.v_period;
+	h_active = pconf->lcd_basic.h_active;
+	v_active = pconf->lcd_basic.v_active;
+
+	pconf->lcd_timing.video_on_pixel = h_period - h_active - 1 - h_delay;
+	pconf->lcd_timing.video_on_line = v_period - v_active;
+
+	h_offset = (pconf->lcd_timing.h_offset & 0xffff);
+	v_offset = (pconf->lcd_timing.v_offset & 0xffff);
+	if ((pconf->lcd_timing.h_offset >> 31) & 1)
+		de_hstart = (h_period - h_active - 1 + h_period - h_offset) % h_period;
+	else
+		de_hstart = (h_period - h_active - 1 + h_offset) % h_period;
+	if ((pconf->lcd_timing.v_offset >> 31) & 1)
+		de_vstart = (v_period - v_active + v_period - v_offset) % v_period;
+	else
+		de_vstart = (v_period - v_active + v_offset) % v_period;
+
+	hstart = (de_hstart + h_period - pconf->lcd_timing.hsync_bp - pconf->lcd_timing.hsync_width) % h_period;
+	hend = (de_hstart + h_period - pconf->lcd_timing.hsync_bp) % h_period;
+	pconf->lcd_timing.hs_hs_addr = hstart;
+	pconf->lcd_timing.hs_he_addr = hend;
+	pconf->lcd_timing.hs_vs_addr = 0;
+	pconf->lcd_timing.hs_ve_addr = v_period - 1;
+
+	vsync_h_phase = (pconf->lcd_timing.vsync_h_phase & 0xffff);
+	if ((pconf->lcd_timing.vsync_h_phase >> 31) & 1) /* negative */
+		vsync_h_phase = (hstart + h_period - vsync_h_phase) % h_period;
+	else /* positive */
+		vsync_h_phase = (hstart + h_period + vsync_h_phase) % h_period;
+	pconf->lcd_timing.vs_hs_addr = vsync_h_phase;
+	pconf->lcd_timing.vs_he_addr = vsync_h_phase;
+	vstart = (de_vstart + v_period - pconf->lcd_timing.vsync_bp - pconf->lcd_timing.vsync_width) % v_period;
+	vend = (de_vstart + v_period - pconf->lcd_timing.vsync_bp) % v_period;
+	pconf->lcd_timing.vs_vs_addr = vstart;
+	pconf->lcd_timing.vs_ve_addr = vend;
+
+	pconf->lcd_timing.de_hs_addr = de_hstart;
+	pconf->lcd_timing.de_he_addr = (de_hstart + h_active) % h_period;
+	pconf->lcd_timing.de_vs_addr = de_vstart;
+	pconf->lcd_timing.de_ve_addr = (de_vstart + v_active - 1) % v_period;
+
+	if (pconf->lcd_timing.vso_user == 0) {
+		/*pconf->lcd_timing.vso_hstart = pconf->lcd_timing.vs_hs_addr;*/
+		pconf->lcd_timing.vso_vstart = pconf->lcd_timing.vs_vs_addr;
+	}
+
+	/*lcd_print("hs_hs_addr=%d, hs_he_addr=%d, ",
+		pconf->lcd_timing.hs_hs_addr, pconf->lcd_timing.hs_he_addr);
+	lcd_print("hs_vs_addr=%d, hs_ve_addr=%d\n",
+		pconf->lcd_timing.hs_vs_addr, pconf->lcd_timing.hs_ve_addr);
+	//lcd_print("vs_hs_addr=%d, vs_he_addr=%d, ",
+		pconf->lcd_timing.vs_hs_addr, pconf->lcd_timing.vs_he_addr);
+	lcd_print("vs_vs_addr=%d, vs_ve_addr=%d\n",
+		pconf->lcd_timing.vs_vs_addr, pconf->lcd_timing.vs_ve_addr);
+	//lcd_print("de_hs_addr=%d, de_he_addr=%d, ",
+		pconf->lcd_timing.de_hs_addr, pconf->lcd_timing.de_he_addr);
+	lcd_print("de_vs_addr=%d, de_ve_addr=%d\n",
+		pconf->lcd_timing.de_vs_addr, pconf->lcd_timing.de_ve_addr); */
+}
+
+static void lcd_control_config_pre(Lcd_Config_t *pconf)
+{
+	unsigned int ss_level;
+
+	/* prepare refer clock for frame_rate setting */
+	if (pconf->lcd_timing.lcd_clk < 200) {
+		pconf->lcd_timing.lcd_clk =
+			(pconf->lcd_timing.lcd_clk * pconf->lcd_basic.h_period *
+			pconf->lcd_basic.v_period);
+	}
+
+	ss_level = ((pconf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+	ss_level = ((ss_level >= SS_LEVEL_MAX) ? (SS_LEVEL_MAX - 1) : ss_level);
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		if (pconf->lcd_control.lvds_config->lvds_repack_user == 0) {
+			if (pconf->lcd_basic.lcd_bits == 6)
+				pconf->lcd_control.lvds_config->lvds_repack = 0;
+			else
+				pconf->lcd_control.lvds_config->lvds_repack = 1;
+		}
+		if (pconf->lcd_control.lvds_config->dual_port == 0) {
+			if (pconf->lcd_control.lvds_config->port_swap == 0) {
+				pconf->lcd_control.lvds_config->port_sel =
+					LVDS_PORT_A;
+			} else {
+				pconf->lcd_control.lvds_config->port_sel =
+					LVDS_PORT_B;
+			}
+		} else {
+			pconf->lcd_control.lvds_config->port_sel = LVDS_PORT_AB;
+		}
+		break;
+	default:
+		break;
+	}
+	pconf->lcd_timing.clk_ctrl = ((pconf->lcd_timing.clk_ctrl &
+		(~(0xf << CLK_CTRL_SS))) | (ss_level << CLK_CTRL_SS));
+}
+
+#ifdef CONFIG_USE_OF
+static LVDS_Config_t lcd_lvds_config = {
+	.lvds_vswing = 1,
+	.lvds_repack_user = 0,
+	.lvds_repack = 0,
+	.pn_swap = 0,
+};
+
+static TTL_Config_t lcd_ttl_config = {
+	.rb_swap = 0,
+	.bit_swap = 0,
+};
+
+static Lcd_Config_t lcd_config = {
+	.lcd_timing = {
+		.lcd_clk = 40000000,
+		.clk_ctrl = ((1 << CLK_CTRL_AUTO) | (0 << CLK_CTRL_SS)),
+		.hvsync_valid = 1,
+		.de_valid = 1,
+		.pol_ctrl = ((0 << POL_CTRL_CLK) | (1 << POL_CTRL_DE) | (0 << POL_CTRL_VS) | (0 << POL_CTRL_HS)),
+	},
+	.lcd_effect = {
+		.rgb_base_addr = 0xf0,
+		.rgb_coeff_addr = 0x74a,
+		.dith_user = 0,
+		.vadj_brightness = 0x0,
+		.vadj_contrast = 0x80,
+		.vadj_saturation = 0x100,
+		.gamma_ctrl = ((0 << GAMMA_CTRL_REVERSE) | (1 << GAMMA_CTRL_EN)),
+		.gamma_r_coeff = 100,
+		.gamma_g_coeff = 100,
+		.gamma_b_coeff = 100,
+		.set_gamma_table = set_gamma_table_lcd,
+		.gamma_test = lcd_gamma_test,
+	},
+	.lcd_control = {
+		.lvds_config = &lcd_lvds_config,
+		.ttl_config = &lcd_ttl_config,
+	},
+	.lcd_power_ctrl = {
+		.power_on_step = 0,
+		.power_off_step = 0,
+		.power_ctrl = NULL,
+	},
+};
+
+Lcd_Config_t *get_lcd_config(void)
+{
+	return &lcd_config;
+}
+#endif
+
+static void lcd_config_assign(Lcd_Config_t *pconf)
+{
+	pconf->lcd_timing.vso_hstart = 10; /* for video process */
+	pconf->lcd_timing.vso_vstart = 10; /* for video process */
+	pconf->lcd_timing.vso_user = 0; /* use default config */
+
+	pconf->lcd_power_ctrl.ports_ctrl = lcd_ports_ctrl;
+
+	pconf->lcd_misc_ctrl.vpp_sel = 0;
+	if (READ_LCD_REG(ENCL_VIDEO_EN) & 1)
+		pconf->lcd_misc_ctrl.lcd_status = 1;
+	else
+		pconf->lcd_misc_ctrl.lcd_status = 0;
+	pconf->lcd_misc_ctrl.module_enable = lcd_module_enable;
+	pconf->lcd_misc_ctrl.module_disable = lcd_module_disable;
+	pconf->lcd_misc_ctrl.lcd_test = lcd_test;
+	pconf->lcd_misc_ctrl.print_version = print_lcd_driver_version;
+}
+
+void lcd_config_init(Lcd_Config_t *pconf)
+{
+	lcd_control_config_pre(pconf);
+
+	if ((pconf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 1) {
+		pr_info("\nAuto generate clock parameters.\n");
+		generate_clk_parameter(pconf);
+	} else {
+		pr_info("\nCustome clock parameters.\n");
+	}
+	pr_info("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n",
+		pconf->lcd_timing.pll_ctrl, pconf->lcd_timing.div_ctrl,
+		pconf->lcd_timing.clk_ctrl);
+
+	lcd_sync_duration(pconf);
+	lcd_tcon_config(pconf);
+}
+
+void lcd_config_probe(Lcd_Config_t *pconf)
+{
+	spin_lock_init(&gamma_write_lock);
+	spin_lock_init(&lcd_clk_lock);
+
+	lcd_conf = pconf;
+	lcd_config_assign(pconf);
+
+	creat_lcd_video_attr(pconf);
+}
+
+void lcd_config_remove(Lcd_Config_t *pconf)
+{
+	remove_lcd_video_attr(pconf);
+}
diff --git a/arch/arm/mach-mesong9tv/lcd/lcd_config.h b/arch/arm/mach-mesong9tv/lcd/lcd_config.h
new file mode 100644
index 000000000000..bf9693159e33
--- /dev/null
+++ b/arch/arm/mach-mesong9tv/lcd/lcd_config.h
@@ -0,0 +1,240 @@
+
+#ifndef LCD_CONFIG_H
+#define LCD_CONFIG_H
+#include <linux/types.h>
+
+/* **********************************
+//lcd driver version
+// ********************************** */
+#define LCD_DRV_TYPE      "c9"
+#define LCD_DRV_DATE      "20150525"
+/* ********************************** */
+
+/* for GAMMA_CNTL_PORT */
+	#define LCD_GAMMA_VCOM_POL       7
+	#define LCD_GAMMA_RVS_OUT        6
+	#define LCD_ADR_RDY              5
+	#define LCD_WR_RDY               4
+	#define LCD_RD_RDY               3
+	#define LCD_GAMMA_TR             2
+	#define LCD_GAMMA_SET            1
+	#define LCD_GAMMA_EN             0
+
+/* for GAMMA_ADDR_PORT */
+	#define LCD_H_RD                 12
+	#define LCD_H_AUTO_INC           11
+	#define LCD_H_SEL_R              10
+	#define LCD_H_SEL_G              9
+	#define LCD_H_SEL_B              8
+	#define LCD_HADR_MSB             7
+	#define LCD_HADR                 0
+
+/* for POL_CNTL_ADDR */
+	#define LCD_DCLK_SEL             14
+	#define LCD_TCON_VSYNC_SEL_DVI   11
+	#define LCD_TCON_HSYNC_SEL_DVI   10
+	#define LCD_TCON_DE_SEL_DVI      9
+	#define LCD_CPH3_POL             8
+	#define LCD_CPH2_POL             7
+	#define LCD_CPH1_POL             6
+	#define LCD_TCON_DE_SEL          5
+	#define LCD_TCON_VS_SEL          4
+	#define LCD_TCON_HS_SEL          3
+	#define LCD_DE_POL               2
+	#define LCD_VS_POL               1
+	#define LCD_HS_POL               0
+
+/* for DITH_CNTL_ADDR */
+	#define LCD_DITH10_EN            10
+	#define LCD_DITH8_EN             9
+	#define LCD_DITH_MD              8
+	#define LCD_DITH10_CNTL_MSB      7
+	#define LCD_DITH10_CNTL          4
+	#define LCD_DITH8_CNTL_MSB       3
+	#define LCD_DITH8_CNTL           0
+
+/* for INV_CNT_ADDR */
+	#define LCD_INV_EN               4
+	#define LCD_INV_CNT_MSB          3
+	#define LCD_INV_CNT              0
+
+/* for TCON_MISC_SEL_ADDR */
+	#define LCD_STH2_SEL             12
+	#define LCD_STH1_SEL             11
+	#define LCD_OEH_SEL              10
+	#define LCD_VCOM_SEL             9
+	#define LCD_DB_LINE_SW           8
+	#define LCD_CPV2_SEL             7
+	#define LCD_CPV1_SEL             6
+	#define LCD_STV2_SEL             5
+	#define LCD_STV1_SEL             4
+	#define LCD_OEV_UNITE            3
+	#define LCD_OEV3_SEL             2
+	#define LCD_OEV2_SEL             1
+	#define LCD_OEV1_SEL             0
+
+/* for DUAL_PORT_CNTL_ADDR */
+	#define LCD_ANALOG_SEL_CPH3      8
+	#define LCD_ANALOG_3PHI_CLK_SEL  7
+	#define LCD_LVDS_SEL54           6
+	#define LCD_LVDS_SEL27           5
+	#define LCD_TTL_SEL              4
+	#define LCD_DUAL_PIXEL           3
+	#define LCD_PORT_SWP             2
+	#define LCD_RGB_SWP              1
+	#define LCD_BIT_SWP              0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LCD_LD_CNT_MSB           7
+	#define LCD_LD_CNT               5
+	#define LCD_PN_SWP               4
+	#define LCD_RES                  3
+	#define LCD_LVDS_PORT_SWP        2
+	#define LCD_PACK_RVS             1
+	#define LCD_PACK_LITTLE          0
+
+/* for LVDS_BLANK_DATA */
+	#define LVDS_BLANK_DATA_RESERVED    30
+	#define LVDS_BLANK_DATA_R           20
+	#define LVDS_BLANK_DATA_G           10
+	#define LVDS_BLANK_DATA_B           0
+
+/* for LVDS_PACK_CNTL_ADDR */
+	#define LVDS_USE_TCON               7
+	#define LVDS_DUAL                   6
+	#define PN_SWP                      5
+	#define LSB_FIRST                   4
+	#define LVDS_RESV                   3
+	#define ODD_EVEN_SWP                2
+	#define LVDS_REPACK                 0
+
+static const unsigned gamma_sel_table[3] = {
+	LCD_H_SEL_R,
+	LCD_H_SEL_G,
+	LCD_H_SEL_B,
+};
+
+/* ******************************************** */
+/* for video encoder */
+	#define LVDS_DELAY			8
+	#define TTL_DELAY			19
+
+/* ********************************************
+// for clk parameter auto generation
+// ********************************************* */
+/**** clk parameters bit ***/
+	/* pll_ctrl */
+	#define PLL_CTRL_LOCK			31
+	#define PLL_CTRL_EN			30
+	#define PLL_CTRL_RST			28
+	#define PLL_CTRL_OD2			22 /* [23:22] */
+	#define PLL_CTRL_OD3			18 /* [19:18] */
+	#define PLL_CTRL_OD1			16 /* [17:16] */
+	#define PLL_CTRL_N			9 /* [13:9] */
+	#define PLL_CTRL_M			0 /* [8:0] */
+
+	/* div_ctrl */
+	#define DIV_CTRL_CLK_DIV		0 /* [7:0] */
+
+	/* clk_ctrl */
+	#define CLK_CTRL_FRAC			16 /* [27:16] */
+
+	#define PLL_WAIT_LOCK_CNT		500
+
+/**** clk frequency limit ***/
+	/* PLL */
+	#define PLL_M_MIN			2
+	#define PLL_M_MAX			511
+	#define PLL_N_MIN			1
+	#define PLL_N_MAX			1
+	#define PLL_FREF_MIN			(5 * 1000)
+	#define PLL_FREF_MAX			(25 * 1000)
+	#define PLL_VCO_MIN			(3000 * 1000)
+	#define PLL_VCO_MAX			(6000 * 1000)
+	/* VIDEO */
+	#define CLK_DIV_MAX_CLK_IN		(3000 * 1000)
+	#define CRT_VID_MAX_CLK_IN		(3000 * 1000)
+	#define ENCL_MAX_CLK_IN			(333 * 1000)
+
+	/* lcd interface video clk */
+	#define LVDS_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+	#define TTL_MAX_VID_CLK_IN		ENCL_MAX_CLK_IN
+
+	/* clk max error */
+	#define MAX_ERROR			(2 * 1000)
+
+#define CRT_VID_DIV_MAX				255
+
+#define OD_SEL_MAX				3
+
+static unsigned od_table[4] = {1, 2, 4, 8};
+
+/* g9tv, g9bb divider */
+#define CLK_DIV_I2O     0
+#define CLK_DIV_O2I     1
+enum div_sel_e {
+	CLK_DIV_SEL_1 = 0,
+	CLK_DIV_SEL_2,    /* 1 */
+	CLK_DIV_SEL_3,    /* 2 */
+	CLK_DIV_SEL_3p5,  /* 3 */
+	CLK_DIV_SEL_3p75, /* 4 */
+	CLK_DIV_SEL_4,    /* 5 */
+	CLK_DIV_SEL_5,    /* 6 */
+	CLK_DIV_SEL_6,    /* 7 */
+	CLK_DIV_SEL_6p25, /* 8 */
+	CLK_DIV_SEL_7,    /* 9 */
+	CLK_DIV_SEL_7p5,  /* 10 */
+	CLK_DIV_SEL_12,   /* 11 */
+	CLK_DIV_SEL_14,   /* 12 */
+	CLK_DIV_SEL_15,   /* 13 */
+	CLK_DIV_SEL_2p5,  /* 14 */
+	CLK_DIV_SEL_MAX,
+};
+/* ******************************************** */
+
+/* ********************************************
+//DPHY Config
+// ******************************************** */
+/* ******** G9TV,G9BB ******** */
+/* bit[15:11] */
+#define BIT_PHY_LANE         16
+#define WIDTH_PHY_LANE       12
+
+/* LVDS */
+#define LVDS_LANE_A0          (1 << 0)
+#define LVDS_LANE_A1          (1 << 1)
+#define LVDS_LANE_A2          (1 << 2)
+#define LVDS_LANE_ACLK        (1 << 3)
+#define LVDS_LANE_A3          (1 << 4)
+#define LVDS_LANE_A4          (1 << 5)
+#define LVDS_LANE_B0          (1 << 6)
+#define LVDS_LANE_B1          (1 << 7)
+#define LVDS_LANE_B2          (1 << 8)
+#define LVDS_LANE_BCLK        (1 << 9)
+#define LVDS_LANE_B3          (1 << 10)
+#define LVDS_LANE_B4          (1 << 11)
+#define LVDS_PORT_A           (LVDS_LANE_ACLK | LVDS_LANE_A0 |\
+				LVDS_LANE_A1 | LVDS_LANE_A2 |\
+				LVDS_LANE_A3 | LVDS_LANE_A4)
+#define LVDS_PORT_B           (LVDS_LANE_BCLK | LVDS_LANE_B0 |\
+				LVDS_LANE_B1 | LVDS_LANE_B2 |\
+				LVDS_LANE_B3 | LVDS_LANE_B4)
+#define LVDS_PORT_AB          (LVDS_PORT_A | LVDS_PORT_B)
+
+/* VBYONE */
+#define VBYONE_LANE_0         (1 << 4)
+#define VBYONE_LANE_1         (1 << 3)
+#define VBYONE_LANE_2         (1 << 1)
+#define VBYONE_LANE_3         (1 << 0)
+#define VBYONE_LANE_4         (1 << 2)
+#define VBYONE_LANE_5         (1 << 3)
+#define VBYONE_LANE_6         (1 << 1)
+#define VBYONE_LANE_7         (1 << 0)
+#define VBYONE_PORT           (VBYONE_LANE_0 | VBYONE_LANE_1 |\
+				VBYONE_LANE_2 | VBYONE_LANE_3 |\
+				VBYONE_LANE_4 | VBYONE_LANE_5 |\
+				VBYONE_LANE_6 | VBYONE_LANE_7)
+
+/* ******************************************** */
+
+#endif
diff --git a/drivers/amlogic/display/lcd/aml_lcd.c b/drivers/amlogic/display/lcd/aml_lcd.c
old mode 100755
new mode 100644
index 95081e566f80..82917e8628d8
--- a/drivers/amlogic/display/lcd/aml_lcd.c
+++ b/drivers/amlogic/display/lcd/aml_lcd.c
@@ -19,7 +19,6 @@
 #include <linux/amlogic/vout/lcd.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
-#include <linux/amlogic/vout/lcd_aml.h>
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
diff --git a/drivers/amlogic/display/lcd/aml_lcd_v2.c b/drivers/amlogic/display/lcd/aml_lcd_v2.c
old mode 100755
new mode 100644
index 773f17282059..2419c6b54047
--- a/drivers/amlogic/display/lcd/aml_lcd_v2.c
+++ b/drivers/amlogic/display/lcd/aml_lcd_v2.c
@@ -19,11 +19,9 @@
 #include <linux/amlogic/vout/lcd.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
-#include <linux/amlogic/vout/lcd_aml.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <mach/am_regs.h>
-#include <mach/mlvds_regs.h>
 #include <mach/clock.h>
 #include <asm/fiq.h>
 #include <linux/delay.h>
@@ -1091,6 +1089,7 @@ static void _lcd_module_enable(void)
 static void change_panel(lcd_dev_t *pDev)
 {
 	pDev->lcd_info.name = PANEL_NAME;
+	pDev->lcd_info.mode = cur_vmode;
 	pDev->lcd_info.width = pDev->conf.lcd_basic.h_active;
 	pDev->lcd_info.height = pDev->conf.lcd_basic.v_active;
 	pDev->lcd_info.field_height = pDev->conf.lcd_basic.v_active;
@@ -1363,6 +1362,8 @@ static void lcd_output_mode_info(void)
 			cur_vmode = VMODE_4K2K_60HZ;
 		}else if(strncmp(info->name, "4k2k50hz", 8) == 0){
 			cur_vmode = VMODE_4K2K_50HZ;
+		}else if (strncmp(info->name, "panel", 5) == 0) {
+			return;
 		}else{
 			cur_vmode = VMODE_1080P;
 			printk("the output mode is not support,use default mode!\n");
@@ -1445,7 +1446,7 @@ static struct platform_driver lcd_driver = {
 	.probe = lcd_probe,
 	.remove = lcd_remove,
 	.driver = {
-		.name = "mesonlcd",
+		.name = "mesontvlcd",
 		.of_match_table = lvds_dt_match,
 	},
 #ifdef CONFIG_PM
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
old mode 100755
new mode 100644
index 5525d1f223bc..2551245dd719
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -39,7 +39,6 @@
 #include <mach/lcdoutc.h>
 #include <linux/amlogic/vout/lcdoutc.h>
 #include <linux/amlogic/vout/aml_lcd_common.h>
-#include <linux/amlogic/vout/lcd_aml.h>
 #include <mach/clock.h>
 #include <asm/fiq.h>
 #include <linux/delay.h>
@@ -87,6 +86,7 @@ static lcd_dev_t *pDev = NULL;
 static struct class *gamma_debug_class = NULL;
 #endif
 static Bool_t data_status = ON;
+static int uboot_display = 1;
 
 void lcd_print(const char *fmt, ...)
 {
@@ -149,10 +149,14 @@ static void backlight_power_ctrl(Bool_t status)
 	if( status == ON ){
 		if (data_status == OFF)
 			return;
+#ifdef CONFIG_AMLOGIC_BACKLIGHT
 		bl_power_on(LCD_BL_FLAG);
+#endif
 	}
 	else{
+#ifdef CONFIG_AMLOGIC_BACKLIGHT
 		bl_power_off(LCD_BL_FLAG);
+#endif
 	}
 	lcd_print("%s(%s): data_status=%s\n", __FUNCTION__, (status ? "ON" : "OFF"), (data_status ? "ON" : "OFF"));
 }
@@ -858,7 +862,7 @@ static Lcd_Timing_t temp_lcd_timing;
 static unsigned short temp_dith_user, temp_dith_ctrl;
 static unsigned int temp_vadj_brightness, temp_vadj_contrast, temp_vadj_saturation;
 static int temp_ttl_rb_swap, temp_ttl_bit_swap;
-static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
+static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing, temp_dual_port, temp_port_swap;
 static unsigned char temp_dsi_lane_num;
 static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
 static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis, temp_edp_edid_timing_used;
@@ -1013,8 +1017,14 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
         case LCD_DIGITAL_LVDS:
             printk("vswing_level      %u\n"
                    "lvds_repack       %u\n"
+                   "dual_port         %u\n"
+                   "port_swap         %u\n"
                    "pn_swap           %u\n\n",
-                   pConf->lcd_control.lvds_config->lvds_vswing, pConf->lcd_control.lvds_config->lvds_repack, pConf->lcd_control.lvds_config->pn_swap);
+                   pConf->lcd_control.lvds_config->lvds_vswing,
+                   pConf->lcd_control.lvds_config->lvds_repack,
+                   pConf->lcd_control.lvds_config->dual_port,
+                   pConf->lcd_control.lvds_config->port_swap,
+                   pConf->lcd_control.lvds_config->pn_swap);
             break;
         case LCD_DIGITAL_MIPI:
             printk("dsi_lane_num      %u\n"
@@ -1098,6 +1108,8 @@ static void save_lcd_config(Lcd_Config_t *pConf)
 		case LCD_DIGITAL_LVDS:
 			temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
 			temp_pn_swap = pConf->lcd_control.lvds_config->pn_swap;
+			temp_dual_port = pConf->lcd_control.lvds_config->dual_port;
+			temp_port_swap = pConf->lcd_control.lvds_config->port_swap;
 			temp_lvds_vswing = pConf->lcd_control.lvds_config->lvds_vswing;
 			break;
 		case LCD_DIGITAL_TTL:
@@ -1172,6 +1184,8 @@ static void reset_lcd_config(Lcd_Config_t *pConf)
 			pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
 			pConf->lcd_control.lvds_config->pn_swap = temp_pn_swap;
 			pConf->lcd_control.lvds_config->lvds_vswing = temp_lvds_vswing;
+			pConf->lcd_control.lvds_config->dual_port = temp_dual_port;
+			pConf->lcd_control.lvds_config->port_swap = temp_port_swap;
 			break;
 		case LCD_DIGITAL_TTL:
 			pConf->lcd_control.ttl_config->rb_swap = temp_ttl_rb_swap;
@@ -1565,19 +1579,45 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
 	unsigned int *lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*100, GFP_KERNEL);
 	int i, j;
 	struct device_node *lcd_model_node;
+#if 0
 	phandle fhandle;
-	
+#endif
+
+	if (pdev->dev.of_node == NULL) {
+		printk("no lcd node in dts\n");
+		return -1;
+	}
 	if (lcd_para == NULL) {
 		printk("[_get_lcd_model_timing]: Not enough memory\n");
 		return -1;
 	}
-	if (pdev->dev.of_node) {
-		ret = of_property_read_u32(pdev->dev.of_node,"lcd_model_config",&fhandle);
-		lcd_model_node = of_find_node_by_phandle(fhandle);
+
+	/* detect lcd model config */
+#if 0
+	ret = of_property_read_u32(pdev->dev.of_node,"lcd_model_config",&fhandle);
+	lcd_model_node = of_find_node_by_phandle(fhandle);
+#else
+	/* compatible old version */
+	ret = of_property_read_string(pdev->dev.of_node,"lcd_model_name", &str);
+	if (ret) {
+		ret = of_property_read_string(pdev->dev.of_node,"lcd_model_config", &str);
+		if (ret) {
+			printk("lcd: faild to get lcd_model_config\n");
+			return -1;
+		}
+	}
+	printk("select lcd model config: %s\n", str);
+	lcd_model_node = of_find_node_by_name(NULL,str);
+#endif
+	if (lcd_model_node == NULL) {
+		printk("can't find specified lcd model config\n");
+		return -1;
+	}
+
 		ret = of_property_read_string(lcd_model_node,"model_name", &str);
 		if(ret) {
 			str = "none";
-			printk("lcd: faild to get lcd_model_name!\n");
+			printk("lcd: faild to get lcd_model_name\n");
 		}
 		pConf->lcd_basic.model_name = (char *)kmalloc(sizeof(char)*LCD_MODEL_LEN_MAX, GFP_KERNEL);
 		if (pConf->lcd_basic.model_name == NULL) {
@@ -1586,7 +1626,7 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
 		else {
 			memset(pConf->lcd_basic.model_name, 0, LCD_MODEL_LEN_MAX);
 			strcpy(pConf->lcd_basic.model_name, str);
-			printk("load lcd model in dtb: %s\n", pConf->lcd_basic.model_name);
+			printk("load lcd model in dts: %s\n", pConf->lcd_basic.model_name);
 		}
 		
 		ret = of_property_read_string(lcd_model_node, "interface", &str);
@@ -1835,8 +1875,17 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
                 pConf->lcd_control.edp_config->max_lane_count =(unsigned char)(val);
             }
             lcd_print("max_lane_count = %d\n", pConf->lcd_control.edp_config->max_lane_count);
+        } else if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+            ret = of_property_read_u32(lcd_model_node, "dual_port", &val);
+            if (ret) {
+                printk("failed to get dual_port\n");
+                pConf->lcd_control.lvds_config->dual_port = 0;
+            } else {
+                pConf->lcd_control.lvds_config->dual_port = val;
+            }
+            lcd_print("dual_port = %d\n", pConf->lcd_control.lvds_config->dual_port);
         }
-    }
+
     kfree(lcd_para);
     return ret;
 }
@@ -1880,13 +1929,17 @@ static int _get_lcd_default_config(Lcd_Config_t *pConf, struct platform_device *
 			}
 		}
 		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
-			ret = of_property_read_u32(pdev->dev.of_node,"lvds_channel_pn_swap",&val);
-			if(ret){
-				printk("don't find to match lvds_channel_pn_swap, use default setting.\n");
-			}
-			else {
-				pConf->lcd_control.lvds_config->pn_swap = val;
-				printk("lvds_pn_swap = %u\n", pConf->lcd_control.lvds_config->pn_swap);
+			ret = of_property_read_u32_array(pdev->dev.of_node, "lvds_pn_port_swap", &lcd_para[0], 2);
+			if (ret) {
+				pConf->lcd_control.lvds_config->pn_swap = 0;
+				pConf->lcd_control.lvds_config->port_swap = 0;
+				printk("failed to get lvds_pn_port_swap, use default setting\n");
+			} else {
+				pConf->lcd_control.lvds_config->pn_swap = lcd_para[0];
+				pConf->lcd_control.lvds_config->port_swap = lcd_para[1];
+				printk("lvds pn_swap = %u, port_swap = %u\n",
+					pConf->lcd_control.lvds_config->pn_swap,
+					pConf->lcd_control.lvds_config->port_swap);
 			}
 		}
 
@@ -2363,7 +2416,13 @@ static int lcd_probe(struct platform_device *pdev)
 	save_original_gamma(pDev->pConf);
 	ret = creat_lcd_gamma_attr();
 #endif
-	
+
+	if (uboot_display == 0) {
+		_lcd_module_enable();
+		_enable_backlight();
+		uboot_display = 1;
+	}
+
 	printk("LCD probe ok\n");
 	return 0;
 }
@@ -2419,6 +2478,20 @@ static void __exit lcd_exit(void)
 subsys_initcall(lcd_init);
 module_exit(lcd_exit);
 
+int __init lcd_uboot_display_para_setup(char *s)
+{
+	lcd_print("lcd uboot display args: %s\n", s);
+	if ((!strcmp(s, "disable")) || (!strcmp(s, "0")))
+		uboot_display = 0;
+	else
+		uboot_display = 1;
+
+	printk("lcd uboot display: %d\n", uboot_display);
+
+	return 0;
+}
+__setup("uboot_display=", lcd_uboot_display_para_setup);
+
 MODULE_DESCRIPTION("Meson LCD Panel Driver");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Amlogic, Inc.");
diff --git a/include/linux/amlogic/vout/lcd.h b/include/linux/amlogic/vout/lcd.h
old mode 100755
new mode 100644
index 0d8818352a6f..427fde889cd2
--- a/include/linux/amlogic/vout/lcd.h
+++ b/include/linux/amlogic/vout/lcd.h
@@ -12,6 +12,7 @@
 
 #ifndef __AML_PANEL_LCD_H
 #define __AML_PANEL_LCD_H
+#include <plat/platform_data.h>
 
 /* for POL_CNTL_ADDR */
    #define LCD_DCLK_SEL             14    //FOR DCLK OUTPUT
@@ -262,4 +263,12 @@ typedef struct Ext_Lcd_Config_s{
 	u16 backlight_power_on_delay;
 	u16 backlight_power_off_delay;
 } Ext_Lcd_Config_t;
+
+struct aml_lcd_platform {
+	plat_data_public_t public;
+	Lcd_Config_t *lcd_conf;
+	/* local settings */
+	int lcd_status;
+};
+
 #endif /* __AML_PANEL_LCD_H */
diff --git a/include/linux/amlogic/vout/lcd_aml.h b/include/linux/amlogic/vout/lcd_aml.h
old mode 100755
new mode 100644
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
old mode 100755
new mode 100644
index f3cab2700fb6..be61b0458e2a
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -24,6 +24,7 @@
 #ifndef LCDOUTC_H
 #define LCDOUTC_H
 #include <linux/types.h>
+#include <plat/platform_data.h>
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <linux/pinctrl/consumer.h>
 
@@ -223,10 +224,13 @@ typedef struct {
 } EDP_Config_t;
 
 typedef struct {
-	unsigned lvds_vswing;
-	unsigned lvds_repack_user;
-	unsigned lvds_repack;
-	unsigned pn_swap;
+	unsigned int lvds_vswing;
+	unsigned int lvds_repack_user;
+	unsigned int lvds_repack;
+	unsigned int dual_port;
+	unsigned int port_sel; /* select port A/B for single port */
+	unsigned int pn_swap;
+	unsigned int port_swap; /* even, odd */
 } LVDS_Config_t;
 
 typedef struct {
@@ -311,6 +315,13 @@ typedef struct {
     Lcd_Misc_Ctrl_t lcd_misc_ctrl;
 } Lcd_Config_t;
 
+struct aml_lcd_platform {
+	plat_data_public_t public;
+	Lcd_Config_t *lcd_conf;
+	/* local settings */
+	int lcd_status;
+};
+
 extern Lcd_Config_t* get_lcd_config(void);
 extern void lcd_config_init(Lcd_Config_t *pConf);
 extern void lcd_config_probe(Lcd_Config_t *pConf);
-- 
2.19.0

