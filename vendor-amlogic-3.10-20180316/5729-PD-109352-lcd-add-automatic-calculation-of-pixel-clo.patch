From b5499f377e0fca21ad47a7a343e3b20c764152fd Mon Sep 17 00:00:00 2001
From: Jiaming Huang <jiaming.huang@amlogic.com>
Date: Mon, 27 Jul 2015 13:43:34 +0800
Subject: [PATCH 5729/5965] PD#109352: lcd: add automatic calculation of pixel
 clock

Change-Id: Ie95f5c2a306c25d6e0c846c4e908510ba0b14caf
---
 arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd  |   3 +
 arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd  |   4 +
 drivers/amlogic/display/lcd/aml_lcd_tv.c      | 502 +++++++++---------
 drivers/amlogic/display/lcd/aml_lcd_tv.h      |  13 +-
 .../display/lcd/aml_tv_lcd_port/lcd_common.c  | 424 ++++++++++++---
 .../display/lcd/aml_tv_lcd_port/lcd_common.h  |  85 ++-
 .../display/lcd/aml_tv_lcd_port/lvds_drv.c    | 100 ++--
 .../display/lcd/aml_tv_lcd_port/vbyone_drv.c  |  29 +-
 8 files changed, 758 insertions(+), 402 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd b/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
index 326138c3e82c..1081de278acf 100644
--- a/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
@@ -736,6 +736,7 @@
 		/* AOC: public Platform lvds : 1920x1080@60hz 8bit pixel clk@74.25mhz 2prot*/
 		lvds_0{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<148000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1920 1080 2200 1125 148 41>; /**h_active v_active h_period v_period h_blank v_blank*/
 			lcd_timing = <0x500404ad 0x00414400 0x71486980 44 2156 0 1079 2100 2164 3 5>;
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
@@ -746,6 +747,7 @@
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
 		lvds_2{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<80000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1648 810 280 42>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			lvds_att = <8 1 0 0 0 0x101>;
@@ -766,6 +768,7 @@
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
 		lvds_4{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<82000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1696 806 300 38>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			lvds_att = <8 1 0 0 0 0x101>;
diff --git a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
index a0c872771517..6b724d0ba6dd 100644
--- a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
@@ -765,6 +765,7 @@
 		/* AOC: public Platform lvds : 1920x1080@60hz 8bit pixel clk@74.25mhz 2prot*/
 		lvds_0{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<148000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1920 1080 2200 1125 148 41>; /**h_active v_active h_period v_period h_blank v_blank*/
 			lcd_timing = <0x500404ad 0x00414400 0x71486900 44 2156 0 1079 2100 2164 3 5>;
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
@@ -775,6 +776,7 @@
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
 		lvds_2{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<80000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1648 810 280 42>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			lvds_att = <8 1 0 0 0 0x101>;
@@ -785,6 +787,7 @@
 		/*BOE: HV320WHB-N80 lvds : 1366x768@60hz 8bit pixel clk@74.25mhz 1port*/
 		lvds_3{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<74250000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1560 806 190 30>;
 			lcd_timing = <0x500404ad 0x00454400 0x71486900 20 30 0 809 20 1200 3 5>;
 			lvds_att = <8 1 0 0 0 0x101>;
@@ -795,6 +798,7 @@
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
 		lvds_4{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
+			pixel_clock=<82000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1696 806 300 38>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			lvds_att = <8 1 0 0 0 0x101>;
diff --git a/drivers/amlogic/display/lcd/aml_lcd_tv.c b/drivers/amlogic/display/lcd/aml_lcd_tv.c
index ac0c7c79da0c..8f159c7ec764 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_tv.c
+++ b/drivers/amlogic/display/lcd/aml_lcd_tv.c
@@ -38,12 +38,15 @@
 
 #define PANEL_NAME		"panel"
 
-Lcd_Config_t lcd_config_dft;
-extern unsigned int lvds_init(Lcd_Config_t *pConf);
-extern unsigned int vbyone_init(Lcd_Config_t *pConf);
+extern unsigned int  lvds_init(struct aml_lcd *pDev);
+extern unsigned int vbyone_init(struct aml_lcd *pDev);
 
 extern void _disable_display_driver(void);
 
+static DEFINE_MUTEX(lcd_vout_mutex);
+
+static struct notifier_block lcd_power_nb;
+
 static char lcd_propname[30] = "lvds_0";
 
 static const char* lcd_type_table[]={
@@ -53,11 +56,13 @@ static const char* lcd_type_table[]={
 	"invalid",
 };
 
-unsigned int (*init_lcd_port[])(Lcd_Config_t *pConf) = {
+unsigned int (*init_lcd_port[])(struct aml_lcd *pDev_t) = {
 	lvds_init,
 	vbyone_init,
 };
 
+struct aml_lcd *pDev = NULL;
+
 static unsigned int lcd_output_mode = 0;
 enum {
 	LCD_OUTPUT_MODE_1080P = 0,
@@ -164,8 +169,8 @@ static const vinfo_t lcd_info[] =
 
 static int lcd_vmode_is_mached(int index)
 {
-	if ((lcd_config_dft.lcd_basic.h_active == lcd_info[index].width) &&
-		(lcd_config_dft.lcd_basic.v_active == lcd_info[index].height))
+	if ((pDev->pConf->lcd_basic.h_active == lcd_info[index].width) &&
+		(pDev->pConf->lcd_basic.v_active == lcd_info[index].height))
 		return 0;
 	else
 		return -1;
@@ -193,76 +198,6 @@ static const vinfo_t *get_valid_vinfo(char *mode)
 	return vinfo;
 }
 
-
-
-//**** Special parameters just for Vbyone ***//
-static Vbyone_Config_t lcd_vbyone_config={
-	.lane_count = 8,	//lane:  1/2/4/6/8 lanes;
-	.byte		= 4,	//byte:  3/4/5 bytes;
-	.region		= 2,	//region
-	.color_fmt	= 4,	//color_fmt
-};
-
-//**** Special parameters just for lvds ***//
-static Lvds_Config_t lcd_lvds_config={
-	.lvds_bits		= 8,	//6/8/10 bit
-	.lvds_repack	= 1,	//0->JEDIA mode,  1->VESA mode
-	.pn_swap		= 0,	//0->normal,         1->swap
-	.dual_port		= 1,	//0->single lvds,	1->double lvds
-	.port_reverse	= 1,
-	.lvds_fifo_wr_mode	= 0x3, //fifo:0x3->double,  0x101->single
-};
-
-//****panel power control only for uboot ***//
-static Panel_Power_Config_t lcd_panel_power =
-{
-	.gpio		=	GPIOH_10,		/** panel power control gpio port */
-	.on_value	=	1,				/** panel power on gpio out value*/
-	.off_value	=	0,				/** panel power off gpio out value*/
-	.panel_on_delay		=	50,		/** panel power on delay time (unit: ms)*/
-	.panel_off_delay	=	50 		/** panel power off delay time (unit: ms)*/
-};
-
-Lcd_Config_t lcd_config_dft =
-{
-	.lcd_basic = {
-		.lcd_type = LCD_DIGITAL_LVDS,	//LCD_DIGITAL_TTL /LCD_DIGITAL_LVDS/LCD_DIGITAL_VBYONE
-		.h_active = 1920,
-		.v_active = 1080,
-		.h_period = 2200,
-		.v_period = 1125,
-		.video_on_pixel = 148,
-		.video_on_line  = 41,
-		.screen_ratio_width   = 16,
-		.screen_ratio_height  = 9,
-	},
-
-	.lcd_timing = {
-		.hpll_clk = 0x500404ad,  //0x10c8 : N->bits[13:9]       M->bits[8:0]
-		.hpll_od = 0x00414400,   //0x10c9 : od1->bits[17:16]   od2->bits[23:22]   od3->bits[19:18]
-		.hdmi_pll_cntl5 = 0x71486900,
-
-		.sth1_hs_addr = 44,
-		.sth1_he_addr = 2156,
-		.sth1_vs_addr = 0,
-		.sth1_ve_addr = 1125 - 1,
-		.stv1_hs_addr = 2100,
-		.stv1_he_addr = 2164,
-		.stv1_vs_addr = 3,
-		.stv1_ve_addr = 5,
-	},
-
-	.lcd_control = {
-		.lvds_config	=	&lcd_lvds_config,
-		.vbyone_config	=	&lcd_vbyone_config,
-	},
-
-	.lcd_power_ctrl = {
-		.panel_power	=	&lcd_panel_power,
-	},
-};
-
-
 #ifdef CONFIG_USE_OF
 static inline int aml_lcd_get_property_string(struct device_node *np,
 	const char *propname, const char **out_string)
@@ -290,174 +225,250 @@ static inline int aml_lcd_get_property_array(struct device_node* of_node,
 	return ret;
 }
 
-static int _get_lcd_config(struct platform_device *pdev)
+static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 {
-	struct aml_lcd *pDev;
 	struct device_node* of_node = pdev->dev.of_node;
 	struct device_node* child;
 	const char *str;
 	unsigned int val;
+	unsigned int panel_power_pin;
 	unsigned int *lcd_para = NULL;
 
-	pDev = platform_get_drvdata(pdev);
+	struct aml_lcd_platdata *pd;
+	Lcd_Config_t *plcd_config;
+	Panel_Power_Config_t *ppanel_power_config;
 
-	lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*20, GFP_KERNEL);
+	pd = kmalloc(sizeof(struct aml_lcd_platdata), GFP_KERNEL);
+	if (pd == NULL) {
+		TV_LCD_ERR("failed to get pd Not enough memory\n");
+		return NULL;
+	}
+	memset(pd, 0, sizeof(*pd));
 
-	memset(lcd_para, 0, sizeof(*lcd_para));
+	plcd_config = kmalloc(sizeof(Lcd_Config_t), GFP_KERNEL);
+	if (plcd_config == NULL) {
+		TV_LCD_ERR("failed to get plcd_config Not enough memory\n");
+		return NULL;
+	}
+	memset(plcd_config, 0, sizeof(*plcd_config));
+	pd->pConf = plcd_config;
+
+	ppanel_power_config = kmalloc(sizeof(Panel_Power_Config_t), GFP_KERNEL);
+	if (ppanel_power_config == NULL) {
+		TV_LCD_ERR("plcd_config ppanel_power_config Not enough memory\n");
+		return NULL;
+	}
+	memset(ppanel_power_config, 0, sizeof(*ppanel_power_config));
+	pd->pConf->lcd_power_ctrl.panel_power = ppanel_power_config;
+
+	lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*20, GFP_KERNEL);
 	if (lcd_para == NULL) {
-		kfree(lcd_para);
-		TV_LCD_ERR("Not enough memory\n");
-		return -EINVAL;
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		TV_LCD_ERR("ppanel_power_config lcd_para Not enough memory\n");
+		return NULL;
 	}
+	memset(lcd_para, 0, sizeof(*lcd_para));
 
 	if (of_node) {
 		child = of_get_child_by_name(of_node,lcd_propname);
 		if (child == NULL) {
 			kfree(lcd_para);
+			kfree(pd);
+			kfree(plcd_config);
+			kfree(ppanel_power_config);
 			TV_LCD_ERR("faild to get lcd_model_config!! \n");
-			return -EINVAL;
+			return NULL;
 		}
 
-		if (!aml_lcd_get_property_string(child, "interface", &str)) {
+		if (aml_lcd_get_property_string(child, "interface", &str)) {
+			kfree(lcd_para);
+			kfree(pd);
+			kfree(plcd_config);
+			kfree(ppanel_power_config);
+			return NULL;
+		} else {
 			for (val = 0; val < LCD_TYPE_MAX; val++) {
-				if (!strcasecmp(str, lcd_type_table[val]))
-					break;
+			if (!strcasecmp(str, lcd_type_table[val]))
+				break;
 			}
-			pDev->pConf->lcd_basic.lcd_type = val;
+			plcd_config->lcd_basic.lcd_type = val;
 		}
 
-		if (!aml_lcd_get_property_array(child, "basic_setting", &lcd_para[0], 6)) {
-			pDev->pConf->lcd_basic.h_active = lcd_para[0];
-			pDev->pConf->lcd_basic.v_active = lcd_para[1];
-			pDev->pConf->lcd_basic.h_period = lcd_para[2];
-			pDev->pConf->lcd_basic.v_period = lcd_para[3];
-			pDev->pConf->lcd_basic.video_on_pixel = lcd_para[4];
-			pDev->pConf->lcd_basic.video_on_line = lcd_para[5];
+		if (aml_lcd_get_property_array(child, "basic_setting", &lcd_para[0], 6)) {
+			kfree(lcd_para);
+			kfree(pd);
+			kfree(plcd_config);
+			kfree(ppanel_power_config);
+			return NULL;
+		} else {
+			plcd_config->lcd_basic.h_active = lcd_para[0];
+			plcd_config->lcd_basic.v_active = lcd_para[1];
+			plcd_config->lcd_basic.h_period = lcd_para[2];
+			plcd_config->lcd_basic.v_period = lcd_para[3];
+			plcd_config->lcd_basic.video_on_pixel = lcd_para[4];
+			plcd_config->lcd_basic.video_on_line = lcd_para[5];
 		}
 
-		if (!aml_lcd_get_property_array(child, "lcd_timing", &lcd_para[0], 11)) {
-			pDev->pConf->lcd_timing.hpll_clk = lcd_para[0];
-			pDev->pConf->lcd_timing.hpll_od  = lcd_para[1];
-			pDev->pConf->lcd_timing.hdmi_pll_cntl5 = lcd_para[2];
-			pDev->pConf->lcd_timing.sth1_hs_addr	 = lcd_para[3];
-			pDev->pConf->lcd_timing.sth1_he_addr	 = lcd_para[4];
-			pDev->pConf->lcd_timing.sth1_vs_addr	 = lcd_para[5];
-			pDev->pConf->lcd_timing.sth1_ve_addr	 = lcd_para[6];
-			pDev->pConf->lcd_timing.stv1_hs_addr	 = lcd_para[7];
-			pDev->pConf->lcd_timing.stv1_he_addr	 = lcd_para[8];
-			pDev->pConf->lcd_timing.stv1_vs_addr	 = lcd_para[9];
-			pDev->pConf->lcd_timing.stv1_ve_addr	 = lcd_para[10];
+		if (aml_lcd_get_property_array(child, "lcd_timing", &lcd_para[0], 11)) {
+			kfree(lcd_para);
+			kfree(pd);
+			kfree(plcd_config);
+			kfree(ppanel_power_config);
+			return NULL;
+		} else {
+			plcd_config->lcd_timing.hpll_clk = lcd_para[0];
+			plcd_config->lcd_timing.hpll_od  = lcd_para[1];
+			plcd_config->lcd_timing.hdmi_pll_cntl5 = lcd_para[2];
+			plcd_config->lcd_timing.sth1_hs_addr	 = lcd_para[3];
+			plcd_config->lcd_timing.sth1_he_addr	 = lcd_para[4];
+			plcd_config->lcd_timing.sth1_vs_addr	 = lcd_para[5];
+			plcd_config->lcd_timing.sth1_ve_addr	 = lcd_para[6];
+			plcd_config->lcd_timing.stv1_hs_addr	 = lcd_para[7];
+			plcd_config->lcd_timing.stv1_he_addr	 = lcd_para[8];
+			plcd_config->lcd_timing.stv1_vs_addr	 = lcd_para[9];
+			plcd_config->lcd_timing.stv1_ve_addr	 = lcd_para[10];
 		}
 
-		if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
-			if (!aml_lcd_get_property_array(child, "lvds_att", &lcd_para[0], 6)) {
-				pDev->pConf->lcd_control.lvds_config->lvds_bits	 = lcd_para[0];
-				pDev->pConf->lcd_control.lvds_config->lvds_repack  = lcd_para[1];
-				pDev->pConf->lcd_control.lvds_config->pn_swap 	 = lcd_para[2];
-				pDev->pConf->lcd_control.lvds_config->dual_port	 = lcd_para[3];
-				pDev->pConf->lcd_control.lvds_config->port_reverse		 = lcd_para[4];
-				pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode	 = lcd_para[5];
-			}
-		} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
-			if (!aml_lcd_get_property_array(child, "vbyone_att", &lcd_para[0], 4)) {
-				pDev->pConf->lcd_control.vbyone_config->lane_count	 = lcd_para[0];
-				pDev->pConf->lcd_control.vbyone_config->byte		= lcd_para[1];
-				pDev->pConf->lcd_control.vbyone_config->region		= lcd_para[2];
-				pDev->pConf->lcd_control.vbyone_config->color_fmt 	= lcd_para[3];
+		if (aml_lcd_get_property_string(child, "panel_power_pin", &str)) {
+			kfree(lcd_para);
+			kfree(pd);
+			kfree(plcd_config);
+			kfree(ppanel_power_config);
+			return NULL;
+		} else {
+			panel_power_pin = amlogic_gpio_name_map_num(str);
+			if (panel_power_pin<0) {
+				kfree(lcd_para);
+				TV_LCD_ERR("wrong gpio number %s\n",str);
+				return NULL;
 			}
-		} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
-
+			ppanel_power_config->gpio	= panel_power_pin;
 		}
-	}
-
-	TV_LCD_INFO("lcd_type = %s(%s)\n", lcd_type_table[pDev->pConf->lcd_basic.lcd_type],lcd_propname);
-	TV_LCD_INFO("h_active = %u, v_active = %u \n", pDev->pConf->lcd_basic.h_active, pDev->pConf->lcd_basic.v_active);
-	TV_LCD_INFO("h_period = %u, v_period = %u \n", pDev->pConf->lcd_basic.h_period, pDev->pConf->lcd_basic.v_period );
-	TV_LCD_INFO("video_on_pixel = %u, video_on_line = %u \n", pDev->pConf->lcd_basic.video_on_pixel, pDev->pConf->lcd_basic.video_on_line);
-	TV_LCD_INFO("hpll_clk = %x, hpll_od =%x hdmi_pll_cntl5 = %x \n", pDev->pConf->lcd_timing.hpll_clk, pDev->pConf->lcd_timing.hpll_od, pDev->pConf->lcd_timing.hdmi_pll_cntl5);
-	TV_LCD_INFO("sth1_hs_addr = %u, sth1_he_addr = %u \n", pDev->pConf->lcd_timing.sth1_hs_addr, pDev->pConf->lcd_timing.sth1_he_addr);
-	TV_LCD_INFO("sth1_vs_addr = %u, sth1_ve_addr = %u \n", pDev->pConf->lcd_timing.sth1_vs_addr, pDev->pConf->lcd_timing.sth1_ve_addr);
-	TV_LCD_INFO("stv1_hs_addr = %u, stv1_he_addr = %u \n", pDev->pConf->lcd_timing.stv1_hs_addr, pDev->pConf->lcd_timing.stv1_he_addr);
-	TV_LCD_INFO("stv1_vs_addr = %u, stv1_ve_addr = %u \n", pDev->pConf->lcd_timing.stv1_vs_addr, pDev->pConf->lcd_timing.stv1_ve_addr);
-
-	if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
-		TV_LCD_INFO("lvds_bits = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_bits);
-		TV_LCD_INFO("lvds_repack = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_repack);
-		TV_LCD_INFO("pn_swap = %d \n",pDev->pConf->lcd_control.lvds_config->pn_swap);
-		TV_LCD_INFO("dual_port = %d \n",pDev->pConf->lcd_control.lvds_config->dual_port);
-		TV_LCD_INFO("port_reverse = %d \n",pDev->pConf->lcd_control.lvds_config->port_reverse);
-		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
-	} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
-		TV_LCD_INFO("lvds_bits = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_bits);
-		TV_LCD_INFO("lvds_repack = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_repack);
-		TV_LCD_INFO("pn_swap = %d \n",pDev->pConf->lcd_control.lvds_config->pn_swap);
-		TV_LCD_INFO("dual_port = %d \n",pDev->pConf->lcd_control.lvds_config->dual_port);
-		TV_LCD_INFO("port_reverse = %d \n",pDev->pConf->lcd_control.lvds_config->port_reverse);
-		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
-	} else if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
-
-	}
-
-	kfree(lcd_para);
-
-	return 0;
-}
 
-static int _get_lcd_power_config(struct platform_device *pdev)
-{
-	struct aml_lcd *pDev;
-	struct device_node* of_node = pdev->dev.of_node;
-	struct device_node* child;
-
-	const char *str;
-	unsigned int panel_power_pin;
-	unsigned int *lcd_para = NULL;
-
-	pDev = platform_get_drvdata(pdev);
+		if (aml_lcd_get_property_array(child, "panel_power_att", &lcd_para[0], 4)) {
+			kfree(lcd_para);
+			kfree(pd);
+			kfree(plcd_config);
+			kfree(ppanel_power_config);
+			return NULL;
+		} else {
+			ppanel_power_config->on_value  = lcd_para[0];
+			ppanel_power_config->off_value = lcd_para[1];
+			ppanel_power_config->panel_on_delay = lcd_para[2];
+			ppanel_power_config->panel_off_delay = lcd_para[3];
+		}
 
-	lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*20, GFP_KERNEL);
+		if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+			if (aml_lcd_get_property_array(child, "pixel_clock", &lcd_para[0], 1)) {
+				kfree(lcd_para);
+				kfree(pd);
+				kfree(plcd_config);
+				kfree(ppanel_power_config);
+				return NULL;
+			} else {
+				plcd_config->lcd_timing.lcd_clk = lcd_para[0];
+			}
 
-	if (lcd_para == NULL) {
-		TV_LCD_ERR("Not enough memory\n");
-		return -EINVAL;
-	}
-	memset(lcd_para, 0, sizeof(*lcd_para));
+			if (aml_lcd_get_property_array(child, "lvds_att", &lcd_para[0], 6)) {
+				kfree(lcd_para);
+				kfree(pd);
+				kfree(plcd_config);
+				kfree(ppanel_power_config);
+				return NULL;
+			}else {
+				Lvds_Config_t *plvds_config;
+				plvds_config = kmalloc(sizeof(Lvds_Config_t), GFP_KERNEL);
+				if (plvds_config == NULL) {
+					TV_LCD_ERR("pvbyone_config plvds_config Not enough memory\n");
+					kfree(lcd_para);
+					kfree(pd);
+					kfree(plcd_config);
+					kfree(ppanel_power_config);
+					return NULL;
+				}
+				memset(plvds_config, 0, sizeof(*plvds_config));
+				pd->pConf->lcd_control.lvds_config = plvds_config;
+
+				plvds_config->lvds_bits	 = lcd_para[0];
+				plvds_config->lvds_repack  = lcd_para[1];
+				plvds_config->pn_swap 	 = lcd_para[2];
+				plvds_config->dual_port	 = lcd_para[3];
+				plvds_config->port_reverse		 = lcd_para[4];
+				plvds_config->lvds_fifo_wr_mode	 = lcd_para[5];
+			}
 
-	if (of_node) {
-		child = of_get_child_by_name(of_node,lcd_propname);
-		if (child == NULL) {
-			kfree(lcd_para);
-			TV_LCD_ERR("faild to get lcd_model_config!! \n");
-			return -EINVAL;
-		}
-		if (!aml_lcd_get_property_string(child, "panel_power_pin", &str)) {
-			panel_power_pin = amlogic_gpio_name_map_num(str);
-			if (panel_power_pin<0) {
+		} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
+			if (aml_lcd_get_property_array(child, "vbyone_att", &lcd_para[0], 4)) {
 				kfree(lcd_para);
-				TV_LCD_ERR("wrong gpio number %s\n",str);
-				return -EINVAL;
+				kfree(pd);
+				kfree(plcd_config);
+				kfree(ppanel_power_config);
+				return NULL;
+			} else {
+				Vbyone_Config_t *pvbyone_config;
+				pvbyone_config = kmalloc(sizeof(Vbyone_Config_t), GFP_KERNEL);
+				if (pvbyone_config == NULL) {
+					kfree(lcd_para);
+					kfree(pd);
+					kfree(plcd_config);
+					kfree(ppanel_power_config);
+					TV_LCD_ERR("failed to get pvbyone_config Not enough memory\n");
+					return NULL;
+				}
+				memset(pvbyone_config, 0, sizeof(*pvbyone_config));
+				pd->pConf->lcd_control.vbyone_config= pvbyone_config;
+
+				pvbyone_config->lane_count	 = lcd_para[0];
+				pvbyone_config->byte		= lcd_para[1];
+				pvbyone_config->region		= lcd_para[2];
+				pvbyone_config->color_fmt 	= lcd_para[3];
 			}
-			pDev->pConf->lcd_power_ctrl.panel_power->gpio	= panel_power_pin;
-		}
+		} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
 
-		if (!aml_lcd_get_property_array(child, "panel_power_att", &lcd_para[0], 4)) {
-			pDev->pConf->lcd_power_ctrl.panel_power->on_value  = lcd_para[0];
-			pDev->pConf->lcd_power_ctrl.panel_power->off_value = lcd_para[1];
-			pDev->pConf->lcd_power_ctrl.panel_power->panel_on_delay = lcd_para[2];
-			pDev->pConf->lcd_power_ctrl.panel_power->panel_off_delay = lcd_para[3];
 		}
+	}
+
+	TV_LCD_INFO("lcd_type = %s(%s)\n", lcd_type_table[pd->pConf->lcd_basic.lcd_type],lcd_propname);
+	TV_LCD_INFO("h_active = %u, v_active = %u \n", pd->pConf->lcd_basic.h_active, pd->pConf->lcd_basic.v_active);
+	TV_LCD_INFO("h_period = %u, v_period = %u \n", pd->pConf->lcd_basic.h_period, pd->pConf->lcd_basic.v_period );
+	TV_LCD_INFO("video_on_pixel = %u, video_on_line = %u \n", pd->pConf->lcd_basic.video_on_pixel, pd->pConf->lcd_basic.video_on_line);
+	TV_LCD_INFO("hpll_clk = %x, hpll_od =%x hdmi_pll_cntl5 = %x \n", pd->pConf->lcd_timing.hpll_clk, pd->pConf->lcd_timing.hpll_od, pd->pConf->lcd_timing.hdmi_pll_cntl5);
+	TV_LCD_INFO("sth1_hs_addr = %u, sth1_he_addr = %u \n", pd->pConf->lcd_timing.sth1_hs_addr, pd->pConf->lcd_timing.sth1_he_addr);
+	TV_LCD_INFO("sth1_vs_addr = %u, sth1_ve_addr = %u \n", pd->pConf->lcd_timing.sth1_vs_addr, pd->pConf->lcd_timing.sth1_ve_addr);
+	TV_LCD_INFO("stv1_hs_addr = %u, stv1_he_addr = %u \n", pd->pConf->lcd_timing.stv1_hs_addr, pd->pConf->lcd_timing.stv1_he_addr);
+	TV_LCD_INFO("stv1_vs_addr = %u, stv1_ve_addr = %u \n", pd->pConf->lcd_timing.stv1_vs_addr, pd->pConf->lcd_timing.stv1_ve_addr);
+
+	TV_LCD_INFO("panel_power_pin: %s--%d \n",str,pd->pConf->lcd_power_ctrl.panel_power->gpio);
+	TV_LCD_INFO("on_value = %d \n",pd->pConf->lcd_power_ctrl.panel_power->on_value);
+	TV_LCD_INFO("off_value = %d \n",pd->pConf->lcd_power_ctrl.panel_power->off_value);
+	TV_LCD_INFO("panel_on_delay = %d \n",pd->pConf->lcd_power_ctrl.panel_power->panel_on_delay);
+	TV_LCD_INFO("panel_off_delay = %d \n",pd->pConf->lcd_power_ctrl.panel_power->panel_off_delay);
+
+	if (pd->pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+		TV_LCD_INFO("lvds_bits = %d \n",pd->pConf->lcd_control.lvds_config->lvds_bits);
+		TV_LCD_INFO("lvds_repack = %d \n",pd->pConf->lcd_control.lvds_config->lvds_repack);
+		TV_LCD_INFO("pn_swap = %d \n",pd->pConf->lcd_control.lvds_config->pn_swap);
+		TV_LCD_INFO("dual_port = %d \n",pd->pConf->lcd_control.lvds_config->dual_port);
+		TV_LCD_INFO("port_reverse = %d \n",pd->pConf->lcd_control.lvds_config->port_reverse);
+		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pd->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
+		TV_LCD_INFO("pixel_clock = %d \n", pd->pConf->lcd_timing.lcd_clk);
+
+	} else if (pd->pConf->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
+		TV_LCD_INFO("lvds_bits = %d \n",pd->pConf->lcd_control.lvds_config->lvds_bits);
+		TV_LCD_INFO("lvds_repack = %d \n",pd->pConf->lcd_control.lvds_config->lvds_repack);
+		TV_LCD_INFO("pn_swap = %d \n",pd->pConf->lcd_control.lvds_config->pn_swap);
+		TV_LCD_INFO("dual_port = %d \n",pd->pConf->lcd_control.lvds_config->dual_port);
+		TV_LCD_INFO("port_reverse = %d \n",pd->pConf->lcd_control.lvds_config->port_reverse);
+		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pd->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
+	} else if (pd->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
 
-		TV_LCD_INFO("panel_power_pin: %s--%d \n",str,pDev->pConf->lcd_power_ctrl.panel_power->gpio);
-		TV_LCD_INFO("on_value = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->on_value);
-		TV_LCD_INFO("off_value = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->off_value);
-		TV_LCD_INFO("panel_on_delay = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->panel_on_delay);
-		TV_LCD_INFO("panel_off_delay = %d \n",pDev->pConf->lcd_power_ctrl.panel_power->panel_off_delay);
 	}
 
 	kfree(lcd_para);
 
-return 0;
-
+	return pd;
 }
 #endif
 
@@ -465,7 +476,7 @@ static void panel_power_ctrl(Bool_t status)
 {
 	const char *owner = "aml_tv_lcd";
 	Lcd_Config_t *pConf;
-	pConf = &lcd_config_dft;
+	pConf = pDev->pConf;
 
 	TV_LCD_INFO("statu=%s gpio=%d value=%d \n",(status ? "ON" : "OFF"),
 		pConf->lcd_power_ctrl.panel_power->gpio,
@@ -485,7 +496,18 @@ static void panel_power_ctrl(Bool_t status)
 	}
 }
 
+static inline void _init_display_driver(struct aml_lcd *pDev)
+{
+	if (pDev->pConf->lcd_basic.lcd_type < LCD_TYPE_MAX) {
+		init_lcd_port[pDev->pConf->lcd_basic.lcd_type](pDev);
+	} else {
+		TV_LCD_ERR("no lcd port\n");
+		init_lcd_port[LCD_DIGITAL_LVDS](pDev);
+	}
+}
+
 /* change clock(frame_rate) for different vmode */
+#if 0
 static int lcd_vmode_change(int index)
 {
 	unsigned int pclk;
@@ -493,32 +515,23 @@ static int lcd_vmode_change(int index)
 	pclk = (lcd_config_dft.lcd_basic.h_period * lcd_config_dft.lcd_basic.v_period *
 		lcd_info[index].sync_duration_num) / lcd_info[index].sync_duration_den;
 
+	lcd_config_dft.lcd_timing.lcd_clk = pclk;
+
 	/* function to change pll & clock tree register value, to match pclk.
 	maybe we can save pclk into lcd_config, and deal that in specific lcd driver,
 	such as set_pll_lvds for lvds driver*/
 	//to do
-	return 0;
-}
 
-static inline void _init_display_driver(Lcd_Config_t *pConf_t)
-{
-	lcd_vmode_change(lcd_output_mode);
-	if (pConf_t->lcd_basic.lcd_type < LCD_TYPE_MAX) {
-		init_lcd_port[pConf_t->lcd_basic.lcd_type](pConf_t);
-	} else {
-		TV_LCD_ERR("no lcd port\n");
-		init_lcd_port[LCD_DIGITAL_LVDS](pConf_t);
-	}
+	return 0;
 }
+#endif
 
 static void _lcd_module_enable(void)
 {
-	printk("%s\n", __func__);
-	_init_display_driver(&lcd_config_dft);
+	//lcd_vmode_change(lcd_output_mode);
+	_init_display_driver(pDev);
 }
 
-static DEFINE_MUTEX(lcd_vout_mutex);
-
 static const vinfo_t *lcd_get_current_info(void)
 {
 	if (lcd_output_mode >= LCD_OUTPUT_MODE_MAX)
@@ -641,24 +654,9 @@ static vout_server_t lcd_vout_server = {
 	},
 };
 
-static void _init_vout(struct platform_device *pdev)
+static void _init_vout(struct aml_lcd *pDev)
 {
-	struct aml_lcd *pDev;
-	pDev = platform_get_drvdata(pdev);
-
-	pDev->lcd_info.name = PANEL_NAME;
-	pDev->lcd_info.mode = VMODE_LCD;
-	pDev->lcd_info.width = pDev->pConf->lcd_basic.h_active;
-	pDev->lcd_info.height = pDev->pConf->lcd_basic.v_active;
-	pDev->lcd_info.field_height = pDev->pConf->lcd_basic.v_active;
-	pDev->lcd_info.aspect_ratio_num = pDev->pConf->lcd_basic.screen_ratio_width;
-	pDev->lcd_info.aspect_ratio_den = pDev->pConf->lcd_basic.screen_ratio_height;
-	pDev->lcd_info.screen_real_width= pDev->pConf->lcd_basic.h_active_area;
-	pDev->lcd_info.screen_real_height= pDev->pConf->lcd_basic.v_active_area;
-	pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
-	pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
-
-	aml_write_reg32(P_VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
+	aml_write_reg32(P_VPP2_POSTBLEND_H_SIZE, pDev->pConf->lcd_basic.h_active);
 
 	vout_register_server(&lcd_vout_server);
 }
@@ -679,13 +677,11 @@ static int lcd_power_notifier(struct notifier_block *nb, unsigned long event, vo
 	return NOTIFY_OK;
 }
 
-
-static struct notifier_block lcd_power_nb;
-
 static int lcd_probe(struct platform_device *pdev)
 {
 	unsigned int ret = 0;
-	struct aml_lcd *pDev;
+	//struct aml_lcd *pDev;
+	struct aml_lcd_platdata *pdata;
 
 	pDev = (struct aml_lcd *)kmalloc(sizeof(struct aml_lcd), GFP_KERNEL);
 	if (!pDev) {
@@ -694,31 +690,27 @@ static int lcd_probe(struct platform_device *pdev)
 	}
 	memset(pDev, 0, sizeof(*pDev));
 
-	platform_set_drvdata(pdev, pDev);
-	pDev->pdev = pdev;
-
-	pDev->pConf = &lcd_config_dft;
-	pDev->pConf->lcd_control.lvds_config = (Lvds_Config_t *)(lcd_config_dft.lcd_control.lvds_config);
-	pDev->pConf->lcd_control.vbyone_config = (Vbyone_Config_t *)(lcd_config_dft.lcd_control.vbyone_config);
-	pDev->pConf->lcd_power_ctrl.panel_power = (Panel_Power_Config_t *)(lcd_config_dft.lcd_power_ctrl.panel_power);
+	pDev->dev = &pdev->dev;
 
-	if (_get_lcd_config(pdev)) {
+	pdata = _get_lcd_config(pdev);
+	if (pdata == NULL) {
 		kfree(pDev);
 		TV_LCD_ERR("can not find lcd dtd config \n");
 		return -ENOMEM;
 	}
-	if (_get_lcd_power_config(pdev)) {
-		kfree(pDev);
-		TV_LCD_ERR("can not find panel power dtd config \n");
-		return -ENOMEM;
-	}
+	pDev->pConf = pdata->pConf;
+	pDev->pd = pdata;
+
+	mutex_init(&pDev->init_lock);
 
 	//panel_power_ctrl(ON);
 	//udelay(50);
-	_init_vout(pdev);
+	_init_vout(pDev);
 	//lcd_set_current_vmode(VMODE_LCD);
 	//lcd_notifier_call_chain(LCD_EVENT_POWERON, NULL);
 
+	platform_set_drvdata(pdev, pDev);
+
 	lcd_power_nb.notifier_call = lcd_power_notifier;
 	ret = lcd_register_client(&lcd_power_nb);
 	if (ret) {
@@ -737,6 +729,10 @@ static int lcd_remove(struct platform_device *pdev)
 
 	lcd_unregister_client(&lcd_power_nb);
 	platform_set_drvdata(pdev, NULL);
+
+	kfree(pDev->pConf);
+	kfree(pDev->pConf->lcd_power_ctrl.panel_power);
+	kfree(pDev->pd);
 	if (pDev)
 		kfree(pDev);
 
diff --git a/drivers/amlogic/display/lcd/aml_lcd_tv.h b/drivers/amlogic/display/lcd/aml_lcd_tv.h
index dcb93b0b634c..5edc0ca39f9e 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_tv.h
+++ b/drivers/amlogic/display/lcd/aml_lcd_tv.h
@@ -116,6 +116,11 @@ typedef struct {
 	u32 hpll_od;
 	u32 hdmi_pll_cntl5;
 
+	u32 lcd_clk;		/* lcd clock = pixel clock*/
+	u32 pll_ctrl;		/* video PLL settings */
+	u32 div_ctrl;		/* video pll div settings */
+	u32 clk_ctrl;		/* video clock settings */  //[31]clk_auto, [11:8]ss_ctrl, [7:0]xd
+
     u16 sync_duration_num;
     u16 sync_duration_den;
 
@@ -181,9 +186,15 @@ typedef struct {
 struct aml_lcd {
 	Lcd_Config_t *pConf;
 	vinfo_t lcd_info;
-	struct platform_device *pdev;
+	struct aml_lcd_platdata *pd;
+
+	struct device		*dev;
+	struct mutex init_lock;
 };
 
+struct aml_lcd_platdata {
+	Lcd_Config_t *pConf;
+};
 
 
 
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
index bb5ce87d3658..d6c4ea380e92 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
@@ -1,64 +1,323 @@
 
 #include "lcd_common.h"
 
+static unsigned od_table[4] = {1, 2, 4, 8};
 
-int set_hpll_pll(int hpll_clk, int hpll_od,int hdmi_pll_cntl5)
+static int check_pll(struct pll_para_s *pll, unsigned int pll_fout)
 {
-//===============================
-//out off pll clock
-//===============================
-	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, hpll_clk);
-	aml_write_reg32(P_HHI_HDMI_PLL_CNTL2,hpll_od);
-	aml_write_reg32(P_HHI_HDMI_PLL_CNTL5,hdmi_pll_cntl5);
+	unsigned int fin, m, n;
+	unsigned int od1_sel, od2_sel, od3_sel, od1, od2, od3;
+	unsigned int pll_fod2_in, pll_fod3_in, pll_fvco;
+	unsigned int od_fb = 0;
+	unsigned int pll_frac = 0;
+	int done;
+
+	done = 0;
+	fin = FIN_FREQ; /* kHz */
+	for (od3_sel = OD_SEL_MAX; od3_sel > 0; od3_sel--) {
+		od3 = od_table[od3_sel - 1];
+		pll_fod3_in = pll_fout * od3;
+		for (od2_sel = od3_sel; od2_sel > 0; od2_sel--) {
+			od2 = od_table[od2_sel - 1];
+			pll_fod2_in = pll_fod3_in * od2;
+			for (od1_sel = od2_sel; od1_sel > 0; od1_sel--) {
+				od1 = od_table[od1_sel - 1];
+				pll_fvco = pll_fod2_in * od1;
+
+				if ((pll_fvco < PLL_VCO_MIN) ||
+					(pll_fvco > PLL_VCO_MAX)) {
+					continue;
+				}
+				pll->od1_sel = od1_sel - 1;
+				pll->od2_sel = od2_sel - 1;
+				pll->od3_sel = od3_sel - 1;
+
+				n = 1;
+				od_fb = 0; /* pll default */
+				pll_fvco = pll_fvco / ((od_fb + 1) * 2);
+
+				m = pll_fvco / fin;
+				pll_frac = (pll_fvco % fin) * 4096 / fin;
+
+				pll->m = m;
+				pll->n = n;
+				pll->frac = pll_frac;
+				printk("od1_sel=%d, od2_sel=%d, od3_sel=%d, pll_fvco=%d",
+									(od1_sel - 1), (od2_sel - 1),
+									(od3_sel - 1),	pll_fvco);
+				printk(" pll_m=%d, pll_n=%d, pll_frac=%d\n",pll->m, pll->n, pll_frac);
+				done = 1;
+			}
+		}
+	}
 
-	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, hpll_clk & (~(1<<28)));
-	//aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2,od1,18,2); //no used ,bit[18:19]
+	return done;
+}
 
-	//printf("Wait 10us for phy_clk stable!\n");
-	udelay(10); // delay 10uS to wait clock is stable
+static unsigned int clk_div_calc(unsigned int clk,unsigned int div_sel, int dir)
+{
+	unsigned int clk_ret;
+
+	switch (div_sel) {
+	case CLK_DIV_SEL_1:
+		clk_ret = clk;
+		break;
+	case CLK_DIV_SEL_2:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 2;
+		else
+			clk_ret = clk * 2;
+		break;
+	case CLK_DIV_SEL_3:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 3;
+		else
+			clk_ret = clk * 3;
+		break;
+	case CLK_DIV_SEL_3p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 7;
+		else
+			clk_ret = clk * 7 / 2;
+		break;
+	case CLK_DIV_SEL_3p75:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 4 / 15;
+		else
+			clk_ret = clk * 15 / 4;
+		break;
+	case CLK_DIV_SEL_4:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 4;
+		else
+			clk_ret = clk * 4;
+		break;
+	case CLK_DIV_SEL_5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 5;
+		else
+			clk_ret = clk * 5;
+		break;
+	case CLK_DIV_SEL_6:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 6;
+		else
+			clk_ret = clk * 6;
+		break;
+	case CLK_DIV_SEL_6p25:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 4 / 25;
+		else
+			clk_ret = clk * 25 / 4;
+		break;
+	case CLK_DIV_SEL_7:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 7;
+		else
+			clk_ret = clk * 7;
+		break;
+	case CLK_DIV_SEL_7p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 15;
+		else
+			clk_ret = clk * 15 / 2;
+		break;
+	case CLK_DIV_SEL_12:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 12;
+		else
+			clk_ret = clk * 12;
+		break;
+	case CLK_DIV_SEL_14:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 14;
+		else
+			clk_ret = clk * 14;
+		break;
+	case CLK_DIV_SEL_15:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk / 15;
+		else
+			clk_ret = clk * 15;
+		break;
+	case CLK_DIV_SEL_2p5:
+		if (dir == CLK_DIV_I2O)
+			clk_ret = clk * 2 / 5;
+		else
+			clk_ret = clk * 5 / 2;
+		break;
+	default:
+		clk_ret = clk;
+		printk("[Error]clk_div_sel:  Invalid parameter\n");
+		break;
+	}
 
-	return 0;
+	return clk_ret;
 }
 
 
-// --------------------------------------------------
-//              clocks_set_vid_clk_div
-// --------------------------------------------------
-// wire            clk_final_en    = control[19];
-// wire            clk_div1        = control[18];
-// wire    [1:0]   clk_sel         = control[17:16];
-// wire            set_preset      = control[15];
-// wire    [14:0]  shift_preset    = control[14:0];
-void lcd_clocks_set_vid_clk_div(int div_sel)
+void generate_clk_parameter(Lcd_Config_t *pconf)
 {
-	int shift_val = 0;
-	int shift_sel = 0;
+	struct pll_para_s pll;
+	int ret = 0;
+	unsigned clk_div_sel, crt_xd;
+	unsigned crt_xd_max;
+	unsigned fout_pll, clk_div_out;
+	unsigned tmp;
+	unsigned fout;
+
+	pll.frac = 0;
+	pll.m = 0;
+	pll.n = 0;
+	pll.od1_sel = 0;
+	pll.od2_sel = 0;
+	pll.od3_sel = 0;
+
+	fout = pconf->lcd_timing.lcd_clk / 1000; /* kHz */
+
+	if (fout > ENCL_MAX_CLK_IN)
+		goto generate_clk_done;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		clk_div_sel = CLK_DIV_SEL_7; // CLK_DIV_SEL_1; 0
+		crt_xd_max = CRT_VID_DIV_MAX; //255
+		crt_xd = 1;
+		clk_div_out = fout * crt_xd;
+		if (clk_div_out > CRT_VID_MAX_CLK_IN)
+			goto generate_clk_done;
+
+		fout_pll = clk_div_calc(clk_div_out,clk_div_sel, CLK_DIV_O2I);
+		if (fout_pll > CLK_DIV_MAX_CLK_IN)
+			goto generate_clk_done;
+
+		ret = check_pll(&pll, fout_pll);
+printk("fout_pll=%d , clk_div_sel=%d clk_div_out=%d\n", fout_pll,clk_div_sel,clk_div_out);
+printk("od1_sel=%x od2_sel=%x od3_sel=%x n=%x m=%x  \n",
+		pll.od1_sel,pll.od2_sel,pll.od3_sel,pll.n,pll.m);
+
+		if (ret)
+			goto generate_clk_done;
+		break;
+
+	default:
+		break;
+	}
+
+generate_clk_done:
+	if (ret) {
+		pconf->lcd_timing.pll_ctrl =
+			(pll.od1_sel << PLL_CTRL_OD1) |
+			(pll.od2_sel << PLL_CTRL_OD2) |
+			(pll.od3_sel << PLL_CTRL_OD3) |
+			(pll.n << PLL_CTRL_N) |
+			(pll.m << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl = (clk_div_sel << DIV_CTRL_CLK_DIV);
+		tmp = (pconf->lcd_timing.clk_ctrl &
+			~((0xff << CLK_CTRL_XD) | (0xfff << CLK_CTRL_FRAC)));
+		pconf->lcd_timing.clk_ctrl = (tmp |
+			((crt_xd << CLK_CTRL_XD) |
+			(pll.frac << CLK_CTRL_FRAC)));
+
+		printk("pll_ctrl=%x div_ctrl=%x clk_ctrl=%x \n",
+			pconf->lcd_timing.pll_ctrl, pconf->lcd_timing.div_ctrl,pconf->lcd_timing.clk_ctrl);
 
-	TV_LCD_INFO("div = %d\n", div_sel);
-	// Disable the output clock
+	} else {
+		pconf->lcd_timing.pll_ctrl = (0 << PLL_CTRL_OD1) |
+			(1 << PLL_CTRL_OD2) | (1 << PLL_CTRL_OD3) |
+			(1 << PLL_CTRL_N) | (65 << PLL_CTRL_M);
+		pconf->lcd_timing.div_ctrl =
+			(CLK_DIV_SEL_1 << DIV_CTRL_CLK_DIV);
+		pconf->lcd_timing.clk_ctrl = (pconf->lcd_timing.clk_ctrl &
+			~(0xff << CLK_CTRL_XD)) | (7 << CLK_CTRL_XD);
+		printk("Out of clock range, reset to default setting!\n");
+	}
+}
+
+static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
+{
+	unsigned m, n, od1, od2, od3, frac;
+	int wait_loop = PLL_WAIT_LOCK_CNT;
+	unsigned pll_lock = 0;
+	unsigned pll_ctrl, pll_ctrl2;
+
+	m = (pll_reg >> PLL_CTRL_M) & 0x1ff;
+	n = (pll_reg >> PLL_CTRL_N) & 0x1f;
+	od1 = (pll_reg >> PLL_CTRL_OD1) & 0x3;
+	od2 = (pll_reg >> PLL_CTRL_OD2) & 0x3;
+	od3 = (pll_reg >> PLL_CTRL_OD3) & 0x3;
+	frac = (clk_ctrl_reg >> CLK_CTRL_FRAC) & 0xfff;
+
+	pll_ctrl = ((1 << 30) | (n << 9) | (m << 0));
+	pll_ctrl2 = ((od1 << 16) | (od2 << 22) | (od3 << 18));
+	if (frac > 0)
+		pll_ctrl2 |= ((1 << 14) | (frac << 0));
+
+	printk("pll_ctrl : %x \n",pll_ctrl | (1 << 28));
+	printk("pll_ctrl2 : %x \n",pll_ctrl2);
+
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, pll_ctrl | (1 << 28));
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL2, pll_ctrl2);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL5, 0x71486900);     //special
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL6, 0x00000a55);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, pll_ctrl);
+	do {
+		udelay(50);
+		pll_lock = (aml_read_reg32(P_HHI_HDMI_PLL_CNTL) >> 31) & 0x1;
+		wait_loop--;
+	} while ((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		printk("[error]: hpll lock failed\n");
+}
+
+
+static unsigned int lcd_clk_div_table[][3] = {
+	/* divider,        shift_val,  shift_sel */
+	{CLK_DIV_SEL_1,    0xffff,     0,},
+	{CLK_DIV_SEL_2,    0x0aaa,     0,},
+	{CLK_DIV_SEL_3,    0x0db6,     0,},
+	{CLK_DIV_SEL_3p5,  0x36cc,     1,},
+	{CLK_DIV_SEL_3p75, 0x6666,     2,},
+	{CLK_DIV_SEL_4,    0x0ccc,     0,},
+	{CLK_DIV_SEL_5,    0x739c,     2,},
+	{CLK_DIV_SEL_6,    0x0e38,     0,},
+	{CLK_DIV_SEL_6p25, 0x0000,     3,},
+	{CLK_DIV_SEL_7,    0x3c78,     1,},
+	{CLK_DIV_SEL_7p5,  0x78f0,     2,},
+	{CLK_DIV_SEL_12,   0x0fc0,     0,},
+	{CLK_DIV_SEL_14,   0x3f80,     1,},
+	{CLK_DIV_SEL_15,   0x7f80,     2,},
+	{CLK_DIV_SEL_2p5,  0x5294,     2,},
+	{CLK_DIV_SEL_MAX,  0xffff,     0,},
+};
+
+void lcd_set_clk_div(unsigned long vid_div_reg)
+{
+	unsigned int  clk_div;
+	unsigned int shift_val, shift_sel;
+	int i;
+
+	clk_div = (vid_div_reg >> DIV_CTRL_CLK_DIV) & 0xf;
+
+	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 19, 1);
+	udelay(5);
+
+	/* Disable the div output clock */
 	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 19, 1);
 	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
 
-	switch (div_sel) {
-		case CLK_UTIL_VID_PLL_DIV_1:      shift_val = 0xFFFF; shift_sel = 0; break;
-		case CLK_UTIL_VID_PLL_DIV_2:      shift_val = 0x0aaa; shift_sel = 0; break;
-		case CLK_UTIL_VID_PLL_DIV_3:      shift_val = 0x0db6; shift_sel = 0; break;
-		case CLK_UTIL_VID_PLL_DIV_3p5:    shift_val = 0x36cc; shift_sel = 1; break;
-		case CLK_UTIL_VID_PLL_DIV_3p75:   shift_val = 0x6666; shift_sel = 2; break;
-		case CLK_UTIL_VID_PLL_DIV_4:      shift_val = 0x0ccc; shift_sel = 0; break;
-		case CLK_UTIL_VID_PLL_DIV_5:      shift_val = 0x739c; shift_sel = 2; break;
-		case CLK_UTIL_VID_PLL_DIV_6:      shift_val = 0x0e38; shift_sel = 0; break;
-		case CLK_UTIL_VID_PLL_DIV_6p25:   shift_val = 0x0000; shift_sel = 3; break;
-		case CLK_UTIL_VID_PLL_DIV_7:      shift_val = 0x3c78; shift_sel = 1; break;
-		case CLK_UTIL_VID_PLL_DIV_7p5:    shift_val = 0x78f0; shift_sel = 2; break;
-		case CLK_UTIL_VID_PLL_DIV_12:     shift_val = 0x0fc0; shift_sel = 0; break;
-		case CLK_UTIL_VID_PLL_DIV_14:     shift_val = 0x3f80; shift_sel = 1; break;
-		case CLK_UTIL_VID_PLL_DIV_15:     shift_val = 0x7f80; shift_sel = 2; break;
-		case CLK_UTIL_VID_PLL_DIV_2p5:    shift_val = 0x5294; shift_sel = 2; break;
-		default:
-		TV_LCD_ERR("clocks_set_vid_clk_div:  Invalid parameter\n");
-		break;
+	i = 0;
+	while (lcd_clk_div_table[i][0] != CLK_DIV_SEL_MAX) {
+		if (clk_div == lcd_clk_div_table[i][0])
+			break;
+		i++;
 	}
+	if (lcd_clk_div_table[i][0] == CLK_DIV_SEL_MAX)
+		printk("invalid clk divider\n");
+	shift_val = lcd_clk_div_table[i][1];
+	shift_sel = lcd_clk_div_table[i][2];
 
 	if (shift_val == 0xffff ) {      // if divide by 1
 		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 18, 1);
@@ -72,45 +331,66 @@ void lcd_clocks_set_vid_clk_div(int div_sel)
 		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
 		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
 	}
-	// Enable the final output clock
+	/* Enable the final output clock */
 	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 19, 1);
 }
 
-void lcd_set_crt_video_enc(int vIdx, int inSel, int DivN)
+static void lcd_set_vclk_crt(unsigned int clk_ctrl_reg)
 {
-	if (vIdx == 0) //V1
-	{
-		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
-		udelay(2);
-		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, inSel,   16, 3); // [18:16] - cntl_clk_in_sel
-		aml_set_reg32_bits(P_HHI_VID_CLK_DIV, (DivN-1), 0, 8); // [7:0]   - cntl_xd0
-		udelay(5);
-		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);//[19] -enable clk_div0
-	} else { //V2
-		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
-		udelay(2);
-		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, inSel,  16, 3); // [18:16] - cntl_clk_in_sel
-		aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, (DivN-1),0, 8); // [7:0]   - cntl_xd0
-		udelay(5);
-		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
-	}
+	unsigned int xd;
+	printk("%s\n", __func__);
+
+	xd = (clk_ctrl_reg >> CLK_CTRL_XD) & 0xff;
+	/* setup the XD divider value */
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, (xd-1), 0, 8);
+	udelay(5);
+	/* Bit[18:16] - v2_cntl_clk_in_sel */
+	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 16, 3);
+	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 19, 1);
+	udelay(2);
+
+	/* [15:12] encl_clk_sel, select vclk2_div1 */
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, 8, 12, 4);
+	/* release vclk2_div_reset and enable vclk2_div */
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, 1, 16, 2);
 	udelay(5);
+
+	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 0, 1);
+	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 15, 1);
+	udelay(10);
+	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 15, 1);
+	udelay(5);
+
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2, 1, 3, 1);
 }
 
-void lcd_enable_crt_video_encl(int enable, int inSel)
+void set_vclk_lcd(Lcd_Config_t *pconf)
 {
-	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV,inSel,  12, 4); //encl_clk_sel:hi_viid_clk_div[15:12]
+	unsigned pll_reg, div_reg, clk_reg;
+	int xd;
+	int lcd_type;
 
-	if (inSel <= 4) //V1
-		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL,1, inSel, 1);
-	else
-		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL,1, (inSel-5),1);
+	pll_reg = pconf->lcd_timing.pll_ctrl;
+	div_reg = pconf->lcd_timing.div_ctrl;
+	clk_reg = pconf->lcd_timing.clk_ctrl;
+	xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
+
+	lcd_type = pconf->lcd_basic.lcd_type;
+
+	switch (lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		xd = 1;
+		break;
+	default:
+		break;
+	}
 
-	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2,enable, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
+	clk_reg = (pconf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) |
+		(xd << CLK_CTRL_XD);
 
-#ifndef NO_EDP_DSI
-	aml_set_reg32_bits(P_VPU_MISC_CTRL, 1, 0, 1);    // vencl_clk_en_force: vpu_misc_ctrl[0]
-#endif
+	lcd_set_pll(pll_reg, clk_reg);
+	lcd_set_clk_div(div_reg);
+	lcd_set_vclk_crt(clk_reg);
 }
 
 void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode)
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
index 719e01b1b8e4..8d6d43cf4e2e 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
@@ -14,7 +14,7 @@
 #include "../aml_lcd_tv.h"
 
 #define VPP_OUT_SATURATE            (1 << 0)
-
+/*
 #define CLK_UTIL_VID_PLL_DIV_1      0
 #define CLK_UTIL_VID_PLL_DIV_2      1
 #define CLK_UTIL_VID_PLL_DIV_3      2
@@ -30,6 +30,84 @@
 #define CLK_UTIL_VID_PLL_DIV_14     12
 #define CLK_UTIL_VID_PLL_DIV_15     13
 #define CLK_UTIL_VID_PLL_DIV_2p5    14
+*/
+
+#define CRT_VID_DIV_MAX				255
+#define CRT_VID_MAX_CLK_IN		(3000 * 1000)
+
+
+
+/* g9tv, g9bb divider */
+#define CLK_DIV_I2O     0
+#define CLK_DIV_O2I     1
+
+struct pll_para_s {
+	unsigned int m;
+	unsigned int n;
+	unsigned int frac;
+	unsigned int od1_sel;
+	unsigned int od2_sel;
+	unsigned int od3_sel;
+};
+
+enum div_sel_e {
+	CLK_DIV_SEL_1 = 0,
+	CLK_DIV_SEL_2,    /* 1 */
+	CLK_DIV_SEL_3,    /* 2 */
+	CLK_DIV_SEL_3p5,  /* 3 */
+	CLK_DIV_SEL_3p75, /* 4 */
+	CLK_DIV_SEL_4,    /* 5 */
+	CLK_DIV_SEL_5,    /* 6 */
+	CLK_DIV_SEL_6,    /* 7 */
+	CLK_DIV_SEL_6p25, /* 8 */
+	CLK_DIV_SEL_7,    /* 9 */
+	CLK_DIV_SEL_7p5,  /* 10 */
+	CLK_DIV_SEL_12,   /* 11 */
+	CLK_DIV_SEL_14,   /* 12 */
+	CLK_DIV_SEL_15,   /* 13 */
+	CLK_DIV_SEL_2p5,  /* 14 */
+	CLK_DIV_SEL_MAX,
+};
+
+
+/* ********************************************
+// for clk parameter auto generation
+// ********************************************* */
+/**** clk parameters bit ***/
+	/* pll_ctrl */
+	#define PLL_CTRL_LOCK			31
+	#define PLL_CTRL_EN			30
+	#define PLL_CTRL_RST			28
+	#define PLL_CTRL_OD2			22 /* [23:22] */
+	#define PLL_CTRL_OD3			18 /* [19:18] */
+	#define PLL_CTRL_OD1			16 /* [17:16] */
+	#define PLL_CTRL_N			9 /* [13:9] */
+	#define PLL_CTRL_M			0 /* [8:0] */
+
+	/* div_ctrl */
+#define DIV_CTRL_CLK_DIV		0 /* [7:0] */
+
+/* clk_ctrl */
+#define CLK_CTRL_FRAC			16 /* [27:16] */
+
+#define PLL_WAIT_LOCK_CNT		500
+
+
+#define FIN_FREQ				 (24 * 1000)
+#define OD_SEL_MAX				3
+#define CLK_CTRL_XD 			  0  //[7:0]
+
+
+#define PLL_VCO_MIN 		(3000 * 1000)
+#define PLL_VCO_MAX 		(6000 * 1000)
+
+/* VIDEO */
+#define CLK_DIV_MAX_CLK_IN		(3000 * 1000)
+#define CRT_VID_MAX_CLK_IN		(3000 * 1000)
+#define ENCL_MAX_CLK_IN 		(333 * 1000)
+
+
+
 
 
 void lcd_clocks_set_vid_clk_div(int div_sel);
@@ -39,4 +117,9 @@ void lcd_enable_crt_video_encl(int enable, int inSel);
 void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode);
  void _enable_vsync_interrupt(void);
 
+void generate_clk_parameter(Lcd_Config_t *pconf);
+void set_vclk_lcd(Lcd_Config_t *pconf);
+void lcd_set_clk_div(unsigned long vid_div_reg);
+
+
 #endif
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
index a115ae2c136f..04a9d0af3aff 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
@@ -18,12 +18,16 @@ static void set_tcon_lvds(Lcd_Config_t *pConf)
 	aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
 }
 
-static void init_lvds_phy(Lcd_Config_t *pConf)
+static void init_phy_lvds(Lcd_Config_t *pConf)
 {
 	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
 	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
 	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
 
+	aml_write_reg32(P_LVDS_PHY_CNTL0, 0xffff);
+	aml_write_reg32(P_LVDS_PHY_CNTL1, 0xff00);
+	aml_write_reg32(P_LVDS_PHY_CNTL4, 0x007f);
+
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
@@ -76,14 +80,17 @@ static void set_control_lvds(Lcd_Config_t *pConf)
 					( 2<<14 ));			//b_select  //0:R, 1:G, 2:B, 3:0;
 }
 
-static void venc_set_lvds(Lcd_Config_t *pConf)
+static void set_venc_lvds(Lcd_Config_t *pConf)
 {
-//	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0)|(0<<2));     // viu1 select encl  | viu2 select encl
 	aml_write_reg32(P_ENCL_VIDEO_EN, 0);
-	//int havon_begin = 80;
-	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0)|(0<<2) );    // viu1 select encl | viu2 select encl
-	aml_write_reg32(P_ENCL_VIDEO_MODE, 0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
-	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV, 0x0418); // Sampling rate: 1
+
+	//aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0)|(0<<2) );    // viu1 select encl | viu2 select encl
+	//aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 0, 2, 2);// viu2 select encl
+	//aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 0, 0, 2);// viu1 select encl
+	aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 0, 0, 4);// viu1, viu2 select encl
+
+	aml_write_reg32(P_ENCL_VIDEO_MODE, 		0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV, 	0x0418); // Sampling rate: 1
 
 	// bypass filter
 	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL, 	0x1000);
@@ -106,38 +113,23 @@ static void venc_set_lvds(Lcd_Config_t *pConf)
 	aml_write_reg32(P_ENCL_VIDEO_EN, 1);
 }
 
-//new lvd_vx1_phy config
-static void lvds_phy_config(int lvds_vx1_sel)
+static void set_pll_lvds(Lcd_Config_t *pConf)
 {
-	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
-	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
-	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+	unsigned int sw_port 	= (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0x100;
+	unsigned int lvds_fifo = (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0xff;
+	unsigned int vx1_phy_div;
+	unsigned int lvds_ports ;
 
-	if (lvds_vx1_sel == 0) { //lvds
-		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
-		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
-		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
-		//od   clk 1039.5 / 2 = 519.75 = 74.25*7
-		aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
-	}
-}
-
-static void vclk_set_encl_lvds(int lvds_ports, int hpll_clk, int hpll_od,int hdmi_pll_cntl5)
-{
-	//int hdmi_clk_out;
-	int vx1_phy_div;
-	int encl_div;
-	unsigned int xd;
+	generate_clk_parameter(pConf);
+	//printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n",
+	//	pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl,
+	//	pConf->lcd_timing.clk_ctrl);
+	set_vclk_lcd(pConf);
 
+	lvds_ports = pConf->lcd_control.lvds_config->dual_port;
 	if (lvds_ports < 2) {
-		TV_LCD_INFO("lvds clk: hpll_clk=%x hpll_od%x \n",hpll_clk,hpll_od);
-		if (set_hpll_pll(hpll_clk, hpll_od,hdmi_pll_cntl5)) {
-			TV_LCD_ERR("Unsupported hpll_pll out frequency!\n");
-			return;
-		}
 		vx1_phy_div  = 2/2;
-		encl_div	 = vx1_phy_div*7;
-
+		//encl_div	 = vx1_phy_div*7;
 		if (lvds_ports == 1) //dual port
 			vx1_phy_div = vx1_phy_div*2;
 	}else if (lvds_ports >= 2) {
@@ -145,32 +137,8 @@ static void vclk_set_encl_lvds(int lvds_ports, int hpll_clk, int hpll_od,int hdm
 		return;
 	}
 
-	//configure vid_clk_div_top
-	if ((encl_div%14) == 0) {//7*even
-		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_14);
-		xd = encl_div/14;
-	}else if ((encl_div%7) == 0) { //7*odd
-		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7);
-		xd = encl_div/7;
-	}else{ //3.5*odd
-		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p5);
-		xd = encl_div/3.5;
-	}
-	//for lvds phy clock and enable decoupling FIFO
 	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((vx1_phy_div-1)<<1)|1)<<24);
 
-	//config lvds phy
-	lvds_phy_config(0);
-	//configure crt_video
-	lcd_set_crt_video_enc(0,0,xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
-	lcd_enable_crt_video_encl(1,0); //select and enable the output
-}
-
-static void set_pll_lvds(Lcd_Config_t *pConf)
-{
-	unsigned int sw_port 	= (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0x100;
-	unsigned int lvds_fifo = (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0xff;
-	vclk_set_encl_lvds(pConf->lcd_control.lvds_config->dual_port, pConf->lcd_timing.hpll_clk, pConf->lcd_timing.hpll_od,pConf->lcd_timing.hdmi_pll_cntl5);
 	if ( sw_port == 0x100 )
 		aml_write_reg32( P_HHI_VIID_DIVIDER_CNTL, ((aml_read_reg32(P_HHI_VIID_DIVIDER_CNTL) & ~(0x7 << 8)) | (1 << 8) | (0<<10)));
 	else
@@ -178,15 +146,19 @@ static void set_pll_lvds(Lcd_Config_t *pConf)
 	aml_write_reg32(P_LVDS_GEN_CNTL, (aml_read_reg32(P_LVDS_GEN_CNTL)| (1 << 3) | (lvds_fifo << 0)));
 }
 
-unsigned int  lvds_init(Lcd_Config_t *pConf)
+
+unsigned int  lvds_init(struct aml_lcd *pDev)
 {
 	TV_LCD_INFO("lcd: lvds mode is selected!\n");
-	set_pll_lvds(pConf);
-	venc_set_lvds(pConf);
-	set_control_lvds(pConf);
-	init_lvds_phy(pConf);
-	set_tcon_lvds(pConf);
+
+	mutex_lock(&pDev->init_lock);
+	set_pll_lvds(pDev->pConf);
+	set_venc_lvds(pDev->pConf);
+	set_tcon_lvds(pDev->pConf);
+	set_control_lvds(pDev->pConf);
+	init_phy_lvds(pDev->pConf);
 	_enable_vsync_interrupt();
+	mutex_unlock(&pDev->init_lock);
 
 	return 0;
 }
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
index 3a7cb4f78689..d9e0c9a17bfa 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
@@ -343,17 +343,22 @@ static void set_pll_vbyone(Lcd_Config_t *pConf)
    //configure vid_clk_div_top
    if (byte == 3) {
 	   if (pclk_div == 375) {
-		   lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p75);
+		   //lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p75);
+		   lcd_set_clk_div(CLK_DIV_SEL_3p75 << 0);
 		   xd = 1;
 	   } else if (pclk_div == 750) {
-		   lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7p5);
+		   //lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7p5);
+		   lcd_set_clk_div(CLK_DIV_SEL_7p5 <<0) ;
+
 		   xd = 1;
 	   } else {
-		   lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_15);
+		   //lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_15);
+		   lcd_set_clk_div(CLK_DIV_SEL_15 <<0 );
 		   xd = pclk_div/100/15;
 	   }
 	} else if (byte == 4) {
-		lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_5);
+		//lcd_clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_5);
+		lcd_set_clk_div(CLK_DIV_SEL_5<<0);
 		xd = pclk_div/100/5;
 	}
 
@@ -390,17 +395,19 @@ static void set_pll_vbyone(Lcd_Config_t *pConf)
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2, 1, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
 }
 
-unsigned int vbyone_init(Lcd_Config_t *pConf)
+unsigned int vbyone_init(struct aml_lcd *pDev)
 {
 	TV_LCD_INFO("lcd: vx1 mode is selected!\n");
-	set_pll_vbyone(pConf);
-	venc_set_vbyone(pConf);
-	set_control_vbyone(pConf);
-	init_vbyone_phy(pConf);
-	set_tcon_vbyone(pConf);
-	set_vbyone_pinmux();
 
+	mutex_lock(&pDev->init_lock);
+	set_pll_vbyone(pDev->pConf);
+	venc_set_vbyone(pDev->pConf);
+	set_control_vbyone(pDev->pConf);
+	init_vbyone_phy(pDev->pConf);
+	set_tcon_vbyone(pDev->pConf);
+	set_vbyone_pinmux();
 	_enable_vsync_interrupt();
+	mutex_unlock(&pDev->init_lock);
 
 	return 0;
 }
-- 
2.19.0

