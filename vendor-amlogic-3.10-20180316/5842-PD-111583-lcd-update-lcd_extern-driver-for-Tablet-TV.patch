From 60ce917486d4d11078158769ad0af1796734bf77 Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Fri, 18 Sep 2015 11:34:28 +0800
Subject: [PATCH 5842/5965] PD#111583: lcd: update lcd_extern driver for
 Tablet/TV compatibility

Change-Id: Ibd188795858b7a349d2a7e718c42835ecd3d570f
---
 arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd  |  71 +-
 arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd  |  71 +-
 arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd  |  76 +-
 .../arm/boot/dts/amlogic/meson8_k101_512M.dtd |  70 +-
 arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd  |  69 +-
 arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd  |  69 +-
 arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd  |  71 +-
 arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd |   2 -
 arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd |   2 -
 .../arm/boot/dts/amlogic/meson8m2_n100_1G.dtd |  70 +-
 .../boot/dts/amlogic/meson8m2_n101_512M.dtd   |  87 +--
 arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd  |  20 +
 arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd  |  22 +-
 arch/arm/configs/meson6_defconfig             |   4 +
 arch/arm/configs/meson8_defconfig             |   6 +
 arch/arm/configs/meson8b_defconfig            |   6 +
 arch/arm/configs/mesong9bb_defconfig          |   7 +
 arch/arm/configs/mesong9tv_defconfig          |   7 +
 arch/arm/mach-meson6/lcd/lcd_config.h         |   2 +-
 arch/arm/mach-meson8/lcd/lcd_config.c         |   1 -
 arch/arm/mach-meson8/lcd/mipi_dsi_util.c      |  54 +-
 arch/arm/mach-meson8b/lcd/lcd_config.c        |   1 -
 arch/arm/mach-meson8b/lcd/mipi_dsi_util.c     |  54 +-
 arch/arm/mach-mesong9bb/lcd/lcd_config.h      |   2 +-
 arch/arm/mach-mesong9tv/lcd/lcd_config.h      |   2 +-
 drivers/amlogic/display/lcd/Kconfig           |   2 +
 drivers/amlogic/display/lcd/Makefile          |   1 +
 .../display/lcd/aml_lcd_extern/Kconfig        |  49 ++
 .../display/lcd/aml_lcd_extern/Makefile       |  10 +
 .../display/lcd/aml_lcd_extern/aml.dtd        |  60 ++
 .../display/lcd/aml_lcd_extern/i2c_T5800Q.c   | 326 +++++++++
 .../display/lcd/aml_lcd_extern/i2c_anx6345.c  | 540 ++++++++++++++
 .../display/lcd/aml_lcd_extern/i2c_anx6345.h  | 666 ++++++++++++++++++
 .../display/lcd/aml_lcd_extern/i2c_tc101.c    | 244 +++++++
 .../display/lcd/aml_lcd_extern/lcd_extern.c   | 495 +++++++++++++
 .../display/lcd/aml_lcd_extern/lcd_extern.h   |  49 ++
 .../lcd/aml_lcd_extern/mipi_KD080D13.c        | 111 +++
 .../display/lcd/aml_lcd_extern/mipi_N070ICN.c | 234 ++++++
 .../display/lcd/aml_lcd_extern/spi_LD070WS2.c | 209 ++++++
 drivers/amlogic/display/lcd/aml_lcd_tv.c      | 330 ++++++++-
 drivers/amlogic/display/lcd/aml_lcd_tv.h      |  23 +-
 drivers/amlogic/display/vout/Makefile         |   1 -
 drivers/amlogic/display/vout/aml_lcd.dtd      |  65 +-
 drivers/amlogic/display/vout/lcdoutc.c        |  77 +-
 include/linux/amlogic/vout/aml_lcd_extern.h   |  31 +-
 include/linux/amlogic/vout/lcdoutc.h          |   3 +-
 46 files changed, 3862 insertions(+), 510 deletions(-)
 mode change 100755 => 100644 arch/arm/configs/mesong9tv_defconfig
 mode change 100755 => 100644 arch/arm/mach-meson6/lcd/lcd_config.h
 mode change 100755 => 100644 arch/arm/mach-meson8/lcd/lcd_config.c
 mode change 100755 => 100644 arch/arm/mach-meson8/lcd/mipi_dsi_util.c
 mode change 100755 => 100644 arch/arm/mach-meson8b/lcd/lcd_config.c
 mode change 100755 => 100644 arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/Kconfig
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/Makefile
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/aml.dtd
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/i2c_T5800Q.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.h
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/i2c_tc101.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.h
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/mipi_KD080D13.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/mipi_N070ICN.c
 create mode 100644 drivers/amlogic/display/lcd/aml_lcd_extern/spi_LD070WS2.c
 mode change 100755 => 100644 drivers/amlogic/display/vout/aml_lcd.dtd
 mode change 100755 => 100644 include/linux/amlogic/vout/aml_lcd_extern.h

diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
index 47f8659b5040..d0d8308c577d 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_1G.dtd
@@ -1194,7 +1194,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 //	lcd_B080XAN01:lcd_B080XAN01{	//k101
 //		model_name="B080XAN01";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1221,6 +1220,7 @@ sdio{
 //					0x05 1 0x10   //sleep in
 //					0xff 10       //delay 10ms
 //					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+//		lcd_extern_index=<0xff>; /** lcd extern index(0xff=invalid, assigned by user) */
 //	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
@@ -1303,49 +1303,36 @@ sdio{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
index 0923e702e81a..8e42639c01ab 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k100_2G.dtd
@@ -1184,7 +1184,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 //	lcd_B080XAN01:lcd_B080XAN01{	//k101
 //		model_name="B080XAN01";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1211,6 +1210,7 @@ sdio{
 //					0x05 1 0x10   //sleep in
 //					0xff 10       //delay 10ms
 //					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+//		lcd_extern_index=<0xff>; /** lcd extern index(0xff=invalid, assigned by user) */
 //	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
@@ -1293,49 +1293,36 @@ sdio{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
index c98e88cd0d70..60c57dbe1e3c 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_1G.dtd
@@ -1125,7 +1125,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
 		model_name="B080XAN01";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1155,7 +1154,7 @@ sdio{
 					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		lcd_extern_init=<0>;/** lcd extern init command control(0=disable, 1=enable) */
+		lcd_extern_index=<0xff>; /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_LD070WX4>
@@ -1177,7 +1176,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 42 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 //lcd_LD070WX4:lcd_LD070WX4{
 //		model_name="LD070WX4";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1217,7 +1215,6 @@ sdio{
 //				0x05 1 0x10   //sleep in
 //				0xff 10       //delay 10ms
 //				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		lcd_extern_init=<0>;  /** lcd extern init command control(0=disable, 1=enable) */
 //	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
@@ -1316,7 +1313,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 //	lcd_CLAA101FP05XG:lcd_CLAA101FP05XG{
 //		model_name="CLAA101FP05XG";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1346,54 +1342,40 @@ sdio{
 //				0x05 1 0x10   //sleep in
 //				0xff 10       //delay 10ms
 //				0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-//		lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
 //	};
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
index 5d38df707b71..60ae10a5adfb 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k101_512M.dtd
@@ -1149,6 +1149,7 @@ sdio{
 					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+		lcd_extern_index=<0xff>; /** lcd extern index(0xff=invalid, assigned by user) */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
@@ -1278,49 +1279,36 @@ sdio{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
index 6529ad360755..f0d349dc850e 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k102_v1.dtd
@@ -1384,49 +1384,36 @@ lcd_LD070WX4:lcd_LD070WX4{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
index 28db51a92d2a..32a29636c203 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k150_v1.dtd
@@ -1347,49 +1347,36 @@ lcd_LD070WX4:lcd_LD070WX4{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
index c4c6084008f6..ecfe68429514 100644
--- a/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8_k160_v1.dtd
@@ -1156,6 +1156,7 @@ sdio{
 //$$ L2 PROP_U32 = "dsi_bit_rate_max"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
+//$$ L2 PROP_U32 = "lcd_extern_index"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
 		model_name="B080XAN01";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1182,6 +1183,7 @@ sdio{
 					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+		lcd_extern_index=<0xff>; /** lcd extern index(0xff=invalid, assigned by user) */
 	};
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_LD070WX4>
@@ -1367,49 +1369,36 @@ lcd_LD070WX4:lcd_LD070WX4{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd
index 8f2ac697849d..6b0b7e2d9d02 100644
--- a/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m100_1G.dtd
@@ -1205,7 +1205,6 @@ void root_func(){
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
 		model_name="B080XAN01";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1235,7 +1234,6 @@ void root_func(){
 					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		lcd_extern_init=<0>;/** lcd extern init command control(0=disable, 1=enable) */
     };
 
 //******************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
index b322e2976cb1..d792e7b43dba 100644
--- a/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8b_m102_1G.dtd
@@ -1155,7 +1155,6 @@ void root_func(){
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
 		model_name="B080XAN01";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1185,7 +1184,6 @@ void root_func(){
 					0x05 1 0x10   //sleep in
 					0xff 10       //delay 10ms
 					0xff 0xff>;/** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-		lcd_extern_init=<0>;/** lcd extern init command control(0=disable, 1=enable) */
     };
 
 //******************************************************************************
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
index 8f19abc00b31..7d64141f73bf 100644
--- a/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n100_1G.dtd
@@ -1185,7 +1185,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 //	lcd_B080XAN01:lcd_B080XAN01{	//k101
 //		model_name="B080XAN01";	/** lcd model name */
 //		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1294,49 +1293,36 @@ sdio{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
index a1dee6e4e61a..67be85653a5d 100644
--- a/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n101_512M.dtd
@@ -1120,7 +1120,6 @@ sdio{
 //$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
 //$$ L2 PROP_U32 12 = "dsi_init_on"
 //$$ L2 PROP_U32 12 = "dsi_init_off"
-//$$ L2 PROP_U32 = "lcd_extern_init"
 	lcd_B080XAN01:lcd_B080XAN01{	//k101
 		model_name="B080XAN01";	/** lcd model name */
 		interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -1276,49 +1275,53 @@ sdio{
 
 //******************************************************************************
 //lcd extern
-//Notice: only one dev support
 //******************************************************************************
-//$$ DEVICE = "lcd_extern_i2c_tc101"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_STR = "i2c_bus"
-	lcd_extern_i2c_tc101{
-		compatible = "amlogic,lcd_i2c_tc101";
-		dev_name ="lcd_i2c_tc101";
-		status = "disabled";
-
-		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		i2c_address = <0x7e>; /** i2c address */
-		i2c_bus = "i2c_bus_a";
-	};
-
-//$$ DEVICE = "lcd_extern_spi_LD070WS2"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-//$$ L2 PROP_U32 = "gpio_spi_cs"
-//$$ L2 PROP_U32 = "gpio_spi_clk"
-//$$ L2 PROP_U32 = "gpio_spi_data"
-	lcd_extern_spi_LD070WS2{
-		compatible = "amlogic,lcd_spi_LD070WS2";
-		dev_name ="lcd_spi_LD070WS2";
-		status = "disabled";
-
-		type = <1>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-		gpio_spi_cs="GPIODV_1";
-		gpio_spi_clk="GPIODV_16";
-		gpio_spi_data="GPIODV_17";
-	};
-
-//$$ DEVICE = "lcd_extern_mipi_N070ICN"
-//$$ L2 PROP_STR = "status"
-//$$ L2 PROP_U32 = "type"
-	lcd_extern_mipi_N070ICN{
-		compatible = "amlogic,lcd_mipi_N070ICN";
-		dev_name ="lcd_mipi_N070ICN";
-		status = "disabled";
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
 
-		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
-	};
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "i2c_anx6345";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x38>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_b";
+			lane_num = <1>; /** edp lane_num:1/2/4 */
+			bits = <0>;  /** bits of lcd(0: 6bit, 1: 8bit) */
+			link_rate = <1>; /** edp link rate (0: 1.62G, 1: 27G, 2: 5.4G) */
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_3{
+			index = <3>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+		extern_4{
+			index = <4>;
+			extern_name = "mipi_KD080D13";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
 
 /// ***************************************************************************************
 ///     -       Sensors
diff --git a/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd b/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
index 776c526301ae..3c050320df04 100644
--- a/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
@@ -743,6 +743,7 @@
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
@@ -755,6 +756,7 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*BOE: HV320WHB-N80 lvds : 1366x768@60hz 8bit pixel clk@74.25mhz 1port*/
@@ -766,6 +768,7 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
@@ -778,6 +781,7 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*BOE: HV550QU2-305 vx1 : 3840x2160@60hz 8lane pixel clk@74.5mhz */
@@ -789,6 +793,22 @@
 			vbyone_att = <8 4 2 4>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
+		};
+	};
+
+	lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
+
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_T5800Q";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_d";
 		};
 	};
 
diff --git a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
index 1f241068edf3..1ad02a1d3016 100644
--- a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
@@ -1024,6 +1024,7 @@
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
@@ -1036,6 +1037,7 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*BOE: HV320WHB-N80 lvds : 1366x768@60hz 8bit pixel clk@74.25mhz 1port*/
@@ -1048,6 +1050,7 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
@@ -1060,6 +1063,7 @@
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
 		};
 
 		/*BOE: HV550QU2-305 vx1 : 3840x2160@60hz 8lane pixel clk@74.5mhz */
@@ -1070,7 +1074,23 @@
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
 			vbyone_att = <8 4 2 4>;
 			panel_power_pin ="GPIOH_10";
-			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
+			panel_power_att = <1 0 50 50>; /** on off on_delay off_delay*/
+			lcd_extern_att = <0xff 30 0>; /** index(0xff=invalid) on_delay off_delay */
+		};
+	};
+
+	lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
+
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_T5800Q";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_d";
 		};
 	};
 
diff --git a/arch/arm/configs/meson6_defconfig b/arch/arm/configs/meson6_defconfig
index 1f70367d17a5..41989a662b07 100644
--- a/arch/arm/configs/meson6_defconfig
+++ b/arch/arm/configs/meson6_defconfig
@@ -232,6 +232,10 @@ CONFIG_AML_TVOUT=y
 CONFIG_AML_VDAC_HW_SWITCH=y
 CONFIG_AML_LCD_TABLET=y
 CONFIG_AML_GAMMA_DEBUG=y
+CONFIG_AML_LCD_EXTERN=y
+CONFIG_AML_LCD_EXTERN_I2C_TC101=y
+CONFIG_AML_LCD_EXTERN_I2C_ANX6345=y
+CONFIG_AML_LCD_EXTERN_SPI_LD070WS2=y
 CONFIG_AMLOGIC_VOUT2=y
 CONFIG_AML_TVOUT2=y
 CONFIG_FB_AM=y
diff --git a/arch/arm/configs/meson8_defconfig b/arch/arm/configs/meson8_defconfig
index 474bf2853473..2fae9f081140 100644
--- a/arch/arm/configs/meson8_defconfig
+++ b/arch/arm/configs/meson8_defconfig
@@ -254,6 +254,12 @@ CONFIG_AML_TVOUT=y
 CONFIG_AML_VOUT_FRAMERATE_AUTOMATION=y
 CONFIG_AML_LCD_TABLET=y
 CONFIG_AML_GAMMA_DEBUG=y
+CONFIG_AML_LCD_EXTERN=y
+CONFIG_AML_LCD_EXTERN_I2C_TC101=y
+CONFIG_AML_LCD_EXTERN_I2C_ANX6345=y
+CONFIG_AML_LCD_EXTERN_SPI_LD070WS2=y
+CONFIG_AML_LCD_EXTERN_MIPI_N070ICN=y
+CONFIG_AML_LCD_EXTERN_MIPI_KD080D13=y
 CONFIG_AMLOGIC_VOUT2=y
 CONFIG_AML_TVOUT2=y
 CONFIG_FB_AM=y
diff --git a/arch/arm/configs/meson8b_defconfig b/arch/arm/configs/meson8b_defconfig
index 88f45237e1a2..6d528f9f9f8a 100644
--- a/arch/arm/configs/meson8b_defconfig
+++ b/arch/arm/configs/meson8b_defconfig
@@ -250,6 +250,12 @@ CONFIG_AML_TVOUT=y
 CONFIG_AML_VOUT_FRAMERATE_AUTOMATION=y
 CONFIG_AML_LCD_TABLET=y
 CONFIG_AML_GAMMA_DEBUG=y
+CONFIG_AML_LCD_EXTERN=y
+CONFIG_AML_LCD_EXTERN_I2C_TC101=y
+CONFIG_AML_LCD_EXTERN_I2C_ANX6345=y
+CONFIG_AML_LCD_EXTERN_SPI_LD070WS2=y
+CONFIG_AML_LCD_EXTERN_MIPI_N070ICN=y
+CONFIG_AML_LCD_EXTERN_MIPI_KD080D13=y
 CONFIG_FB_AM=y
 CONFIG_FB_OSD2_CURSOR=y
 CONFIG_FB_OSD2_DEFAULT_WIDTH=32
diff --git a/arch/arm/configs/mesong9bb_defconfig b/arch/arm/configs/mesong9bb_defconfig
index 74150a66d935..39937128958a 100644
--- a/arch/arm/configs/mesong9bb_defconfig
+++ b/arch/arm/configs/mesong9bb_defconfig
@@ -199,6 +199,13 @@ CONFIG_AML_LCD_TABLET=y
 CONFIG_AML_GAMMA_DEBUG=y
 CONFIG_AMLOGIC_LCD=y
 CONFIG_AML_LCD_TV=y
+CONFIG_AML_LCD_EXTERN=y
+CONFIG_AML_LCD_EXTERN_I2C_T5800Q=y
+CONFIG_AML_LCD_EXTERN_I2C_TC101=y
+CONFIG_AML_LCD_EXTERN_I2C_ANX6345=y
+CONFIG_AML_LCD_EXTERN_SPI_LD070WS2=y
+CONFIG_AML_LCD_EXTERN_MIPI_N070ICN=y
+CONFIG_AML_LCD_EXTERN_MIPI_KD080D13=y
 CONFIG_FB_AM=y
 CONFIG_FB_OSD1_DEFAULT_BITS_PER_PIXEL=32
 CONFIG_FB_OSD1_DEFAULT_WIDTH=1920
diff --git a/arch/arm/configs/mesong9tv_defconfig b/arch/arm/configs/mesong9tv_defconfig
old mode 100755
new mode 100644
index 3848d1a3e1ee..f0c3bfc6bfa3
--- a/arch/arm/configs/mesong9tv_defconfig
+++ b/arch/arm/configs/mesong9tv_defconfig
@@ -198,6 +198,13 @@ CONFIG_AML_LCD_TABLET=y
 CONFIG_AML_GAMMA_DEBUG=y
 CONFIG_AMLOGIC_LCD=y
 CONFIG_AML_LCD_TV=y
+CONFIG_AML_LCD_EXTERN=y
+CONFIG_AML_LCD_EXTERN_I2C_T5800Q=y
+CONFIG_AML_LCD_EXTERN_I2C_TC101=y
+CONFIG_AML_LCD_EXTERN_I2C_ANX6345=y
+CONFIG_AML_LCD_EXTERN_SPI_LD070WS2=y
+CONFIG_AML_LCD_EXTERN_MIPI_N070ICN=y
+CONFIG_AML_LCD_EXTERN_MIPI_KD080D13=y
 CONFIG_FB_AM=y
 CONFIG_FB_OSD1_DEFAULT_BITS_PER_PIXEL=32
 CONFIG_FB_OSD1_DEFAULT_WIDTH=1920
diff --git a/arch/arm/mach-meson6/lcd/lcd_config.h b/arch/arm/mach-meson6/lcd/lcd_config.h
old mode 100755
new mode 100644
index ede15d5eeac7..b4b74fd112fa
--- a/arch/arm/mach-meson6/lcd/lcd_config.h
+++ b/arch/arm/mach-meson6/lcd/lcd_config.h
@@ -8,7 +8,7 @@
 //lcd driver version
 //**********************************
 #define LCD_DRV_TYPE      "c6"
-#define LCD_DRV_DATE      "20150126"
+#define LCD_DRV_DATE      "20150915"
 //**********************************
 
 /* for GAMMA_CNTL_PORT */
diff --git a/arch/arm/mach-meson8/lcd/lcd_config.c b/arch/arm/mach-meson8/lcd/lcd_config.c
old mode 100755
new mode 100644
index f1fc1c93e7e8..ca892b1c3673
--- a/arch/arm/mach-meson8/lcd/lcd_config.c
+++ b/arch/arm/mach-meson8/lcd/lcd_config.c
@@ -1810,7 +1810,6 @@ static DSI_Config_t lcd_mipi_config = {
     .transfer_ctrl = 0,
     .dsi_init_on = &dsi_init_on_table[0],
     .dsi_init_off = &dsi_init_off_table[0],
-    .lcd_extern_init = 0,
 };
 
 static EDP_Config_t lcd_edp_config = {
diff --git a/arch/arm/mach-meson8/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
old mode 100755
new mode 100644
index 8ad00950a3e3..8c4a94ff83b6
--- a/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8/lcd/mipi_dsi_util.c
@@ -11,7 +11,9 @@
 #include <mach/mipi_dsi_reg.h>
 #include <mach/lcdoutc.h>
 #include <linux/amlogic/vout/lcdoutc.h>
+#ifdef CONFIG_AML_LCD_EXTERN
 #include <linux/amlogic/vout/aml_lcd_extern.h>
+#endif
 #include "lcd_config.h"
 #include "mipi_dsi_util.h"
 
@@ -171,7 +173,7 @@ static void print_info(void)
             i += n;
         }
     }
-    DPRINT("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
+    //DPRINT("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
     DPRINT("================================================\n");
 }
 
@@ -1160,25 +1162,30 @@ static void mipi_dsi_host_config(Lcd_Config_t *pConf)
 void mipi_dsi_link_on(Lcd_Config_t *pConf)
 {
     unsigned int      operation_mode_disp, operation_mode_init;
-    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#ifdef CONFIG_AML_LCD_EXTERN
+    struct aml_lcd_extern_driver_t *ext_drv;
+    int index;
+#endif
     unsigned int init_flag = 0;
 
     DPRINT("%s\n", __FUNCTION__);
     operation_mode_disp = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
     operation_mode_init = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
 
-    if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
-        lcd_extern_driver = aml_lcd_extern_get_driver();
-        if (lcd_extern_driver == NULL) {
-            DPRINT("no lcd_extern driver\n");
-        }
-        else {
-            if (lcd_extern_driver->init_on_cmd_8) {
-                init_flag += dsi_write_cmd(lcd_extern_driver->init_on_cmd_8);
-                DPRINT("[extern]%s dsi init on\n", lcd_extern_driver->name);
+#ifdef CONFIG_AML_LCD_EXTERN
+    index = pConf->lcd_control.extern_index;
+    if (index < LCD_EXTERN_INDEX_INVALID) {
+        ext_drv = aml_lcd_extern_get_driver(index);
+        if (ext_drv == NULL) {
+            lcd_print("no lcd_extern driver for mipi-dsi\n");
+        } else {
+            if (ext_drv->init_on_cmd_8) {
+                init_flag += dsi_write_cmd(ext_drv->init_on_cmd_8);
+                DPRINT("[extern]%s dsi init on\n", ext_drv->config.name);
             }
         }
     }
+#endif
 
     if (pConf->lcd_control.mipi_config->dsi_init_on) {
         init_flag += dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_on);
@@ -1200,25 +1207,30 @@ void mipi_dsi_link_on(Lcd_Config_t *pConf)
 
 void mipi_dsi_link_off(Lcd_Config_t *pConf)
 {
-    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#ifdef CONFIG_AML_LCD_EXTERN
+    struct aml_lcd_extern_driver_t *ext_drv;
+    int index;
+#endif
 
     if (pConf->lcd_control.mipi_config->dsi_init_off) {
         dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_off);
         lcd_print("dsi init off\n");
     }
 
-    if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
-        lcd_extern_driver = aml_lcd_extern_get_driver();
-        if (lcd_extern_driver == NULL) {
-            DPRINT("no lcd_extern driver\n");
-        }
-        else {
-            if (lcd_extern_driver->init_off_cmd_8) {
-                dsi_write_cmd(lcd_extern_driver->init_off_cmd_8);
-                DPRINT("[extern]%s dsi init off\n", lcd_extern_driver->name);
+#ifdef CONFIG_AML_LCD_EXTERN
+    index = pConf->lcd_control.extern_index;
+    if (index < LCD_EXTERN_INDEX_INVALID) {
+        ext_drv = aml_lcd_extern_get_driver(index);
+        if (ext_drv == NULL) {
+            lcd_print("no lcd_extern driver for mipi-dsi\n");
+        } else {
+            if (ext_drv->init_off_cmd_8) {
+                dsi_write_cmd(ext_drv->init_off_cmd_8);
+                DPRINT("[extern]%s dsi init off\n", ext_drv->config.name);
             }
         }
     }
+#endif
 }
 
 void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
diff --git a/arch/arm/mach-meson8b/lcd/lcd_config.c b/arch/arm/mach-meson8b/lcd/lcd_config.c
old mode 100755
new mode 100644
index 63e5e4a5384b..c08d23782caf
--- a/arch/arm/mach-meson8b/lcd/lcd_config.c
+++ b/arch/arm/mach-meson8b/lcd/lcd_config.c
@@ -1390,7 +1390,6 @@ static DSI_Config_t lcd_mipi_config = {
     .transfer_ctrl = 0,
     .dsi_init_on = &dsi_init_on_table[0],
     .dsi_init_off = &dsi_init_off_table[0],
-    .lcd_extern_init = 0,
 };
 
 static LVDS_Config_t lcd_lvds_config = {
diff --git a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
old mode 100755
new mode 100644
index 8ad00950a3e3..8c4a94ff83b6
--- a/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
+++ b/arch/arm/mach-meson8b/lcd/mipi_dsi_util.c
@@ -11,7 +11,9 @@
 #include <mach/mipi_dsi_reg.h>
 #include <mach/lcdoutc.h>
 #include <linux/amlogic/vout/lcdoutc.h>
+#ifdef CONFIG_AML_LCD_EXTERN
 #include <linux/amlogic/vout/aml_lcd_extern.h>
+#endif
 #include "lcd_config.h"
 #include "mipi_dsi_util.h"
 
@@ -171,7 +173,7 @@ static void print_info(void)
             i += n;
         }
     }
-    DPRINT("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
+    //DPRINT("DSI INIT EXTERN:        %d\n", dsi_config->lcd_extern_init);
     DPRINT("================================================\n");
 }
 
@@ -1160,25 +1162,30 @@ static void mipi_dsi_host_config(Lcd_Config_t *pConf)
 void mipi_dsi_link_on(Lcd_Config_t *pConf)
 {
     unsigned int      operation_mode_disp, operation_mode_init;
-    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#ifdef CONFIG_AML_LCD_EXTERN
+    struct aml_lcd_extern_driver_t *ext_drv;
+    int index;
+#endif
     unsigned int init_flag = 0;
 
     DPRINT("%s\n", __FUNCTION__);
     operation_mode_disp = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
     operation_mode_init = ((pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1);
 
-    if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
-        lcd_extern_driver = aml_lcd_extern_get_driver();
-        if (lcd_extern_driver == NULL) {
-            DPRINT("no lcd_extern driver\n");
-        }
-        else {
-            if (lcd_extern_driver->init_on_cmd_8) {
-                init_flag += dsi_write_cmd(lcd_extern_driver->init_on_cmd_8);
-                DPRINT("[extern]%s dsi init on\n", lcd_extern_driver->name);
+#ifdef CONFIG_AML_LCD_EXTERN
+    index = pConf->lcd_control.extern_index;
+    if (index < LCD_EXTERN_INDEX_INVALID) {
+        ext_drv = aml_lcd_extern_get_driver(index);
+        if (ext_drv == NULL) {
+            lcd_print("no lcd_extern driver for mipi-dsi\n");
+        } else {
+            if (ext_drv->init_on_cmd_8) {
+                init_flag += dsi_write_cmd(ext_drv->init_on_cmd_8);
+                DPRINT("[extern]%s dsi init on\n", ext_drv->config.name);
             }
         }
     }
+#endif
 
     if (pConf->lcd_control.mipi_config->dsi_init_on) {
         init_flag += dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_on);
@@ -1200,25 +1207,30 @@ void mipi_dsi_link_on(Lcd_Config_t *pConf)
 
 void mipi_dsi_link_off(Lcd_Config_t *pConf)
 {
-    struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#ifdef CONFIG_AML_LCD_EXTERN
+    struct aml_lcd_extern_driver_t *ext_drv;
+    int index;
+#endif
 
     if (pConf->lcd_control.mipi_config->dsi_init_off) {
         dsi_write_cmd(pConf->lcd_control.mipi_config->dsi_init_off);
         lcd_print("dsi init off\n");
     }
 
-    if (pConf->lcd_control.mipi_config->lcd_extern_init > 0) {
-        lcd_extern_driver = aml_lcd_extern_get_driver();
-        if (lcd_extern_driver == NULL) {
-            DPRINT("no lcd_extern driver\n");
-        }
-        else {
-            if (lcd_extern_driver->init_off_cmd_8) {
-                dsi_write_cmd(lcd_extern_driver->init_off_cmd_8);
-                DPRINT("[extern]%s dsi init off\n", lcd_extern_driver->name);
+#ifdef CONFIG_AML_LCD_EXTERN
+    index = pConf->lcd_control.extern_index;
+    if (index < LCD_EXTERN_INDEX_INVALID) {
+        ext_drv = aml_lcd_extern_get_driver(index);
+        if (ext_drv == NULL) {
+            lcd_print("no lcd_extern driver for mipi-dsi\n");
+        } else {
+            if (ext_drv->init_off_cmd_8) {
+                dsi_write_cmd(ext_drv->init_off_cmd_8);
+                DPRINT("[extern]%s dsi init off\n", ext_drv->config.name);
             }
         }
     }
+#endif
 }
 
 void set_mipi_dsi_control_config(Lcd_Config_t *pConf)
diff --git a/arch/arm/mach-mesong9bb/lcd/lcd_config.h b/arch/arm/mach-mesong9bb/lcd/lcd_config.h
index 5124195c043b..ca62fe99e7d3 100644
--- a/arch/arm/mach-mesong9bb/lcd/lcd_config.h
+++ b/arch/arm/mach-mesong9bb/lcd/lcd_config.h
@@ -7,7 +7,7 @@
 //lcd driver version
 // ********************************** */
 #define LCD_DRV_TYPE      "c9b"
-#define LCD_DRV_DATE      "20150525"
+#define LCD_DRV_DATE      "20150915"
 /* ********************************** */
 
 /* for GAMMA_CNTL_PORT */
diff --git a/arch/arm/mach-mesong9tv/lcd/lcd_config.h b/arch/arm/mach-mesong9tv/lcd/lcd_config.h
index bf9693159e33..672898fa7b4e 100644
--- a/arch/arm/mach-mesong9tv/lcd/lcd_config.h
+++ b/arch/arm/mach-mesong9tv/lcd/lcd_config.h
@@ -7,7 +7,7 @@
 //lcd driver version
 // ********************************** */
 #define LCD_DRV_TYPE      "c9"
-#define LCD_DRV_DATE      "20150525"
+#define LCD_DRV_DATE      "20150915"
 /* ********************************** */
 
 /* for GAMMA_CNTL_PORT */
diff --git a/drivers/amlogic/display/lcd/Kconfig b/drivers/amlogic/display/lcd/Kconfig
index 2e4ecd0366cc..ca80d4f284be 100644
--- a/drivers/amlogic/display/lcd/Kconfig
+++ b/drivers/amlogic/display/lcd/Kconfig
@@ -16,4 +16,6 @@ config AML_LCD_TV
 	help
 	  Amlogic TV LCD module support
 
+source "drivers/amlogic/display/lcd/aml_lcd_extern/Kconfig"
+
 endif
diff --git a/drivers/amlogic/display/lcd/Makefile b/drivers/amlogic/display/lcd/Makefile
index 1a89cf166cd0..9dea37588f20 100644
--- a/drivers/amlogic/display/lcd/Makefile
+++ b/drivers/amlogic/display/lcd/Makefile
@@ -5,3 +5,4 @@
 obj-y					+= lcd_notify.o
 obj-$(CONFIG_AML_LCD_TV)		+= aml_lcd_tv.o
 obj-$(CONFIG_AML_LCD_TV)		+= aml_tv_lcd_port/
+obj-$(CONFIG_AML_LCD_EXTERN)		+= aml_lcd_extern/
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/Kconfig b/drivers/amlogic/display/lcd/aml_lcd_extern/Kconfig
new file mode 100644
index 000000000000..7942481dbf56
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/Kconfig
@@ -0,0 +1,49 @@
+#
+# lcd extern driver configuration
+#
+
+menuconfig AML_LCD_EXTERN
+	tristate "Amlogic lcd extern driver support"
+	default n
+	help
+		Amlogic video output support
+
+if AML_LCD_EXTERN
+
+config AML_LCD_EXTERN_I2C_T5800Q
+	boolean "Amlogic i2c T5800Q lcd extern driver support"
+	default n
+	help
+		Video output and control module support
+
+config AML_LCD_EXTERN_I2C_TC101
+	boolean "Amlogic i2c tc101 lcd extern driver support"
+	default n
+	help
+		framerate adjustment automatically from video source
+
+config AML_LCD_EXTERN_I2C_ANX6345
+	boolean "Amlogic i2c anx6345 lcd extern driver support"
+	default n
+	help
+		vdac hardware switch of cvbs/ypbpr for mx.
+
+config AML_LCD_EXTERN_SPI_LD070WS2
+	boolean "Amlogic spi LD070WS2 lcd extern driver support"
+	default n
+	help
+		Tablet LCD output module support
+
+config AML_LCD_EXTERN_MIPI_N070ICN
+	boolean "Amlogic mipi N070ICN lcd extern driver support"
+	default n
+	help
+		Tablet LCD output module support
+
+config AML_LCD_EXTERN_MIPI_KD080D13
+	boolean "Amlogic mipi KD080D13 lcd extern driver support"
+	default n
+	help
+		Tablet LCD output module support
+
+endif
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/Makefile b/drivers/amlogic/display/lcd/aml_lcd_extern/Makefile
new file mode 100644
index 000000000000..5f997ae2eb88
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/Makefile
@@ -0,0 +1,10 @@
+
+obj-$(CONFIG_AML_LCD_EXTERN)			+= lcd_extern.o
+obj-$(CONFIG_AML_LCD_EXTERN_I2C_T5800Q)		+= i2c_T5800Q.o
+obj-$(CONFIG_AML_LCD_EXTERN_I2C_TC101)		+= i2c_tc101.o
+obj-$(CONFIG_AML_LCD_EXTERN_I2C_ANX6345)	+= i2c_anx6345.o
+obj-$(CONFIG_AML_LCD_EXTERN_SPI_LD070WS2)	+= spi_LD070WS2.o
+obj-$(CONFIG_AML_LCD_EXTERN_MIPI_N070ICN)	+= mipi_N070ICN.o
+obj-$(CONFIG_AML_LCD_EXTERN_MIPI_KD080D13)	+= mipi_KD080D13.o
+
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/aml.dtd b/drivers/amlogic/display/lcd/aml_lcd_extern/aml.dtd
new file mode 100644
index 000000000000..e69e499463c7
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/aml.dtd
@@ -0,0 +1,60 @@
+#ifdef CONFIG_AML_LCD_EXTERN
+//******************************************************************************
+//lcd extern
+//******************************************************************************
+lcd_extern{
+		compatible = "amlogic,lcd_extern";
+		dev_name = "lcd_extern";
+		status = "okay";
+
+		extern_0{
+			index = <0>;
+			extern_name = "i2c_T5800Q";
+			status = "okay";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x1c>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_d";
+		};
+		extern_1{
+			index = <1>;
+			extern_name = "i2c_tc101";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x7e>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_a";
+		};
+		extern_2{
+			index = <2>;
+			extern_name = "i2c_anx6345";
+			status = "disabled";
+			type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			i2c_address = <0x38>; /** 7bit i2c address */
+			i2c_bus = "i2c_bus_b";
+			lane_num = <1>; /** edp lane_num:1/2/4 */
+			bits = <0>;  /** bits of lcd(0: 6bit, 1: 8bit) */
+			link_rate = <1>; /** edp link rate (0: 1.62G, 1: 27G, 2: 5.4G) */
+		};
+		extern_3{
+			index = <3>;
+			extern_name = "spi_LD070WS2";
+			status = "disabled";
+			type = <1>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+			gpio_spi_cs="GPIODV_1";
+			gpio_spi_clk="GPIODV_16";
+			gpio_spi_data="GPIODV_17";
+		};
+		extern_4{
+			index = <4>;
+			extern_name = "_mipi_N070ICN";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+		extern_5{
+			index = <5>;
+			extern_name = "mipi_KD080D13";
+			status = "disabled";
+			type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		};
+};
+
+#endif
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_T5800Q.c b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_T5800Q.c
new file mode 100644
index 000000000000..5f4c92446ae9
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_T5800Q.c
@@ -0,0 +1,326 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * I2C
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+
+#define LCD_EXTERN_NAME			"i2c_T5800Q"
+
+static struct i2c_client *aml_T5800Q_i2c_client;
+static struct lcd_extern_config_t *ext_config;
+
+#define INIT_LEN        7
+static unsigned char i2c_init_table[][INIT_LEN] = {
+	//QFHD 50/60Hz 1 division Video Mode 
+	{0x20, 0x01, 0x02, 0x00, 0x40, 0xFF, 0x00},
+	{0x80, 0x02, 0x00, 0x40, 0x62, 0x51, 0x73},
+	{0x61, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{0xC1, 0x05, 0x0F, 0x00, 0x08, 0x70, 0x00},
+	{0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00},
+	{0x3D, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00}, //Color Engine Bypass Enable
+	{0xED, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x00}, //Mute only when starting
+	{0x23, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00}, //MEMC off
+	{0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0xFF},
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
+};
+
+static int lcd_extern_i2c_write(struct i2c_client *i2client, unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msg, 1);
+	if (ret < 0)
+		LCD_EXT_PR("i2c write failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+#if 0
+static int lcd_extern_i2c_read(struct i2c_client *i2client, unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msgs[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = buff,
+		},
+		{
+			.addr = i2client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msgs, 2);
+	if (ret < 0)
+		LCD_EXT_PR("i2c read failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+#endif
+
+static int lcd_extern_reg_read(unsigned char reg, unsigned char *buf)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_reg_write(unsigned char reg, unsigned char value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_i2c_init(void)
+{
+	int i = 0, ending_flag = 0;
+	int ret = 0;
+
+	while (ending_flag == 0) {
+		if ((i2c_init_table[i][0] == 0xff) && (i2c_init_table[i][1] == 0xff)) { //special mark
+			if (i2c_init_table[i][2] == 0xff) //ending flag
+				ending_flag = 1;
+			else //delay flag
+				mdelay(i2c_init_table[i][2]);
+		} else {
+			lcd_extern_i2c_write(aml_T5800Q_i2c_client, i2c_init_table[i], INIT_LEN);
+		}
+		i++;
+	}
+	LCD_EXT_PR("%s: %s\n", __func__, ext_config->name);
+	return ret;
+}
+
+static int lcd_extern_i2c_remove(void)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_power_on(void)
+{
+	int ret;
+
+	ret = lcd_extern_i2c_init();
+	return ret;
+}
+
+static int lcd_extern_power_off(void)
+{
+	int ret;
+
+	ret = lcd_extern_i2c_remove();
+	return ret;
+}
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->reg_read  = lcd_extern_reg_read;
+		ext_drv->reg_write = lcd_extern_reg_write;
+		ext_drv->power_on  = lcd_extern_power_on;
+		ext_drv->power_off = lcd_extern_power_off;
+	} else {
+		LCD_EXT_PR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+//*********************************************************
+//debug function
+//*********************************************************
+static const char * lcd_extern_debug_usage_str = {
+"Usage:\n"
+"    echo <reg> <> ... <> > write ; T5800Q i2c command write, 7 parameters without address\n"
+};
+
+static ssize_t lcd_extern_debug_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", lcd_extern_debug_usage_str);
+}
+
+static ssize_t lcd_extern_debug_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int temp[8];
+	unsigned char data[8];
+	int i;
+
+	memset(temp, 0, (sizeof(unsigned int) * 8));
+	ret = sscanf(buf, "%x %x %x %x %x %x %x",
+		&temp[0], &temp[1], &temp[2], &temp[3],
+		&temp[4], &temp[5], &temp[6]);
+	LCD_EXT_PR("T5800Q i2c write:\n");
+	for (i = 0; i < INIT_LEN; i++) {
+		data[i] = (unsigned char)temp[i];
+		printk("0x%02x ", data[i]);
+	}
+	printk("\n");
+	lcd_extern_i2c_write(aml_T5800Q_i2c_client, data, INIT_LEN);
+
+	if (ret != 1 || ret !=2)
+		return -EINVAL;
+
+	return count;
+}
+
+static struct class_attribute lcd_extern_class_attrs[] = {
+	__ATTR(write, S_IRUGO | S_IWUSR, lcd_extern_debug_help, lcd_extern_debug_write),
+};
+
+static struct class *debug_class;
+static int creat_lcd_extern_class(void)
+{
+	int i;
+
+	debug_class = class_create(THIS_MODULE, LCD_EXTERN_NAME);
+	if (IS_ERR(debug_class)) {
+		LCD_EXT_PR("create debug class failed\n");
+		return -1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(lcd_extern_class_attrs); i++) {
+		if (class_create_file(debug_class, &lcd_extern_class_attrs[i]))
+			LCD_EXT_PR("create debug attribute %s failed\n", lcd_extern_class_attrs[i].attr.name);
+	}
+
+	return 0;
+}
+
+#if 0
+static int remove_lcd_extern_class(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lcd_extern_class_attrs); i++)
+		class_remove_file(debug_class, &lcd_extern_class_attrs[i]);
+
+	class_destroy(debug_class);
+	debug_class = NULL;
+
+	return 0;
+}
+#endif
+//*********************************************************
+
+static int aml_T5800Q_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LCD_EXT_PR("[error] %s: functionality check failed\n", __func__);
+		return -ENODEV;
+	} else {
+		aml_T5800Q_i2c_client = client;
+	}
+
+	LCD_EXT_PR("%s OK\n", __func__);
+	return 0;
+}
+
+static int aml_T5800Q_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id aml_T5800Q_i2c_id[] = {
+	{LCD_EXTERN_NAME, 0},
+	{ }
+};
+// MODULE_DEVICE_TABLE(i2c, aml_T5800Q_id);
+
+static struct i2c_driver aml_T5800Q_i2c_driver = {
+	.probe    = aml_T5800Q_i2c_probe,
+	.remove   = aml_T5800Q_i2c_remove,
+	.id_table = aml_T5800Q_i2c_id,
+	.driver = {
+		.name = LCD_EXTERN_NAME,
+		.owner =THIS_MODULE,
+	},
+};
+
+int aml_lcd_extern_i2c_T5800Q_probe(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	struct i2c_board_info i2c_info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *i2c_client;
+	int ret = 0;
+
+	ext_config = &ext_drv->config;
+	memset(&i2c_info, 0, sizeof(i2c_info));
+
+	adapter = i2c_get_adapter(ext_drv->config.i2c_bus);
+	if (!adapter) {
+		LCD_EXT_PR("%s failed to get i2c adapter\n", ext_drv->config.name);
+		return -1;
+	}
+
+	strncpy(i2c_info.type, ext_drv->config.name, I2C_NAME_SIZE);
+	i2c_info.addr = ext_drv->config.i2c_addr;
+	i2c_info.platform_data = &ext_drv->config;
+	i2c_info.flags = 0;
+	if (i2c_info.addr > 0x7f) {
+		LCD_EXT_PR("%s invalid i2c address: 0x%02x\n", ext_drv->config.name, ext_drv->config.i2c_addr);
+		return -1;
+	}
+	i2c_client = i2c_new_device(adapter, &i2c_info);
+	if (!i2c_client) {
+		LCD_EXT_PR("%s failed to new i2c device\n", ext_drv->config.name);
+		return -1;
+	} else {
+		DBG_PRINT("%s new i2c device succeed\n", ext_drv->config.name);
+	}
+
+	if (!aml_T5800Q_i2c_client) {
+		ret = i2c_add_driver(&aml_T5800Q_i2c_driver);
+		if (ret) {
+			LCD_EXT_PR("%s add i2c_driver failed\n", ext_drv->config.name);
+			return -1;
+		}
+	}
+
+	ret = lcd_extern_driver_update(ext_drv);
+	creat_lcd_extern_class();
+
+	DBG_PRINT("%s: %d\n", __func__, ret);
+	return ret;
+}
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.c b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.c
new file mode 100644
index 000000000000..acd3895d371c
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.c
@@ -0,0 +1,540 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * I2C
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+#include "i2c_anx6345.h"
+
+#define LCD_EXTERN_NAME			"lcd_anx6345"
+
+static struct i2c_client *aml_anx6345_70_client;
+static struct i2c_client *aml_anx6345_72_client;
+static struct lcd_extern_config_t *ext_config;
+
+const char *anx_addr_name[2] = {"anx6345_70","anx6345_72"};
+
+struct lcd_extern_edp_config {
+	int lane_num;
+	int bits;
+	int link_rate;
+};
+
+static struct lcd_extern_edp_config edp_parameter = {
+	.lane_num = 1, // 1/2/4
+	.bits = 0x00,  // 6bit: 0x00   8bit: 0x10
+	.link_rate = 0x0a, //1.62G: 0X06, 2.7G: 0x0a, 5.4G: 0x14
+};
+
+static int lcd_extern_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msg, 1);
+	if (ret < 0)
+		LCD_EXT_PR("i2c write failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+
+static int lcd_extern_i2c_read(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msgs[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = buff,
+		},
+		{
+			.addr = i2client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msgs, 2);
+	if (ret < 0)
+		LCD_EXT_PR("i2c read failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+
+static int lcd_extern_reg_read(unsigned char reg, unsigned char *buf)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_reg_write(unsigned char reg, unsigned char value)
+{
+	int ret = 0;
+
+	return ret;
+}
+static int SP_TX_Write_Reg(unsigned char addr,unsigned char reg ,unsigned char data)
+{
+	struct i2c_client *client = aml_anx6345_70_client;
+	unsigned char buff[2];
+	int ret;
+
+	buff[0] = reg;
+	buff[1] = data;
+	if (addr == 0x70)
+		client = aml_anx6345_70_client;
+	else if (addr == 0x72)
+		client = aml_anx6345_72_client;
+
+	ret = lcd_extern_i2c_write(client, buff, 1);
+	if (ret < 0)
+		return -1;
+	else
+		return 0;
+}
+
+static int SP_TX_Read_Reg(unsigned char addr,unsigned char reg ,unsigned char* data)
+{
+	struct i2c_client *client = aml_anx6345_70_client;
+	int ret;
+
+	*data = reg;
+	if (addr == 0x70)
+		client = aml_anx6345_70_client;
+	else if (addr == 0x72)
+		client = aml_anx6345_72_client;
+
+	ret = lcd_extern_i2c_read(client, data, 1);
+	if (ret < 0)
+		return -1;
+	else
+		return 0;
+}
+
+static int SP_TX_Wait_AUX_Finished(void)
+{
+	unsigned char c;
+	unsigned char cCnt = 0;
+
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_STATUS, &c);
+	while (c & 0x10) {//aux busy
+		cCnt++;
+		SP_TX_Read_Reg(0x70, SP_TX_AUX_STATUS, &c);
+
+		if (cCnt > 100)
+			return 0; //aux fail
+	}
+
+	return 1;//aux ok
+}
+
+static int SP_TX_AUX_DPCDRead_Bytes(unsigned char addrh, unsigned char addrm, unsigned char addrl,unsigned char cCount,unsigned char *pBuf)
+{
+	unsigned char c,i;
+
+	//clr buffer
+	SP_TX_Write_Reg(0x70, SP_TX_BUF_DATA_COUNT_REG, 0x80);
+
+	//set read cmd and count
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_CTRL_REG, ((cCount-1) <<4)|0x09);
+
+	//set aux address15:0
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_ADDR_7_0_REG, addrl);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_ADDR_15_8_REG, addrm);
+
+	//set address19:16 and enable aux
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_ADDR_19_16_REG, &c);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_ADDR_19_16_REG, (c & 0xf0) | addrh);
+
+	//Enable Aux
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_CTRL_REG2, &c);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_CTRL_REG2, c|0x01);
+
+	mdelay(5);
+	if (!SP_TX_Wait_AUX_Finished())
+		return 0;
+
+	for (i = 0; i < cCount; i++) {
+		SP_TX_Read_Reg(0x70, SP_TX_BUF_DATA_0_REG+i, &c);
+
+		*(pBuf+i) = c;
+
+		if (i >= MAX_BUF_CNT)
+			break;
+	}
+
+	return 1;//aux ok
+}
+
+static int lcd_extern_i2c_init(void)
+{
+	unsigned lane_num;
+	unsigned link_rate;
+	unsigned char bits;
+	unsigned char device_id;
+	unsigned char temp;
+	unsigned char temp1;
+	unsigned count = 0;
+	unsigned count1 = 0;
+
+	lane_num = edp_parameter.lane_num;
+	link_rate = edp_parameter.link_rate;
+	bits = edp_parameter.bits;
+
+	SP_TX_Write_Reg (0x72, 0x05, 0x00);
+
+	SP_TX_Read_Reg(0x72, 0x01, &device_id);
+
+	if (device_id == 0xaa) {
+		LCD_EXT_PR("ANX6345 Chip found\n\n");
+	} else {
+		LCD_EXT_PR("ANX6345 Chip not found\n\n");
+		return 1;
+	}
+	temp = device_id;
+	//if aux read fail, do h/w reset,
+	while ((!SP_TX_AUX_DPCDRead_Bytes(0x00, 0x00, 0x00, 1, &temp1)) && (count < 200)) {
+		//read fail, h/w reset
+		SP_TX_Write_Reg (0x72, 0x06, 0x01);
+		SP_TX_Write_Reg (0x72, 0x06, 0x00);
+		SP_TX_Write_Reg (0x72, 0x05, 0x00);
+		mdelay(10);
+		count++;
+	}
+
+	//software reset
+	SP_TX_Read_Reg(0x72, SP_TX_RST_CTRL_REG, &temp);
+	SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL_REG, temp | SP_TX_RST_SW_RST);
+	SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL_REG, temp & ~SP_TX_RST_SW_RST);
+
+	SP_TX_Write_Reg(0x70, SP_TX_EXTRA_ADDR_REG, 0x50);//EDID address for AUX access
+	SP_TX_Write_Reg(0x70, SP_TX_HDCP_CTRL, 0x00); //disable HDCP polling mode.
+	//SP_TX_Write_Reg(0x70, SP_TX_HDCP_CTRL, 0x02); //Enable HDCP polling mode.
+	SP_TX_Write_Reg(0x70, SP_TX_LINK_DEBUG_REG, 0x30);//enable M value read out
+
+	//SP_TX_Read_Reg(0x70, SP_TX_DEBUG_REG1, &temp);
+	SP_TX_Write_Reg(0x70, SP_TX_DEBUG_REG1, 0x00);//disable polling HPD
+
+	SP_TX_Read_Reg(0x70, SP_TX_HDCP_CONTROL_0_REG, &temp);
+	SP_TX_Write_Reg(0x70, SP_TX_HDCP_CONTROL_0_REG, temp | 0x03);//set KSV valid
+
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_CTRL_REG2, &temp);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_CTRL_REG2, temp|0x08);//set double AUX output
+
+	SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK1, 0xbf);//unmask pll change int
+	SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK2, 0xff);//mask all int
+	SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK3, 0xff);//mask all int
+	SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK4, 0xff);//mask all int
+
+	//reset AUX
+	SP_TX_Read_Reg(0x72, SP_TX_RST_CTRL2_REG, &temp);
+	SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL2_REG, temp |SP_TX_AUX_RST);
+	SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL2_REG, temp & (~SP_TX_AUX_RST));
+
+	//Chip initialization
+
+	SP_TX_Write_Reg(0x70, SP_TX_SYS_CTRL1_REG, 0x00);
+	mdelay(10);
+
+	SP_TX_Write_Reg(0x72, SP_TX_VID_CTRL2_REG, bits);
+
+	//ANX6345 chip analog setting
+	SP_TX_Write_Reg(0x70, SP_TX_PLL_CTRL_REG, 0x00);  //UPDATE: FROM 0X07 TO 0X00
+
+	//ANX chip analog setting
+	//SP_TX_Write_Reg(0x72, ANALOG_DEBUG_REG1, 0x70);  //UPDATE: FROM 0XF0 TO 0X70
+	SP_TX_Write_Reg(0x70, SP_TX_LINK_DEBUG_REG, 0x30);
+
+	//force HPD
+	SP_TX_Write_Reg(0x70, SP_TX_SYS_CTRL3_REG, 0x30);
+
+	/* enable ssc function */
+	SP_TX_Write_Reg(0x70, 0xA7, 0x00);          // disable SSC first
+	SP_TX_Write_Reg(0x70, 0xD0, 0x5f);         // ssc d  0.4%, f0/4 mode
+	SP_TX_Write_Reg(0x70, 0xD1, 0x00);
+	SP_TX_Write_Reg(0x70, 0xD2, 0x75);         // ctrl_th
+	SP_TX_Read_Reg(0x70, 0xA7, &temp);
+	SP_TX_Write_Reg(0x70, 0xA7, temp | 0x10);  // enable SSC
+	SP_TX_Read_Reg(0x72, 0x07, &temp);         //reset SSC
+	SP_TX_Write_Reg(0x72, 0x07, temp | 0x80);
+	SP_TX_Write_Reg(0x72, 0x07, temp & (~0x80));
+
+	//Select 2.7G
+	SP_TX_Write_Reg(0x70, SP_TX_LINK_BW_SET_REG, link_rate); //2.7g:0x0a;1.62g:0x06
+	//Select 2 lanes
+	SP_TX_Write_Reg(0x70, 0xa1, lane_num);
+
+	SP_TX_Write_Reg(0x70, SP_TX_LINK_TRAINING_CTRL_REG, SP_TX_LINK_TRAINING_CTRL_EN);
+	mdelay(5);
+	SP_TX_Read_Reg(0x70, SP_TX_LINK_TRAINING_CTRL_REG, &temp);
+	/* UPDATE: FROM 0X01 TO 0X80 */
+	while ((temp & 0x80) != 0) {
+		//debug_puts("Waiting...\n");
+		mdelay(5);
+		count1++;
+		if (count1 > 100) {
+			LCD_EXT_PR("ANX6345 Link training fail\n");
+			break;
+		}
+		SP_TX_Read_Reg(0x70, SP_TX_LINK_TRAINING_CTRL_REG, &temp);
+	}
+
+	SP_TX_Write_Reg(0x72, 0x12, 0x2c);
+	SP_TX_Write_Reg(0x72, 0x13, 0x06);
+	SP_TX_Write_Reg(0x72, 0x14, 0x00);
+	SP_TX_Write_Reg(0x72, 0x15, 0x06);
+	SP_TX_Write_Reg(0x72, 0x16, 0x02);
+	SP_TX_Write_Reg(0x72, 0x17, 0x04);
+	SP_TX_Write_Reg(0x72, 0x18, 0x26);
+	SP_TX_Write_Reg(0x72, 0x19, 0x50);
+	SP_TX_Write_Reg(0x72, 0x1a, 0x04);
+	SP_TX_Write_Reg(0x72, 0x1b, 0x00);
+	SP_TX_Write_Reg(0x72, 0x1c, 0x04);
+	SP_TX_Write_Reg(0x72, 0x1d, 0x18);
+	SP_TX_Write_Reg(0x72, 0x1e, 0x00);
+	SP_TX_Write_Reg(0x72, 0x1f, 0x10);
+	SP_TX_Write_Reg(0x72, 0x20, 0x00);
+	SP_TX_Write_Reg(0x72, 0x21, 0x28);
+
+	SP_TX_Write_Reg(0x72, 0x11, 0x03);
+	//enable BIST. In normal mode, don't need to config this reg
+	//if want to open BIST,must setting right dat 0x11-0x21 base lcd timing.
+	//SP_TX_Write_Reg(0x72, 0x0b, 0x09);//colorbar:08,graystep:09
+	SP_TX_Write_Reg(0x72, 0x08, 0x81); //SDR:0x81;DDR:0x8f
+
+	//force HPD and stream valid
+	SP_TX_Write_Reg(0x70, 0x82, 0x33);
+
+	LCD_EXT_PR("%s: %s\n", __func__, ext_config->name);
+	return 0;
+}
+
+static int lcd_extern_i2c_remove(void)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_power_on(void)
+{
+	int ret;
+
+	ret = lcd_extern_i2c_init();
+	return ret;
+}
+
+static int lcd_extern_power_off(void)
+{
+	int ret;
+
+	ret = lcd_extern_i2c_remove();
+	return ret;
+}
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->reg_read  = lcd_extern_reg_read;
+		ext_drv->reg_write = lcd_extern_reg_write;
+		ext_drv->power_on  = lcd_extern_power_on;
+		ext_drv->power_off = lcd_extern_power_off;
+	} else {
+		LCD_EXT_PR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_USE_OF
+static int aml_lcd_extern_get_dt_config(int index)
+{
+	int err;
+	struct device_node* child;
+
+	child = aml_lcd_extern_get_dt_child(index);
+	if (child == NULL) {
+		LCD_EXT_PR("can't get dt child %d\n", index);
+		return -1;
+	}
+
+	err = of_property_read_u32(child, "lane_num", &edp_parameter.lane_num);
+	if (err)
+		LCD_EXT_PR("get index failed, use default setting\n");
+	DBG_PRINT ("lane_num = %d\n", edp_parameter.lane_num);
+
+	err = of_property_read_u32(child, "bits", &edp_parameter.bits);
+	if (err)
+		LCD_EXT_PR("get bits failed, use default setting\n");
+	DBG_PRINT ("bits = %d\n", edp_parameter.bits);
+
+	err = of_property_read_u32(child, "link_rate", &edp_parameter.link_rate);
+	if (err)
+		LCD_EXT_PR("get link_rate failed, use default setting\n");
+	DBG_PRINT ("link_rate = %d\n", edp_parameter.link_rate);
+
+	return 0;
+}
+#endif
+
+static int aml_anx6345_70_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LCD_EXT_PR("[error] %s: functionality check failed\n", __FUNCTION__);
+		return -ENODEV;
+	} else {
+		aml_anx6345_70_client = client;
+	}
+
+	LCD_EXT_PR("%s OK\n", __func__);
+	return 0;
+}
+
+static int aml_anx6345_72_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LCD_EXT_PR("[error] %s: functionality check failed\n", __func__);
+		return -ENODEV;
+	} else {
+		aml_anx6345_72_client = client;
+	}
+
+	LCD_EXT_PR("%s OK\n", __func__);
+	return 0;
+}
+
+static int aml_anx6345_70_remove(struct i2c_client *client)
+{
+	return 0;
+}
+static int aml_anx6345_72_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id aml_anx6345_70_id[] = {
+	{"anx6345_70", 0},
+	{ }
+};
+static const struct i2c_device_id aml_anx6345_72_id[] = {
+	{"anx6345_72", 0},
+	{ }
+};
+
+// MODULE_DEVICE_TABLE(i2c, aml_tc101_id);
+
+static struct i2c_driver aml_anx6345_70_driver = {
+	.probe    = aml_anx6345_70_probe,
+	.remove   = aml_anx6345_70_remove,
+	.id_table = aml_anx6345_70_id,
+	.driver = {
+		.name = "anx6345_70",
+		.owner =THIS_MODULE,
+	},
+};
+static struct i2c_driver aml_anx6345_72_driver = {
+	.probe    = aml_anx6345_72_probe,
+	.remove   = aml_anx6345_72_remove,
+	.id_table = aml_anx6345_72_id,
+	.driver = {
+		.name = "anx6345_72",
+		.owner =THIS_MODULE,
+	},
+};
+
+
+int aml_lcd_extern_i2c_anx6345_probe(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	struct i2c_board_info i2c_info[2];
+	struct i2c_adapter *adapter;
+	struct i2c_client *i2c_client;
+	int i = 0;
+	int ret = 0;
+
+	ext_config = &ext_drv->config;
+	aml_lcd_extern_get_dt_config(ext_drv->config.index);
+
+	for (i = 0; i < 2; i++)
+		memset(&i2c_info[i], 0, sizeof(i2c_info[i]));
+
+	adapter = i2c_get_adapter(ext_drv->config.i2c_bus);
+	if (!adapter) {
+		LCD_EXT_PR("%s failed to get i2c adapter\n", ext_drv->config.name);
+		return -1;
+	}
+	for (i = 0; i < 2; i++)
+		strncpy(i2c_info[i].type, anx_addr_name[i], I2C_NAME_SIZE);
+	i2c_info[0].addr = (0x70 >> 1);
+	i2c_info[1].addr = (0x72 >> 1);
+	for (i = 0; i < 2; i++) {
+		i2c_info[i].flags = 0;
+		if (i2c_info[i].addr > 0x7f) {
+			LCD_EXT_PR("%s invalid i2c address: 0x%02x\n", ext_drv->config.name, i2c_info[i].addr);
+			return -1;
+		}
+		i2c_client = i2c_new_device(adapter, &i2c_info[i]);
+		if (!i2c_client) {
+			LCD_EXT_PR("%s(0x%02x) failed to new i2c device\n", ext_drv->config.name, i2c_info[i].addr);
+			return -1;
+		} else {
+			DBG_PRINT("%s(0x%02x) new i2c device succeed\n", ext_drv->config.name, i2c_info[i].addr);
+		}
+	}
+
+	if (!aml_anx6345_70_client) {
+		ret = i2c_add_driver(&aml_anx6345_70_driver);
+		if (ret) {
+			LCD_EXT_PR("%s add i2c_driver_70 failed\n", ext_drv->config.name);
+			return -1;
+		}
+	}
+
+	if (!aml_anx6345_72_client) {
+		ret = i2c_add_driver(&aml_anx6345_72_driver);
+		if (ret) {
+			LCD_EXT_PR("%s add i2c_driver_72 failed\n", ext_drv->config.name);
+			return -1;
+		}
+	}
+
+	ret = lcd_extern_driver_update(ext_drv);
+
+	DBG_PRINT("%s: %d\n", __func__, ret);
+	return ret;
+}
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.h b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.h
new file mode 100644
index 000000000000..770987fa75fe
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_anx6345.h
@@ -0,0 +1,666 @@
+#ifndef EDP_ANX6345_H
+#define EDP_ANX6345_H
+
+
+#define SP_TX_PORT0_ADDR 0x70
+#define SP_TX_PORT1_ADDR 0x74
+#define SP_TX_PORT2_ADDR 0x72
+#define MIPI_RX_PORT1_ADDR 0x7A
+
+#define MAX_BUF_CNT 6
+
+#define CR_LOOP_TIME 5
+#define EQ_LOOP_TIME 5
+
+#define SP_TX_AVI_SEL 0x01
+#define SP_TX_SPD_SEL 0x02
+#define SP_TX_MPEG_SEL 0x04
+
+#define VAL_EDP_TX_LINK_BW_SET_162						0x06
+#define VAL_EDP_TX_LINK_BW_SET_270						0x0a
+#define VAL_EDP_TX_LINK_BW_SET_540						0x14
+
+//End for DEV_addr 0x7A/0x7E
+
+/***************************************************************/
+//  DEV_ADDR = 0x70 or 0x78 , Displayport mode and HDCP registers
+#define SP_TX_HDCP_STATUS							0x00
+#define SP_TX_HDCP_AUTH_PASS						  	0x02//bit position
+
+#define SP_TX_HDCP_CONTROL_0_REG                  		0x01
+#define SP_TX_HDCP_CONTROL_0_STORE_AN            0x80//bit position
+#define SP_TX_HDCP_CONTROL_0_RX_REPEATER   	0x40//bit position
+#define SP_TX_HDCP_CONTROL_0_RE_AUTH              0x20//bit position
+#define SP_TX_HDCP_CONTROL_0_SW_AUTH_OK       0x10//bit position
+#define SP_TX_HDCP_CONTROL_0_HARD_AUTH_EN   0x08//bit position
+#define SP_TX_HDCP_CONTROL_0_HDCP_ENC_EN      0x04//bit position
+#define SP_TX_HDCP_CONTROL_0_BKSV_SRM_PASS  0x02//bit position
+#define SP_TX_HDCP_CONTROL_0_KSVLIST_VLD        0x01//bit position
+
+
+#define SP_TX_HDCP_CONTROL_1_REG                  		0x02
+#define SP_TX_HDCP_CONTROL_1_DDC_NO_STOP      			0x20//bit position
+#define SP_TX_HDCP_CONTROL_1_DDC_NO_ACK        			0x10//bit position
+#define SP_TX_HDCP_CONTROL_1_EDDC_NO_ACK          		0x08//bit position
+//#define SP_TX_HDCP_CONTROL_1_HDCP_EMB_SCREEN_EN   		0x04//bit position
+#define SP_TX_HDCP_CONTROL_1_RCV_11_EN                  0x02//bit position
+#define SP_TX_HDCP_CONTROL_1_HDCP_11_EN           		0x01//bit position
+
+#define SP_TX_HDCP_LINK_CHK_FRAME_NUM				 	0x03
+#define SP_TX_HDCP_CONTROL_2_REG					0x04
+
+#define SP_TX_HDCP_AKSV0								0x05
+#define SP_TX_HDCP_AKSV1								0x06
+#define SP_TX_HDCP_AKSV2								0x07
+#define SP_TX_HDCP_AKSV3								0x08
+#define SP_TX_HDCP_AKSV4								0x09
+
+//AKSV
+#define SP_TX_HDCP_AN0									0x0A
+#define SP_TX_HDCP_AN1									0x0B
+#define SP_TX_HDCP_AN2									0x0C
+#define SP_TX_HDCP_AN3									0x0D
+#define SP_TX_HDCP_AN4									0x0E
+#define SP_TX_HDCP_AN5									0x0F
+#define SP_TX_HDCP_AN6									0x10
+#define SP_TX_HDCP_AN7									0x11
+
+//BKSV
+#define SP_TX_HDCP_BKSV0								0x12
+#define SP_TX_HDCP_BKSV1								0x13
+#define SP_TX_HDCP_BKSV2								0x14
+#define SP_TX_HDCP_BKSV3								0x15
+#define SP_TX_HDCP_BKSV4								0x16
+
+#define SP_TX_HDCP_R0_L									0x17
+#define SP_TX_HDCP_R0_H									0x18
+
+#ifndef M_VID_0
+#define M_VID_0 0xC0
+#define M_VID_1 0xC1
+#define M_VID_2 0xC2
+#define N_VID_0 0xC3
+#define N_VID_1 0xC4
+#define N_VID_2 0xC5
+#endif
+
+#define SP_TX_HDCP_R0_WAIT_Timer					 0x40
+
+
+
+#define SP_TX_SYS_CTRL1_REG           					0x80
+//#define SP_TX_SYS_CTRL1_PD_IO         					0x80    // bit position
+//#define SP_TX_SYS_CTRL1_PD_VID        					0x40    // bit position
+//#define SP_TX_SYS_CTRL1_PD_LINK       					0x20    // bit position
+//#define SP_TX_SYS_CTRL1_PD_TOTAL      					0x10    // bit position
+//#define SP_TX_SYS_CTRL1_MODE_SEL      					0x08    // bit position
+#define SP_TX_SYS_CTRL1_DET_STA       					0x04    // bit position
+#define SP_TX_SYS_CTRL1_FORCE_DET     					0x02    // bit position
+#define SP_TX_SYS_CTRL1_DET_CTRL      					0x01    // bit position
+
+#define SP_TX_SYS_CTRL2_REG           					0x81
+// #define SP_TX_SYS_CTRL2_ENHANCED 	  					0x08  //bit position
+#define SP_TX_SYS_CTRL2_CHA_STA       					0x04    // bit position
+#define SP_TX_SYS_CTRL2_FORCE_CHA     					0x02    // bit position
+#define SP_TX_SYS_CTRL2_CHA_CTRL      					0x01    // bit position
+
+#define SP_TX_SYS_CTRL3_REG           					0x82
+#define SP_TX_SYS_CTRL3_HPD_STATUS    					0x40    // bit position
+#define SP_TX_SYS_CTRL3_F_HPD         					0x20    // bit position
+#define SP_TX_SYS_CTRL3_HPD_CTRL      					0x10    // bit position
+#define SP_TX_SYS_CTRL3_STRM_VALID    					0x04    // bit position
+#define SP_TX_SYS_CTRL3_F_VALID       					0x02    // bit position
+#define SP_TX_SYS_CTRL3_VALID_CTRL    					0x01    // bit position
+
+#define SP_TX_SYS_CTRL4_REG			  				0x83
+#define SP_TX_SYS_CTRL4_ENHANCED 	  					0x08//bit position
+
+#define SP_TX_VID_CTRL				  				0x84
+
+#define SP_TX_AUD_CTRL								0x87
+#define SP_TX_AUD_CTRL_AUD_EN							0x01
+
+
+#define SP_TX_PKT_EN_REG              					0x90
+#define SP_TX_PKT_AUD_UP								0x80  // bit position
+#define SP_TX_PKT_AVI_UD              					0x40  // bit position
+#define SP_TX_PKT_MPEG_UD             					0x20  // bit position
+#define SP_TX_PKT_SPD_UD              					0x10  // bit position
+#define SP_TX_PKT_AUD_EN								0x08  // bit position=
+#define SP_TX_PKT_AVI_EN              					0x04  // bit position
+#define SP_TX_PKT_MPEG_EN             					0x02  // bit position
+#define SP_TX_PKT_SPD_EN              					0x01  // bit position
+
+
+#define SP_TX_HDCP_CTRL 							0x92
+
+#define SP_TX_LINK_BW_SET_REG         				 0xA0
+#define SP_TX_LANE_COUNT_SET_REG      				 0xA1
+
+#define SP_TX_TRAINING_PTN_SET_REG                   0xA2
+#define SP_TX_SCRAMBLE_DISABLE						 0x20//bit 5
+
+#define SP_TX_TRAINING_LANE0_SET_REG                 				0xA3
+#define SP_TX_TRAINING_LANE0_SET_MAX_PRE_REACH        0x20        // bit position
+#define SP_TX_TRAINING_LANE0_SET_MAX_DRIVE_REACH     0x04        // bit position
+
+#define SP_TX_TRAINING_LANE1_SET_REG                0xA4
+
+
+#define SSC_CTRL_REG1					 0xA7
+#define SPREAD_AMP						 0x10//bit 4
+#define MODULATION_FREQ					 0x01//bit 0
+
+
+#define SP_TX_LINK_TRAINING_CTRL_REG                0xA8
+#define SP_TX_LINK_TRAINING_CTRL_EN                 0x01        // bit position
+
+
+#define SP_TX_DEBUG_REG1							0xB0
+#define SP_TX_DEBUG_HPD_POLLING_DET						0x40//bit position
+#define SP_TX_DEBUG_HPD_POLLING_EN						0x20//bit position
+#define SP_TX_DEBUG_PLL_LOCK						0x10//bit position
+
+
+#define SP_TX_LINK_DEBUG_REG                        0xB8
+#define SP_TX_LINK_DEBUG_INSERT_ER                  0x02        // bit position
+#define SP_TX_LINK_DEBUG_PRBS31_EN                  0x01        // bit position
+
+#define SP_TX_SINK_COUNT_REG                0xB9
+
+#define SP_TX_LINK_STATUS_REG1                               0xBB
+
+#define SP_TX_SINK_STATUS_REG                                   0xBE
+#define SP_TX_SINK_STATUS_SINK_STATUS_1          	0x02        // bit position
+#define SP_TX_SINK_STATUS_SINK_STATUS_0          	0x01        // bit position
+
+
+//#define SP_TX_LINK_TEST_COUNT                     0xC0
+
+
+#define SP_TX_PLL_CTRL_REG							0xC7
+#define SP_TX_PLL_CTRL_PLL_PD           					0x80        // bit position
+#define SP_TX_PLL_CTRL_PLL_RESET        					0x40        // bit position
+//#define SP_TX_PLL_CTRL_CPREG_BLEED      					0x08        // bit position
+
+#define SP_TX_ANALOG_POWER_DOWN_REG                   			0xC8
+#define SP_TX_ANALOG_POWER_DOWN_MACRO_PD              	0x20        // bit position
+#define SP_TX_ANALOG_POWER_DOWN_AUX_PD                		0x10        // bit position
+//#define SP_TX_ANALOG_POWER_DOWN_CH3_PD                		0x08        // bit position
+//#define SP_TX_ANALOG_POWER_DOWN_CH2_PD                		0x04        // bit position
+#define SP_TX_ANALOG_POWER_DOWN_CH1_PD                		0x02        // bit position
+#define SP_TX_ANALOG_POWER_DOWN_CH0_PD                		0x01        // bit position
+
+
+#define SP_TX_ANALOG_TEST_REG                         				0xC9
+#define SP_TX_ANALOG_TEST_MACRO_RST                   				0x20       // bit position
+#define SP_TX_ANALOG_TEST_PLL_TEST                    				0x10       // bit position
+#define SP_TX_ANALOG_TEST_CH3_TEST                    				0x08       // bit position
+#define SP_TX_ANALOG_TEST_CH2_TEST                    				0x04       // bit position
+#define SP_TX_ANALOG_TEST_CH1_TEST                    				0x02       // bit position
+#define SP_TX_ANALOG_TEST_CH0_TEST                    				0x01       // bit position
+
+#define SP_TX_GNS_CTRL_REG                            				0xCD
+#define SP_EQ_LOOP_CNT								0x40//bit position
+#define SP_TX_VIDEO_MAP_CTRL                 			                0x02       // bit position
+#define SP_TX_RS_CTRL                        					0x01       // bit position
+
+#define SP_TX_DOWN_SPREADING_CTRL1                                               0xD0   //guochuncheng
+#define SP_TX_DOWN_SPREADING_CTRL2                                               0xD1
+#define SP_TX_DOWN_SPREADING_CTRL3                                               0xD2
+#define SP_TX_SSC_D_CTRL                                                         0x40       //bit position
+#define SP_TX_FS_CTRL_TH_CTRL                                                   0x20       //bit position
+
+#define SP_TX_M_CALCU_CTRL							0xD9
+#define M_GEN_CLK_SEL								0x01//bit 0
+
+
+#define SP_TX_EXTRA_ADDR_REG							0xCE
+#define SP_TX_I2C_STRETCH_CTRL_REG                                              0xDB
+#define SP_TX_AUX_STATUS            						0xE0
+#define SP_TX_DEFER_CTRL_REG            					0xE2
+#define SP_TXL_DEFER_CTRL_EN  					                0x80       // bit position
+
+#define SP_TX_BUF_DATA_COUNT_REG						0xE4
+#define SP_TX_AUX_CTRL_REG              					0xE5
+#define SP_TX_MOT_BIT								0x04//bit 2
+
+#define SP_TX_AUX_ADDR_7_0_REG          					0xE6
+#define SP_TX_AUX_ADDR_15_8_REG         					0xE7
+#define SP_TX_AUX_ADDR_19_16_REG        					0xE8
+
+#define SP_TX_AUX_CTRL_REG2                                                 0xE9
+#define SP_TX_ADDR_ONLY_BIT							0x02//bit 1
+
+#define SP_TX_BUF_DATA_0_REG                          0xf0
+#define SP_TX_BUF_DATA_1_REG                          0xf1
+#define SP_TX_BUF_DATA_2_REG                          0xf2
+#define SP_TX_BUF_DATA_3_REG                          0xf3
+#define SP_TX_BUF_DATA_4_REG                          0xf4
+#define SP_TX_BUF_DATA_5_REG                          0xf5
+#define SP_TX_BUF_DATA_6_REG                          0xf6
+#define SP_TX_BUF_DATA_7_REG                          0xf7
+#define SP_TX_BUF_DATA_8_REG                          0xf8
+#define SP_TX_BUF_DATA_9_REG                          0xf9
+#define SP_TX_BUF_DATA_10_REG                         0xfa
+#define SP_TX_BUF_DATA_11_REG                         0xfb
+#define SP_TX_BUF_DATA_12_REG                         0xfc
+#define SP_TX_BUF_DATA_13_REG                         0xfd
+#define SP_TX_BUF_DATA_14_REG                         0xfe
+#define SP_TX_BUF_DATA_15_REG                         0xff
+
+//End for Address 0x70 or 0x78
+
+/***************************************************************/
+//  DEV_ADDR = 0x72 or 0x76, System control registers
+#define SP_TX_VND_IDL_REG             	0x00
+#define SP_TX_VND_IDH_REG             	0x01
+#define SP_TX_DEV_IDL_REG             	0x02
+#define SP_TX_DEV_IDH_REG             	0x03
+#define SP_TX_DEV_REV_REG             	0x04
+
+#define SP_POWERD_CTRL_REG			  	0x05
+#define SP_POWERD_REGISTER_REG			0x80// bit position
+//#define SP_POWERD_MISC_REG			  	0x40// bit position
+#define SP_POWERD_IO_REG			  	0x20// bit position
+#define SP_POWERD_AUDIO_REG				0x10// bit position
+#define SP_POWERD_VIDEO_REG			  	0x08// bit position
+#define SP_POWERD_LINK_REG			  	0x04// bit position
+#define SP_POWERD_TOTAL_REG			  	0x02// bit position
+#define SP_MODE_SEL_REG				  	0x01// bit position
+
+#define SP_TX_RST_CTRL_REG            	0x06
+#define SP_TX_RST_MISC_REG 			  	0x80	// bit position
+#define SP_TX_RST_VIDCAP_REG		  	0x40	// bit position
+#define SP_TX_RST_VIDFIF_REG          	0x20    // bit position
+#define SP_TX_RST_AUDFIF_REG          	0x10    // bit position
+#define SP_TX_RST_AUDCAP_REG         	0x08    // bit position
+#define SP_TX_RST_HDCP_REG            	0x04    // bit position
+#define SP_TX_RST_SW_RST             	0x02    // bit position
+#define SP_TX_RST_HW_RST             	0x01    // bit position
+
+#define SP_TX_RST_CTRL2_REG				0x07
+#define SP_TX_RST_SSC					0x80//bit position
+#define SP_TX_AC_MODE					0x40//bit position
+//#define SP_TX_DDC_RST					0x10//bit position
+//#define SP_TX_TMDS_BIST_RST				0x08//bit position
+#define SP_TX_AUX_RST					0x04//bit position
+#define SP_TX_SERDES_FIFO_RST			0x02//bit position
+#define SP_TX_I2C_REG_RST				0x01//bit position
+
+
+#define SP_TX_VID_CTRL1_REG           	0x08
+#define SP_TX_VID_CTRL1_VID_EN       0x80    // bit position
+#define SP_TX_VID_CTRL1_VID_MUTE   0x40    // bit position
+#define SP_TX_VID_CTRL1_DE_GEN      0x20    // bit position
+#define SP_TX_VID_CTRL1_DEMUX        0x10    // bit position
+#define SP_TX_VID_CTRL1_IN_BIT		  	0x04    // bit position
+#define SP_TX_VID_CTRL1_DDRCTRL		0x02    // bit position
+#define SP_TX_VID_CTRL1_EDGE		  		0x01    // bit position
+
+#define SP_TX_VID_CTRL2_REG           	0x09
+#define SP_TX_VID_CTRL1_YCBIT_SEL  		0x04    // bit position
+
+#define SP_TX_VID_CTRL3_REG           	0x0A
+
+#define SP_TX_VID_CTRL4_REG           	0x0B
+#define SP_TX_VID_CTRL4_E_SYNC_EN	  	0x80	  //bit position
+#define SP_TX_VID_CTRL4_EX_E_SYNC    0x40    // bit position
+#define SP_TX_VID_CTRL4_BIST          		0x08    // bit position
+#define SP_TX_VID_CTRL4_BIST_WIDTH   0x04        // bit position
+
+#define SP_TX_VID_CTRL5_REG           		0x0C
+
+#define SP_TX_VID_CTRL6_REG           		0x0D
+#define SP_TX_VID_UPSAMPLE					0x02//bit position
+
+#define SP_TX_VID_CTRL7_REG           		0x0E
+#define SP_TX_VID_CTRL8_REG           		0x0F
+#define SP_TX_VID_CTRL9_REG           		0x10
+
+#define SP_TX_VID_CTRL10_REG           	0x11
+#define SP_TX_VID_CTRL10_INV_F         	0x08    // bit position
+#define SP_TX_VID_CTRL10_I_SCAN        	0x04    // bit position
+#define SP_TX_VID_CTRL10_VSYNC_POL   0x02    // bit position
+#define SP_TX_VID_CTRL10_HSYNC_POL   0x01    // bit position
+
+#define SP_TX_TOTAL_LINEL_REG         0x12
+#define SP_TX_TOTAL_LINEH_REG         0x13
+#define SP_TX_ACT_LINEL_REG           0x14
+#define SP_TX_ACT_LINEH_REG           0x15
+#define SP_TX_VF_PORCH_REG            0x16
+#define SP_TX_VSYNC_CFG_REG           0x17
+#define SP_TX_VB_PORCH_REG            0x18
+#define SP_TX_TOTAL_PIXELL_REG        0x19
+#define SP_TX_TOTAL_PIXELH_REG        0x1A
+#define SP_TX_ACT_PIXELL_REG          0x1B
+#define SP_TX_ACT_PIXELH_REG          0x1C
+#define SP_TX_HF_PORCHL_REG           0x1D
+#define SP_TX_HF_PORCHH_REG           0x1E
+#define SP_TX_HSYNC_CFGL_REG          0x1F
+#define SP_TX_HSYNC_CFGH_REG          0x20
+#define SP_TX_HB_PORCHL_REG           0x21
+#define SP_TX_HB_PORCHH_REG           0x22
+
+#define SP_TX_VID_STATUS		0x23
+
+#define SP_TX_TOTAL_LINE_STA_L        0x24
+#define SP_TX_TOTAL_LINE_STA_H        0x25
+#define SP_TX_ACT_LINE_STA_L          0x26
+#define SP_TX_ACT_LINE_STA_H          0x27
+#define SP_TX_V_F_PORCH_STA           0x28
+#define SP_TX_V_SYNC_STA              0x29
+#define SP_TX_V_B_PORCH_STA           0x2A
+#define SP_TX_TOTAL_PIXEL_STA_L       0x2B
+#define SP_TX_TOTAL_PIXEL_STA_H       0x2C
+#define SP_TX_ACT_PIXEL_STA_L         0x2D
+#define SP_TX_ACT_PIXEL_STA_H         0x2E
+#define SP_TX_H_F_PORCH_STA_L         0x2F
+#define SP_TX_H_F_PORCH_STA_H         0x30
+#define SP_TX_H_SYNC_STA_L            0x31
+#define SP_TX_H_SYNC_STA_H            0x32
+#define SP_TX_H_B_PORCH_STA_L         0x33
+#define SP_TX_H_B_PORCH_STA_H         0x34
+
+#define SP_TX_Video_Interface_BIST    0x35
+
+#define SPDIF_AUDIO_CTRL0			0x36
+#define SPDIF_AUDIO_CTRL0_SPDIF_IN  0x80 // bit position
+
+#define SPDIF_AUDIO_STATUS0			0x38
+#define SPDIF_AUDIO_STATUS0_CLK_DET 0x80
+#define SPDIF_AUDIO_STATUS0_AUD_DET 0x01
+
+#define SPDIF_AUDIO_STATUS1 0x39
+
+#define AUDIO_BIST_CTRL 0x3c
+#define AUDIO_BIST_EN 0x01
+
+//#define AUDIO_BIST_CHANNEL_STATUS1 0xd0
+//#define AUDIO_BIST_CHANNEL_STATUS2 0xd1
+//#define AUDIO_BIST_CHANNEL_STATUS3 0xd2
+//#define AUDIO_BIST_CHANNEL_STATUS4 0xd3
+//#define AUDIO_BIST_CHANNEL_STATUS5 0xd4
+
+#define SP_TX_VIDEO_BIT_CTRL_0_REG                    0x40
+#define SP_TX_VIDEO_BIT_CTRL_1_REG                    0x41
+#define SP_TX_VIDEO_BIT_CTRL_2_REG                    0x42
+#define SP_TX_VIDEO_BIT_CTRL_3_REG                    0x43
+#define SP_TX_VIDEO_BIT_CTRL_4_REG                    0x44
+#define SP_TX_VIDEO_BIT_CTRL_5_REG                    0x45
+#define SP_TX_VIDEO_BIT_CTRL_6_REG                    0x46
+#define SP_TX_VIDEO_BIT_CTRL_7_REG                    0x47
+#define SP_TX_VIDEO_BIT_CTRL_8_REG                    0x48
+#define SP_TX_VIDEO_BIT_CTRL_9_REG                    0x49
+#define SP_TX_VIDEO_BIT_CTRL_10_REG                   0x4a
+#define SP_TX_VIDEO_BIT_CTRL_11_REG                   0x4b
+#define SP_TX_VIDEO_BIT_CTRL_12_REG                   0x4c
+#define SP_TX_VIDEO_BIT_CTRL_13_REG                   0x4d
+#define SP_TX_VIDEO_BIT_CTRL_14_REG                   0x4e
+#define SP_TX_VIDEO_BIT_CTRL_15_REG                   0x4f
+#define SP_TX_VIDEO_BIT_CTRL_16_REG                   0x50
+#define SP_TX_VIDEO_BIT_CTRL_17_REG                   0x51
+#define SP_TX_VIDEO_BIT_CTRL_18_REG                   0x52
+#define SP_TX_VIDEO_BIT_CTRL_19_REG                   0x53
+#define SP_TX_VIDEO_BIT_CTRL_20_REG                   0x54
+#define SP_TX_VIDEO_BIT_CTRL_21_REG                   0x55
+#define SP_TX_VIDEO_BIT_CTRL_22_REG                   0x56
+#define SP_TX_VIDEO_BIT_CTRL_23_REG                   0x57
+#define SP_TX_VIDEO_BIT_CTRL_24_REG                   0x58
+#define SP_TX_VIDEO_BIT_CTRL_25_REG                   0x59
+#define SP_TX_VIDEO_BIT_CTRL_26_REG                   0x5a
+#define SP_TX_VIDEO_BIT_CTRL_27_REG                   0x5b
+#define SP_TX_VIDEO_BIT_CTRL_28_REG                   0x5c
+#define SP_TX_VIDEO_BIT_CTRL_29_REG                   0x5d
+#define SP_TX_VIDEO_BIT_CTRL_30_REG                   0x5e
+#define SP_TX_VIDEO_BIT_CTRL_31_REG                   0x5f
+#define SP_TX_VIDEO_BIT_CTRL_32_REG                   0x60
+#define SP_TX_VIDEO_BIT_CTRL_33_REG                   0x61
+#define SP_TX_VIDEO_BIT_CTRL_34_REG                   0x62
+#define SP_TX_VIDEO_BIT_CTRL_35_REG                   0x63
+#define SP_TX_VIDEO_BIT_CTRL_36_REG                   0x64
+#define SP_TX_VIDEO_BIT_CTRL_37_REG                   0x65
+#define SP_TX_VIDEO_BIT_CTRL_38_REG                   0x66
+#define SP_TX_VIDEO_BIT_CTRL_39_REG                   0x67
+#define SP_TX_VIDEO_BIT_CTRL_40_REG                   0x68
+#define SP_TX_VIDEO_BIT_CTRL_41_REG                   0x69
+#define SP_TX_VIDEO_BIT_CTRL_42_REG                   0x6a
+#define SP_TX_VIDEO_BIT_CTRL_43_REG                   0x6b
+#define SP_TX_VIDEO_BIT_CTRL_44_REG                   0x6c
+#define SP_TX_VIDEO_BIT_CTRL_45_REG                   0x6d
+#define SP_TX_VIDEO_BIT_CTRL_46_REG                   0x6e
+#define SP_TX_VIDEO_BIT_CTRL_47_REG                   0x6f
+
+//AVI info frame
+#define SP_TX_AVI_TYPE              0x70
+#define SP_TX_AVI_VER               0x71
+#define SP_TX_AVI_LEN               0x72
+#define SP_TX_AVI_DB0		     0x73
+#define SP_TX_AVI_DB1               0x74
+#define SP_TX_AVI_DB2               0x75
+#define SP_TX_AVI_DB3               0x76
+#define SP_TX_AVI_DB4               0x77
+#define SP_TX_AVI_DB5               0x78
+#define SP_TX_AVI_DB6               0x79
+#define SP_TX_AVI_DB7               0x7A
+#define SP_TX_AVI_DB8               0x7B
+#define SP_TX_AVI_DB9               0x7C
+#define SP_TX_AVI_DB10              0x7D
+#define SP_TX_AVI_DB11              0x7E
+#define SP_TX_AVI_DB12              0x7F
+#define SP_TX_AVI_DB13              0x80
+#define SP_TX_AVI_DB14              0x81
+#define SP_TX_AVI_DB15              0x82
+
+//Audio info frame
+#define SP_TX_AUD_TYPE			 0x83
+#define SP_TX_AUD_VER			 0x84
+#define SP_TX_AUD_LEN			 0x85
+#define SP_TX_AUD_DB0			 0x86
+#define SP_TX_AUD_DB1			 0x87
+#define SP_TX_AUD_DB2			 0x88
+#define SP_TX_AUD_DB3			 0x89
+#define SP_TX_AUD_DB4			 0x8A
+#define SP_TX_AUD_DB5			 0x8B
+#define SP_TX_AUD_DB6			 0x8C
+#define SP_TX_AUD_DB7			 0x8D
+#define SP_TX_AUD_DB8			 0x8E
+#define SP_TX_AUD_DB9			 0x8F
+#define SP_TX_AUD_DB10			 0x90
+
+//SPD info frame
+#define SP_TX_SPD_TYPE                0x91
+#define SP_TX_SPD_VER                 0x92
+#define SP_TX_SPD_LEN                 0x93
+#define SP_TX_SPD_DATA0		0x94
+#define SP_TX_SPD_DATA1               0x95
+#define SP_TX_SPD_DATA2               0x96
+#define SP_TX_SPD_DATA3               0x97
+#define SP_TX_SPD_DATA4               0x98
+#define SP_TX_SPD_DATA5               0x99
+#define SP_TX_SPD_DATA6               0x9A
+#define SP_TX_SPD_DATA7               0x9B
+#define SP_TX_SPD_DATA8               0x9C
+#define SP_TX_SPD_DATA9               0x9D
+#define SP_TX_SPD_DATA10              0x9E
+#define SP_TX_SPD_DATA11              0x9F
+#define SP_TX_SPD_DATA12              0xA0
+#define SP_TX_SPD_DATA13              0xA1
+#define SP_TX_SPD_DATA14              0xA2
+#define SP_TX_SPD_DATA15              0xA3
+#define SP_TX_SPD_DATA16              0xA4
+#define SP_TX_SPD_DATA17              0xA5
+#define SP_TX_SPD_DATA18              0xA6
+#define SP_TX_SPD_DATA19              0xA7
+#define SP_TX_SPD_DATA20              0xA8
+#define SP_TX_SPD_DATA21              0xA9
+#define SP_TX_SPD_DATA22              0xAA
+#define SP_TX_SPD_DATA23              0xAB
+#define SP_TX_SPD_DATA24              0xAC
+#define SP_TX_SPD_DATA25              0xAD
+#define SP_TX_SPD_DATA26              0xAE
+#define SP_TX_SPD_DATA27              0xAF
+
+//Mpeg source info frame
+#define SP_TX_MPEG_TYPE               0xB0
+#define SP_TX_MPEG_VER                0xB1
+#define SP_TX_MPEG_LEN                0xB2
+#define SP_TX_MPEG_DATA0              0xB3
+#define SP_TX_MPEG_DATA1              0xB4
+#define SP_TX_MPEG_DATA2              0xB5
+#define SP_TX_MPEG_DATA3              0xB6
+#define SP_TX_MPEG_DATA4              0xB7
+#define SP_TX_MPEG_DATA5              0xB8
+#define SP_TX_MPEG_DATA6              0xB9
+#define SP_TX_MPEG_DATA7              0xBA
+#define SP_TX_MPEG_DATA8              0xBB
+#define SP_TX_MPEG_DATA9              0xBC
+#define SP_TX_MPEG_DATA10             0xBD
+#define SP_TX_MPEG_DATA11            0xBE
+#define SP_TX_MPEG_DATA12            0xBF
+#define SP_TX_MPEG_DATA13            0xC0
+#define SP_TX_MPEG_DATA14            0xC1
+#define SP_TX_MPEG_DATA15            0xC2
+#define SP_TX_MPEG_DATA16            0xC3
+#define SP_TX_MPEG_DATA17            0xC4
+#define SP_TX_MPEG_DATA18            0xC5
+#define SP_TX_MPEG_DATA19            0xC6
+#define SP_TX_MPEG_DATA20            0xC7
+#define SP_TX_MPEG_DATA21            0xC8
+#define SP_TX_MPEG_DATA22            0xC9
+#define SP_TX_MPEG_DATA23            0xCA
+#define SP_TX_MPEG_DATA24            0xCB
+#define SP_TX_MPEG_DATA25            0xCC
+#define SP_TX_MPEG_DATA26            0xCD
+#define SP_TX_MPEG_DATA27            0xCE
+
+//#define GNSS_CTRL_REG				0xCD
+//#define ENABLE_SSC_FILTER			0x80//bit
+
+//#define SSC_D_VALUE					 0xD0
+//#define SSC_CTRL_REG2					 0xD1
+
+#define ANALOG_DEBUG_REG1			0xDC
+#define ANALOG_SEL_BG				0x40//bit 4
+#define ANALOG_SWING_A_30PER		0x08//bit 3
+
+#define ANALOG_DEBUG_REG2			0xDD
+#define ANALOG_24M_SEL				0x08//bit 3
+//#define ANALOG_FILTER_ENABLED		0x10//bit 4
+
+
+#define ANALOG_DEBUG_REG3			0xDE
+
+#define PLL_FILTER_CTRL1			0xDF
+#define PD_RING_OSC					0x40//bit 6
+
+#define PLL_FILTER_CTRL2			0xE0
+#define PLL_FILTER_CTRL3			0xE1
+#define PLL_FILTER_CTRL4			0xE2
+#define PLL_FILTER_CTRL5			0xE3
+#define PLL_FILTER_CTRL6			0xE4
+
+#define SP_TX_I2S_CTRL			0xE6
+#define SP_TX_I2S_FMT			0xE7
+#define SP_TX_I2S_CH_Status1			0xD0
+#define SP_TX_I2S_CH_Status2			0xD1
+#define SP_TX_I2S_CH_Status3			0xD2
+#define SP_TX_I2S_CH_Status4			0xD3
+#define SP_TX_I2S_CH_Status5			0xD4
+
+//interrupt
+#define SP_COMMON_INT_STATUS1     0xF1
+#define SP_COMMON_INT1_PLL_LOCK_CHG 	0x40//bit position
+#define SP_COMMON_INT1_VIDEO_FORMAT_CHG 0x08//bit position
+#define SP_COMMON_INT1_AUDIO_CLK_CHG	0x04//bit position
+#define SP_COMMON_INT1_VIDEO_CLOCK_CHG  0x02//bit position
+
+
+#define SP_COMMON_INT_STATUS2	  0xF2
+#define SP_COMMON_INT2_AUTHCHG	  0x02 //bit position
+#define SP_COMMON_INT2_AUTHDONE	  0x01 //bit position
+
+#define SP_COMMON_INT_STATUS3	  0xF3
+#define SP_COMMON_INT3_AFIFO_UNDER	0x80//bit position
+#define SP_COMMON_INT3_AFIFO_OVER	0x40//bit position
+
+#define SP_COMMON_INT_STATUS4	    0xF4
+#define SP_COMMON_INT4_PLUG                0x01   // bit position
+#define SP_COMMON_INT4_ESYNC_ERR          0x10   // bit position
+#define SP_COMMON_INT4_HPDLOST		0x02   //bit position
+#define SP_COMMON_INT4_HPD_CHANGE   0x04   //bit position
+
+
+#define SP_TX_INT_STATUS1		  0xF7
+#define SP_TX_INT_STATUS1_HPD	  0x40 //bit position
+#define SP_TX_INT_STATUS1_TRAINING_Finish       0x20   // bit position
+#define SP_TX_INT_STATUS1_POLLING_ERR        0x10   // bit position
+
+#define SP_TX_INT_SINK_CHG		  0x08//bit position
+
+//interrupt mask
+#define SP_COMMON_INT_MASK1			  0xF8
+#define SP_COMMON_INT_MASK2			  0xF9
+#define SP_COMMON_INT_MASK3			  0xFA
+#define SP_COMMON_INT_MASK4			  0xFB
+#define SP_INT_MASK				0xFE
+#define SP_TX_INT_CTRL_REG            		0xFF
+//End for dev_addr 0x72 or 0x76
+
+/***************************************************************/
+/***************************************************************/
+
+//DPCD regs
+#define DPCD_DPCD_REV                                                0x00
+#define DPCD_MAX_LINK_RATE                                      0x01
+#define DPCD_MAX_LANE_COUNT                                   0x02
+#define DPCD_MAX_DOWNSPREAD                                  0x03
+#define DPCD_NORP                                                        0x04
+#define DPCD_DOWNSTREAMPORT_PRESENT                  0x05
+
+#define DPCD_RECEIVE_PORT0_CAP_0                        0x08
+#define DPCD_RECEIVE_PORT0_CAP_1                        0x09
+#define DPCD_RECEIVE_PORT0_CAP_2                        0x0a
+#define DPCD_RECEIVE_PORT0_CAP_3                        0x0b
+
+#define DPCD_LINK_BW_SET                                      0x00
+#define DPCD_LANE_COUNT_SET                                0x01
+#define DPCD_TRAINING_PATTERN_SET                     0x02
+#define DPCD_TRAINNIG_LANE0_SET                         0x03
+#define DPCD_TRAINNIG_LANE1_SET                         0x04
+#define DPCD_TRAINNIG_LANE2_SET                         0x05
+#define DPCD_TRAINNIG_LANE3_SET                         0x06
+#define DPCD_DOWNSPREAD_CTRL                            0x07
+
+#define DPCD_SINK_COUNT                                          0x00
+#define DPCD_DEVICE_SERVICE_IRQ_VECTOR              0x01
+#define DPCD_LANE0_1_STATUS                                   0x02
+#define DPCD_LANE2_3_STATUS                                   0x03
+#define DPCD_LANE_ALIGN_STATUS_UPDATED            0x04
+#define DPCD_SINK_STATUS                                          0x05
+#define DPCD_ADJUST_REQUEST_LANE0_1                     0x06
+#define DPCD_ADJUST_REQUEST_LANE2_3                     0x07
+#define DPCD_TRAINING_SCORE_LANE0                       0x08
+#define DPCD_TRAINING_SCORE_LANE1                       0x09
+#define DPCD_TRAINING_SCORE_LANE2                       0x0a
+#define DPCD_TRAINING_SCORE_LANE3                       0x0b
+
+#define DPCD_TEST_REQUEST                               0x18
+#define DPCD_TEST_LINK_RATE                             0x19
+
+#define DPCD_TEST_LANE_COUNT                            0x20
+
+#define DPCD_TEST_Response                              0x60
+#define TEST_ACK                                                  0x01
+#define DPCD_TEST_EDID_Checksum_Write                   0x04//bit position
+
+#define DPCD_TEST_EDID_Checksum                         0x61
+
+
+#define DPCD_SPECIFIC_INTERRUPT                               0x10
+#define DPCD_USER_COMM1                                             0x22//define for downstream HDMI Rx sense detection
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_tc101.c b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_tc101.c
new file mode 100644
index 000000000000..dd9191781dc7
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/i2c_tc101.c
@@ -0,0 +1,244 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * I2C
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+
+#define LCD_EXTERN_NAME			"i2c_tc101"
+
+static struct i2c_client *aml_tc101_i2c_client;
+static struct lcd_extern_config_t *ext_config;
+
+#define INIT_LEN        3
+static unsigned char i2c_init_table[][INIT_LEN] = {
+	//{0xff, 0xff, 20},//delay mark(20ms)
+	{0xf8, 0x30, 0xb2},
+	{0xf8, 0x33, 0xc2},
+	{0xf8, 0x31, 0xf0},
+	{0xf8, 0x40, 0x80},
+	{0xf8, 0x81, 0xec},
+	{0xff, 0xff, 0xff},//end mark
+};
+
+static int lcd_extern_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msg, 1);
+	if (ret < 0)
+		LCD_EXT_PR("i2c write failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+#if 0
+static int lcd_extern_i2c_read(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msgs[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = buff,
+		},
+		{
+			.addr = i2client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msgs, 2);
+	if (ret < 0)
+		LCD_EXT_PR("i2c read failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+#endif
+
+static int lcd_extern_reg_read(unsigned char reg, unsigned char *buf)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_reg_write(unsigned char reg, unsigned char value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_i2c_init(void)
+{
+	int i = 0, ending_flag = 0;
+	int ret = 0;
+
+	while (ending_flag == 0) {
+		if ((i2c_init_table[i][0] == 0xff) && (i2c_init_table[i][1] == 0xff)) { //special mark
+			if (i2c_init_table[i][2] == 0xff) //ending flag
+				ending_flag = 1;
+			else //delay flag
+				mdelay(i2c_init_table[i][2]);
+		} else {
+			lcd_extern_i2c_write(aml_tc101_i2c_client, i2c_init_table[i], INIT_LEN);
+		}
+		i++;
+	}
+	LCD_EXT_PR("%s: %s\n", __func__, ext_config->name);
+	return ret;
+}
+
+static int lcd_extern_i2c_remove(void)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_power_on(void)
+{
+	int ret;
+
+	ret = lcd_extern_i2c_init();
+	return ret;
+}
+
+static int lcd_extern_power_off(void)
+{
+	int ret;
+
+	ret = lcd_extern_i2c_remove();
+	return ret;
+}
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->reg_read  = lcd_extern_reg_read;
+		ext_drv->reg_write = lcd_extern_reg_write;
+		ext_drv->power_on  = lcd_extern_power_on;
+		ext_drv->power_off = lcd_extern_power_off;
+	} else {
+		LCD_EXT_PR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int aml_tc101_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		LCD_EXT_PR("[error] %s: functionality check failed\n", __func__);
+		return -ENODEV;
+	} else {
+		aml_tc101_i2c_client = client;
+	}
+
+	LCD_EXT_PR("%s OK\n", __func__);
+	return 0;
+}
+
+static int aml_tc101_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id aml_tc101_i2c_id[] = {
+	{LCD_EXTERN_NAME, 0},
+	{ }
+};
+// MODULE_DEVICE_TABLE(i2c, aml_tc101_id);
+
+static struct i2c_driver aml_tc101_i2c_driver = {
+	.probe    = aml_tc101_i2c_probe,
+	.remove   = aml_tc101_i2c_remove,
+	.id_table = aml_tc101_i2c_id,
+	.driver = {
+		.name = LCD_EXTERN_NAME,
+		.owner =THIS_MODULE,
+	},
+};
+
+int aml_lcd_extern_i2c_tc101_probe(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	struct i2c_board_info i2c_info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *i2c_client;
+	int ret = 0;
+
+	ext_config = &ext_drv->config;
+	memset(&i2c_info, 0, sizeof(i2c_info));
+
+	adapter = i2c_get_adapter(ext_drv->config.i2c_bus);
+	if (!adapter) {
+		LCD_EXT_PR("%s failed to get i2c adapter\n", ext_drv->config.name);
+		return -1;
+	}
+
+	strncpy(i2c_info.type, ext_drv->config.name, I2C_NAME_SIZE);
+	i2c_info.addr = ext_drv->config.i2c_addr;
+	i2c_info.platform_data = &ext_drv->config;
+	i2c_info.flags = 0;
+	if (i2c_info.addr > 0x7f) {
+		LCD_EXT_PR("%s invalid i2c address: 0x%02x\n", ext_drv->config.name, ext_drv->config.i2c_addr);
+		return -1;
+	}
+	i2c_client = i2c_new_device(adapter, &i2c_info);
+	if (!i2c_client) {
+		LCD_EXT_PR("%s failed to new i2c device\n", ext_drv->config.name);
+		return -1;
+	} else {
+		DBG_PRINT("%s new i2c device succeed\n", ext_drv->config.name);
+	}
+
+	if (!aml_tc101_i2c_client) {
+		ret = i2c_add_driver(&aml_tc101_i2c_driver);
+		if (ret) {
+			LCD_EXT_PR("%s add i2c_driver failed\n", ext_drv->config.name);
+			return -1;
+		}
+	}
+
+	ret = lcd_extern_driver_update(ext_drv);
+
+	DBG_PRINT("%s: %d\n", __func__, ret);
+	return ret;
+}
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c b/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c
new file mode 100644
index 000000000000..492bf6452c3f
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c
@@ -0,0 +1,495 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <mach/am_regs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+
+#ifdef CONFIG_USE_OF
+static struct device_node *lcd_extern_node;
+#endif
+static int lcd_ext_driver_num;
+static struct aml_lcd_extern_driver_t *lcd_ext_driver[LCD_EXT_DRIVER_MAX];
+
+struct aml_lcd_extern_driver_t *aml_lcd_extern_get_driver(int index)
+{
+	int i;
+	struct aml_lcd_extern_driver_t *ext_driver = NULL;
+
+	if (index >= LCD_EXTERN_INDEX_INVALID) {
+		LCD_EXT_PR("invalid driver index %d\n", index);
+		return NULL;
+	}
+	for (i = 0; i < lcd_ext_driver_num; i++) {
+		if (lcd_ext_driver[i]->config.index == index) {
+			ext_driver = lcd_ext_driver[i];
+			break;
+		}
+	}
+	if (ext_driver == NULL)
+		LCD_EXT_PR("invalid driver index %d\n", index);
+	return ext_driver;
+}
+
+#if 0
+static struct aml_lcd_extern_driver_t *aml_lcd_extern_get_driver_by_name(char *name)
+{
+	int i;
+	struct aml_lcd_extern_driver_t *ext_driver = NULL;
+
+	for (i = 0; i < lcd_ext_driver_num; i++) {
+		if (strcmp(lcd_ext_driver[i]->config.name, name) == 0) {
+			ext_driver = lcd_ext_driver[i];
+			break;
+		}
+	}
+	if (ext_driver == NULL)
+		LCD_EXT_PR("invalid driver index %d\n", index);
+	return ext_driver;
+}
+#endif
+
+#ifdef CONFIG_USE_OF
+struct device_node *aml_lcd_extern_get_dt_child(int index)
+{
+	char propname[30];
+	struct device_node* child;
+
+	sprintf(propname, "extern_%d", index);
+	child = of_get_child_by_name(lcd_extern_node, propname);
+	return child;
+}
+
+static int aml_lcd_extern_get_dt_config(struct device_node *of_node, struct lcd_extern_config_t *econfig)
+{
+	int err;
+	int val;
+	const char *str;
+
+	err = of_property_read_u32(of_node, "index", &econfig->index);
+	if (err) {
+		LCD_EXT_PR("get index failed, exit\n");
+		return -1;
+	}
+
+	err = of_property_read_string(of_node, "extern_name", &str);
+	if (err) {
+		str = "none";
+		LCD_EXT_PR("get extern_name failed\n");
+	}
+	strcpy(econfig->name, str);
+	LCD_EXT_PR("load config in dtb: %s[%d]\n", econfig->name, econfig->index);
+
+	err = of_property_read_u32(of_node, "type", &econfig->type);
+	if (err) {
+		econfig->type = LCD_EXTERN_MAX;
+		LCD_EXT_PR("error: get type failed, exit\n");
+		return -1;
+	}
+
+	switch (econfig->type) {
+	case LCD_EXTERN_I2C:
+		err = of_property_read_u32(of_node, "i2c_address", &econfig->i2c_addr);
+		if (err) {
+			LCD_EXT_PR("get %s i2c_address failed, exit\n", econfig->name);
+			econfig->i2c_addr = 0;
+			return -1;
+		}
+		DBG_PRINT("%s i2c_address=0x%02x\n", econfig->name, econfig->i2c_addr);
+
+		err = of_property_read_string(of_node, "i2c_bus", &str);
+		if (err) {
+			LCD_EXT_PR("get %s i2c_bus failed, exit\n", econfig->name);
+			econfig->i2c_bus = AML_I2C_MASTER_A;
+			return -1;
+		} else {
+			if (strncmp(str, "i2c_bus_a", 9) == 0)
+				econfig->i2c_bus = AML_I2C_MASTER_A;
+			else if (strncmp(str, "i2c_bus_b", 9) == 0)
+				econfig->i2c_bus = AML_I2C_MASTER_B;
+			else if (strncmp(str, "i2c_bus_c", 9) == 0)
+				econfig->i2c_bus = AML_I2C_MASTER_C;
+			else if (strncmp(str, "i2c_bus_d", 9) == 0)
+				econfig->i2c_bus = AML_I2C_MASTER_D;
+			else if (strncmp(str, "i2c_bus_ao", 10) == 0)
+				econfig->i2c_bus = AML_I2C_MASTER_AO;
+			else
+				econfig->i2c_bus = AML_I2C_MASTER_A;
+		}
+		DBG_PRINT("%s i2c_bus=%s[%d]\n", econfig->name, str, econfig->i2c_bus);
+		break;
+	case LCD_EXTERN_SPI:
+		err = of_property_read_string(of_node, "gpio_spi_cs", &str);
+		if (err) {
+			LCD_EXT_PR("get %s gpio_spi_cs failed, exit\n", econfig->name);
+			econfig->spi_cs = -1;
+			return -1;
+		} else {
+			val = amlogic_gpio_name_map_num(str);
+			if (val > 0) {
+				err = lcd_ext_gpio_request(val);
+				if (err)
+					LCD_EXT_PR("faild to alloc spi_cs gpio (%s)\n", str);
+				econfig->spi_cs = val;
+				DBG_PRINT("spi_cs gpio = %s(%d)\n", str, econfig->spi_cs);
+			} else {
+				econfig->spi_cs = -1;
+			}
+		}
+		err = of_property_read_string(of_node, "gpio_spi_clk", &str);
+		if (err) {
+			LCD_EXT_PR("get %s gpio_spi_clk failed, exit\n", econfig->name);
+			econfig->spi_clk = -1;
+			return -1;
+		} else {
+			val = amlogic_gpio_name_map_num(str);
+			if (val > 0) {
+				err = lcd_ext_gpio_request(val);
+				if (err)
+					LCD_EXT_PR("faild to alloc spi_clk gpio (%s)\n", str);
+				econfig->spi_clk = val;
+				DBG_PRINT("spi_clk gpio = %s(%d)\n", str, econfig->spi_clk);
+			} else {
+				econfig->spi_clk = -1;
+			}
+		}
+		err = of_property_read_string(of_node, "gpio_spi_data", &str);
+		if (err) {
+			LCD_EXT_PR("get %s gpio_spi_data failed, exit\n", econfig->name);
+			econfig->spi_data = -1;
+			return -1;
+		} else {
+			val = amlogic_gpio_name_map_num(str);
+			if (val > 0) {
+				err = lcd_ext_gpio_request(val);
+				if (err)
+					LCD_EXT_PR("faild to alloc spi_data gpio (%s)\n", str);
+				econfig->spi_data = val;
+				DBG_PRINT("spi_data gpio = %s(%d)\n", str, econfig->spi_data);
+			} else {
+				econfig->spi_data = -1;
+			}
+		}
+		break;
+	case LCD_EXTERN_MIPI:
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+static int aml_lcd_extern_add_i2c(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (strcmp(ext_drv->config.name, "i2c_T5800Q") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_T5800Q
+		ret = aml_lcd_extern_i2c_T5800Q_probe(ext_drv);
+#endif
+	} else if (strcmp(ext_drv->config.name, "i2c_tc101") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_TC101
+		ret = aml_lcd_extern_i2c_tc101_probe(ext_drv);
+#endif
+	} else if (strcmp(ext_drv->config.name, "i2c_anx6345") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_ANX6345
+		ret = aml_lcd_extern_i2c_anx6345_probe(ext_drv);
+#endif
+	} else {
+		LCD_EXT_PR("invalid driver name: %s\n", ext_drv->config.name);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int aml_lcd_extern_add_spi(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (strcmp(ext_drv->config.name, "spi_LD070WS2") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_SPI_LD070WS2
+		ret = aml_lcd_extern_spi_LD070WS2_probe(ext_drv);
+#endif
+	} else {
+		LCD_EXT_PR("invalid driver name: %s\n", ext_drv->config.name);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int aml_lcd_extern_add_mipi(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (strcmp(ext_drv->config.name, "mipi_N070ICN") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_MIPI_N070ICN
+		ret = aml_lcd_extern_mipi_N070ICN_probe(ext_drv);
+#endif
+	} else if (strcmp(ext_drv->config.name, "mipi_KD080D13") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_MIPI_KD080D13
+		ret = aml_lcd_extern_mipi_KD080D13_probe(ext_drv);
+#endif
+	} else {
+		LCD_EXT_PR("invalid driver name: %s\n", ext_drv->config.name);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int aml_lcd_extern_add_invalid(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	return -1;
+}
+
+static int aml_lcd_extern_add_driver(struct lcd_extern_config_t *econfig)
+{
+	struct aml_lcd_extern_driver_t *ext_drv;
+	int ret = 0;
+
+	if (lcd_ext_driver_num >= LCD_EXT_DRIVER_MAX) {
+		LCD_EXT_PR("driver num is too much\n");
+		return -1;
+	}
+	lcd_ext_driver[lcd_ext_driver_num] = kmalloc(sizeof(struct aml_lcd_extern_driver_t), GFP_KERNEL);
+	if (lcd_ext_driver[lcd_ext_driver_num] == NULL) {
+		LCD_EXT_PR("failed to alloc driver %s[%d], not enough memory\n", econfig->name, econfig->index);
+		return -1;
+	}
+
+	ext_drv = lcd_ext_driver[lcd_ext_driver_num];
+	/* fill config parameters */
+	ext_drv->config.index = econfig->index;
+	strcpy(ext_drv->config.name, econfig->name);
+	ext_drv->config.type = econfig->type;
+
+	/* fill config parameters by different type */
+	switch (ext_drv->config.type) {
+	case LCD_EXTERN_I2C:
+		ext_drv->config.i2c_addr = econfig->i2c_addr;
+		ext_drv->config.i2c_bus = econfig->i2c_bus;
+		ret = aml_lcd_extern_add_i2c(ext_drv);
+		break;
+	case LCD_EXTERN_SPI:
+		ext_drv->config.spi_cs = econfig->spi_cs;
+		ext_drv->config.spi_clk = econfig->spi_clk;
+		ext_drv->config.spi_data = econfig->spi_data;
+		ret = aml_lcd_extern_add_spi(ext_drv);
+		break;
+	case LCD_EXTERN_MIPI:
+		ret = aml_lcd_extern_add_mipi(ext_drv);
+		break;
+	default:
+		ret = aml_lcd_extern_add_invalid(ext_drv);
+		LCD_EXT_PR("don't support type %d\n", ext_drv->config.type);
+		break;
+	}
+	if (ret) {
+		LCD_EXT_PR("add driver failed\n");
+		kfree(lcd_ext_driver[lcd_ext_driver_num]);
+		lcd_ext_driver[lcd_ext_driver_num] = NULL;
+		return -1;
+	}
+	lcd_ext_driver_num++;
+	LCD_EXT_PR("add driver %s(%d)\n", ext_drv->config.name, ext_drv->config.index);
+	return 0;
+}
+
+//*********************************************************
+//debug function
+//*********************************************************
+static void aml_lcd_extern_config_dump(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	if (ext_drv == NULL)
+		return;
+
+	printk("    index:       %d\n"
+		"    name:        %s\n",
+		ext_drv->config.index, ext_drv->config.name);
+	switch (ext_drv->config.type) {
+	case LCD_EXTERN_I2C:
+		printk("    type:        i2c(%d)\n", ext_drv->config.type);
+		printk("    i2c_addr:    0x%02x\n"
+			"    i2c_bus:     %d\n",
+			ext_drv->config.i2c_addr, ext_drv->config.i2c_bus);
+		break;
+	case LCD_EXTERN_SPI:
+		printk("    type:        spi(%d)\n", ext_drv->config.type);
+		printk("    spi_cs:      %d\n"
+			"    spi_clk:     %d\n"
+			"    spi_data:    %d\n",
+			ext_drv->config.spi_cs, ext_drv->config.spi_clk, ext_drv->config.spi_data);
+		break;
+	case LCD_EXTERN_MIPI:
+		printk("    type:        mipi(%d)\n", ext_drv->config.type);
+		break;
+	default:
+		break;
+	}
+	printk("\n");
+}
+
+static const char * lcd_extern_debug_usage_str = {
+"Usage:\n"
+"    echo index <n> > info ; dump specified index driver config\n"
+"    echo all > info ; dump all driver config\n"
+};
+
+static ssize_t lcd_extern_debug_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", lcd_extern_debug_usage_str);
+}
+
+static ssize_t lcd_extern_info_dump(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	int i, index;
+	struct aml_lcd_extern_driver_t *ext_drv;
+
+	index = LCD_EXTERN_INDEX_INVALID;
+	switch (buf[0]) {
+	case 'i':
+		ret = sscanf(buf, "index %d", &index);
+		ext_drv = aml_lcd_extern_get_driver(index);
+		aml_lcd_extern_config_dump(ext_drv);
+		break;
+	case 'a':
+		for (i = 0; i < lcd_ext_driver_num; i++)
+			aml_lcd_extern_config_dump(lcd_ext_driver[i]);
+		break;
+	default:
+		LCD_EXT_PR("don't support command\n");
+		break;
+	}
+
+	if (ret != 1 || ret !=2)
+		return -EINVAL;
+
+	return count;
+}
+
+static struct class_attribute lcd_extern_class_attrs[] = {
+	__ATTR(info, S_IRUGO | S_IWUSR, lcd_extern_debug_help, lcd_extern_info_dump),
+};
+
+static struct class *debug_class;
+static int creat_lcd_extern_class(void)
+{
+	int i;
+
+	debug_class = class_create(THIS_MODULE, "lcd_ext");
+	if (IS_ERR(debug_class)) {
+		LCD_EXT_PR("create debug class failed\n");
+		return -1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(lcd_extern_class_attrs); i++) {
+		if (class_create_file(debug_class, &lcd_extern_class_attrs[i]))
+			LCD_EXT_PR("create debug attribute %s failed\n", lcd_extern_class_attrs[i].attr.name);
+	}
+
+	return 0;
+}
+
+static int remove_lcd_extern_class(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lcd_extern_class_attrs); i++)
+		class_remove_file(debug_class, &lcd_extern_class_attrs[i]);
+
+	class_destroy(debug_class);
+	debug_class = NULL;
+
+	return 0;
+}
+//*********************************************************
+
+static int aml_lcd_extern_probe(struct platform_device *pdev)
+{
+	struct device_node *child;
+	struct lcd_extern_config_t ext_config;
+	int ret = 0;
+
+	lcd_ext_driver_num = 0;
+#ifdef CONFIG_USE_OF
+	lcd_extern_node = pdev->dev.of_node;
+	for_each_child_of_node(lcd_extern_node, child) {
+		ret = aml_lcd_extern_get_dt_config(child, &ext_config);
+		if (ret == 0)
+			aml_lcd_extern_add_driver(&ext_config);
+	}
+#endif
+	creat_lcd_extern_class();
+
+	LCD_EXT_PR("%s ok\n", __func__);
+	return ret;
+}
+
+static int aml_lcd_extern_remove(struct platform_device *pdev)
+{
+	int i;
+
+	remove_lcd_extern_class();
+	for (i = 0; i < lcd_ext_driver_num; i++) {
+		kfree(lcd_ext_driver[i]);
+		lcd_ext_driver[i] = NULL;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_lcd_extern_dt_match[] = {
+	{
+		.compatible = "amlogic,lcd_extern",
+	},
+	{},
+};
+#endif
+
+static struct platform_driver aml_lcd_extern_driver = {
+	.probe  = aml_lcd_extern_probe,
+	.remove = aml_lcd_extern_remove,
+	.driver = {
+		.name  = "lcd_extern",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+		.of_match_table = aml_lcd_extern_dt_match,
+#endif
+	},
+};
+
+static int __init aml_lcd_extern_init(void)
+{
+	int ret;
+	DBG_PRINT("%s\n", __func__);
+
+	ret = platform_driver_register(&aml_lcd_extern_driver);
+	if (ret) {
+		LCD_EXT_PR("lcd_extern: [error] lcd_extern_driver register failed\n");
+		return -ENODEV;
+	}
+	return ret;
+}
+
+static void __exit aml_lcd_extern_exit(void)
+{
+	platform_driver_unregister(&aml_lcd_extern_driver);
+}
+
+module_init(aml_lcd_extern_init);
+module_exit(aml_lcd_extern_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD extern driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.h b/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.h
new file mode 100644
index 000000000000..333bbaf6f7e6
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.h
@@ -0,0 +1,49 @@
+
+#ifndef _LCD_EXTERN_H_
+#define _LCD_EXTERN_H_
+#include <linux/of.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/pinctrl/consumer.h>
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(format, arg...)        printk("lcd extern: " format, ## arg)
+#else
+#define DBG_PRINT(format, arg...)
+#endif
+#define LCD_EXT_PR(format, arg...)        printk("lcd extern: " format, ## arg)
+
+#define LCD_EXTERN_DRIVER		"lcd_extern"
+
+#define lcd_ext_gpio_request(gpio)			amlogic_gpio_request(gpio, LCD_EXTERN_DRIVER)
+#define lcd_ext_gpio_free(gpio)				amlogic_gpio_free(gpio, LCD_EXTERN_DRIVER)
+#define lcd_ext_gpio_direction_input(gpio)		amlogic_gpio_direction_input(gpio, LCD_EXTERN_DRIVER)
+#define lcd_ext_gpio_direction_output(gpio, val)	amlogic_gpio_direction_output(gpio, val, LCD_EXTERN_DRIVER)
+#define lcd_ext_gpio_get_value(gpio)			amlogic_get_value(gpio, LCD_EXTERN_DRIVER)
+#define lcd_ext_gpio_set_value(gpio,val)		amlogic_set_value(gpio, val, LCD_EXTERN_DRIVER)
+
+#ifdef CONFIG_USE_OF
+extern struct device_node *aml_lcd_extern_get_dt_child(int index);
+#endif
+
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_T5800Q
+extern int aml_lcd_extern_i2c_T5800Q_probe(struct aml_lcd_extern_driver_t *ext_drv);
+#endif
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_TC101
+extern int aml_lcd_extern_i2c_tc101_probe(struct aml_lcd_extern_driver_t *ext_drv);
+#endif
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_ANX6345
+extern int aml_lcd_extern_i2c_anx6345_probe(struct aml_lcd_extern_driver_t *ext_drv);
+#endif
+#ifdef CONFIG_AML_LCD_EXTERN_SPI_LD070WS2
+extern int aml_lcd_extern_spi_LD070WS2_probe(struct aml_lcd_extern_driver_t *ext_drv);
+#endif
+#ifdef CONFIG_AML_LCD_EXTERN_MIPI_N070ICN
+extern int aml_lcd_extern_mipi_N070ICN_probe(struct aml_lcd_extern_driver_t *ext_drv);
+#endif
+#ifdef CONFIG_AML_LCD_EXTERN_MIPI_KD080D13
+extern int aml_lcd_extern_mipi_KD080D13_probe(struct aml_lcd_extern_driver_t *ext_drv);
+#endif
+
+#endif
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/mipi_KD080D13.c b/drivers/amlogic/display/lcd/aml_lcd_extern/mipi_KD080D13.c
new file mode 100644
index 000000000000..c9776341620f
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/mipi_KD080D13.c
@@ -0,0 +1,111 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * MIPI
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+
+#define LCD_EXTERN_NAME			"mipi_KD080D13"
+
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
+static unsigned char mipi_init_on_table[] = {
+	0x39,3,0xf0,0x5a,0x5a,
+	0x39,3,0xf1,0x5a,0x5a,
+	0x39,3,0xfc,0xa5,0xa5,
+	0x39,3,0xd0,0x00,0x10,
+	0x15,2,0xb1,0x10,
+	0x39,5,0xb2,0x14,0x22,0x2f,0x04,
+	0x39,6,0xf2,0x02,0x08,0x08,0x40,0x10,
+	0x15,2,0xb0,0x03,
+	0x39,3,0xfd,0x23,0x09,
+	0x39,11,0xf3,0x01,0x93,0x20,0x22,0x80,0x05,0x25,0x3c,0x26,0x00,
+	0x39,46,0xf4,0x00,0x02,0x03,0x26,0x03,0x02,0x09,0x00,0x07,0x16,0x16,0x03,0x00,0x08,0x08,0x03,0x0E,0x0F,0x12,0x1C,0x1D,0x1E,0x0C,0x09,0x01,0x04,0x02,0x61,0x74,0x75,0x72,0x83,0x80,0x80,0xB0,0x00,0x01,0x01,0x28,0x04,0x03,0x28,0x01,0xD1,0x32,
+	0x39,27,0xf5,0x84,0x2F,0x2F,0x5F,0xAB,0x98,0x52,0x0F,0x33,0x43,0x04,0x59,0x54,0x52,0x05,0x40,0x60,0x4E,0x60,0x40,0x27,0x26,0x52,0x25,0x6D,0x18,
+	0x39,9,0xee,0x25,0x00,0x25,0x00,0x25,0x00,0x25,0x00,
+	0x39,9,0xef,0x34,0x12,0x98,0xBA,0x20,0x00,0x24,0x80,
+	0x39,33,0xf7,0x0E,0x0E,0x0A,0x0A,0x0F,0x0F,0x0B,0x0B,0x05,0x07,0x01,0x01,0x01,0x01,0x01,0x01,0x0C,0x0C,0x08,0x08,0x0D,0x0D,0x09,0x09,0x04,0x06,0x01,0x01,0x01,0x01,0x01,0x01,
+	0x39,4,0xbc,0x01,0x4e,0x0a,
+	0x39,6,0xe1,0x03,0x10,0x1c,0xa0,0x10,
+	0x39,7,0xf6,0x60,0x21,0xA6,0x00,0x00,0x00,
+	0x39,7,0xfe,0x00,0x0D,0x03,0x21,0x80,0x48,
+	0x15,2,0xb0,0x22,
+	0x39,18,0xfa,0x02,0x34,0x09,0x13,0x0B,0x0F,0x16,0x16,0x17,0x1E,0x1D,0x1C,0x1E,0x1D,0x1D,0x1F,0x24,
+	0x15,2,0xb0,0x22,
+	0x39,18,0xfb,0x00,0x34,0x07,0x11,0x09,0x0D,0x14,0x14,0x15,0x1C,0x1F,0x1C,0x1D,0x1D,0x1D,0x20,0x26,
+	0x15,2,0xb0,0x11,
+	0x39,18,0xfa,0x20,0x34,0x24,0x27,0x19,0x1B,0x1F,0x1E,0x1B,0x1F,0x21,0x1F,0x1E,0x20,0x1E,0x1E,0x21,
+	0x15,2,0xb0,0x11,
+	0x39,18,0xfb,0x1E,0x34,0x22,0x25,0x17,0x19,0x1D,0x1A,0x19,0x20,0x1F,0x1E,0x20,0x1E,0x1E,0x1F,0x22,
+	0x39,18,0xfa,0x1C,0x34,0x1C,0x1F,0x13,0x17,0x1A,0x18,0x18,0x1E,0x20,0x21,0x21,0x21,0x23,0x22,0x2A,
+	0x39,18,0xfb,0x1A,0x34,0x1A,0x1D,0x11,0x15,0x18,0x16,0x16,0x1C,0x20,0x20,0x20,0x1F,0x23,0x23,0x2B,
+
+	0x05,1,0x11,
+	0xff,20,
+	0x39,4,0xc3,0x40,0x00,0x28,
+	0xff,200,
+	0x15,2,0x35,0x00,
+	0x05,1,0x29,
+	0xff,30,     //delay 30ms
+	0xff,0xff,   //ending flag
+};
+
+static unsigned char mipi_init_off_table[] = {
+	0x05,1,0x28, //display off
+	0xff,30,     //delay 30ms
+	0x05,1,0x10, //sleep in
+	0xff,30,     //delay 30ms
+	0x39,4,0xc3,0x40,0x00,0x20,
+	0xff,10,
+	0xff,0xff,   //ending flag
+};
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->init_on_cmd_8  = &mipi_init_on_table[0];
+		ext_drv->init_off_cmd_8 = &mipi_init_off_table[0];
+	} else {
+		LCD_EXT_PR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+int aml_lcd_extern_mipi_KD080D13_probe(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	ret = lcd_extern_driver_update(ext_drv);
+
+	DBG_PRINT("%s: %d\n", __func__, ret);
+	return ret;
+}
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/mipi_N070ICN.c b/drivers/amlogic/display/lcd/aml_lcd_extern/mipi_N070ICN.c
new file mode 100644
index 000000000000..b92a7991c31a
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/mipi_N070ICN.c
@@ -0,0 +1,234 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * MIPI
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+
+#define LCD_EXTERN_NAME			"mipi_N070ICN"
+
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
+static unsigned char mipi_init_on_table[] = {
+	0x39,5,0xFF,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========
+
+	0x39,3,0x6F,0x11,0x00, //MIPI related Timing Setting
+	0x39,3,0xF7,0x20,0x00,
+
+	0x15,2,0x6F,0x06,      //Improve ESD option
+	0x15,2,0xF7,0xA0,
+	0x15,2,0x6F,0x19,
+	0x15,2,0xF7,0x12,
+
+	0x15,2,0x6F,0x08,     //Vcom floating
+	0x15,2,0xFA,0x40,
+	0x15,2,0x6F,0x11,
+	0x15,2,0xF3,0x01,
+
+	0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========
+	0x15,2,0xC8,0x80,
+
+	0x39,3,0xB1,0x6C,0x01, //Set WXGA resolution
+
+	0x15,2,0xB6,0x08,      //Set source output hold time
+
+	0x15,2,0x6F,0x02,      //EQ control function
+	0x15,2,0xB8,0x08,
+
+	0x39,3,0xBB,0x54,0x54, //Set bias current for GOP and SOP
+
+	0x39,3,0xBC,0x05,0x05, //Inversion setting
+
+	0x15,2,0xC7,0x01,      //zigzag setting
+
+	0x39,6,0xBD,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST
+
+	0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========
+
+	0x39,3,0xB0,0x05,0x05,                // Setting AVDD, AVEE clamp
+	0x39,3,0xB1,0x05,0x05,
+
+	0x39,3,0xBC,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
+	0x39,3,0xBD,0x3E,0x01,
+
+	0x15,2,0xCA,0x00,                    // gate signal control
+
+	0x15,2,0xC0,0x04,                    // power IC control
+	0x15,2,0xB2,0x00,
+	0x15,2,0xBE,0x80,      //vcom    -1.88V
+
+	0x39,3,0xB3,0x19,0x19, // Setting VGH=15V, VGL=-11V
+	0x39,3,0xB4,0x12,0x12,
+
+	0x39,3,0xB9,0x24,0x24, // power control for VGH, VGL
+	0x39,3,0xBA,0x14,0x14,
+
+	0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========
+
+	0x15,2,0xEE,0x01,                     //Gamma setting
+	0x39,5,0xEF,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage
+
+	0x39,7,0xB0,0x00,0x00,0x00,0x08,0x00,0x17, //========== GOA relative ==========
+	0x15,2,0x6F,0x06,
+	0x39,7,0xB0,0x00,0x25,0x00,0x30,0x00,0x45,
+	0x15,2,0x6F,0x0C,
+	0x39,5,0xB0,0x00,0x56,0x00,0x7A,
+	0x39,7,0xB1,0x00,0xA3,0x00,0xE7,0x01,0x20, ////////////////////////////
+	0x15,2,0x6F,0x06,
+	0x39,7,0xB1,0x01,0x7A,0x01,0xC2,0x01,0xC5,
+	0x15,2,0x6F,0x0C,
+	0x39,5,0xB1,0x02,0x06,0x02,0x5F,
+	0x39,7,0xB2,0x02,0x92,0x02,0xD0,0x02,0xFC,
+	0x15,2,0x6F,0x06,
+	0x39,7,0xB2,0x03,0x35,0x03,0x5D,0x03,0x8B,
+	0x15,2,0x6F,0x0C,
+	0x39,5,0xB2,0x03,0xA2,0x03,0xBF,
+	0x39,5,0xB3,0x03,0xD2,0x03,0xFF,
+
+	0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x06,      //PAGE6 : GOUT Mapping, VGLO select
+	0x39,3,0xB0,0x00,0x17,
+	0x39,3,0xB1,0x16,0x15,
+	0x39,3,0xB2,0x14,0x13,
+	0x39,3,0xB3,0x12,0x11,
+	0x39,3,0xB4,0x10,0x2D,
+	0x39,3,0xB5,0x01,0x08,
+	0x39,3,0xB6,0x09,0x31,
+	0x39,3,0xB7,0x31,0x31,
+	0x39,3,0xB8,0x31,0x31,
+	0x39,3,0xB9,0x31,0x31,
+	0x39,3,0xBA,0x31,0x31,
+	0x39,3,0xBB,0x31,0x31,
+	0x39,3,0xBC,0x31,0x31,
+	0x39,3,0xBD,0x31,0x09,
+	0x39,3,0xBE,0x08,0x01,
+	0x39,3,0xBF,0x2D,0x10,
+	0x39,3,0xC0,0x11,0x12,
+	0x39,3,0xC1,0x13,0x14,
+	0x39,3,0xC2,0x15,0x16,
+	0x39,3,0xC3,0x17,0x00,
+	0x39,3,0xE5,0x31,0x31,
+	0x39,3,0xC4,0x00,0x17,
+	0x39,3,0xC5,0x16,0x15,
+	0x39,3,0xC6,0x14,0x13,
+	0x39,3,0xC7,0x12,0x11,
+	0x39,3,0xC8,0x10,0x2D,
+	0x39,3,0xC9,0x01,0x08,
+	0x39,3,0xCA,0x09,0x31,
+	0x39,3,0xCB,0x31,0x31,
+	0x39,3,0xCC,0x31,0x31,
+	0x39,3,0xCD,0x31,0x31,
+	0x39,3,0xCE,0x31,0x31,
+	0x39,3,0xCF,0x31,0x31,
+	0x39,3,0xD0,0x31,0x31,
+	0x39,3,0xD1,0x31,0x09,
+	0x39,3,0xD2,0x08,0x01,
+	0x39,3,0xD3,0x2D,0x10,
+	0x39,3,0xD4,0x11,0x12,
+	0x39,3,0xD5,0x13,0x14,
+	0x39,3,0xD6,0x15,0x16,
+	0x39,3,0xD7,0x17,0x00,
+	0x39,3,0xE6,0x31,0x31,
+	0x39,6,0xD8,0x00,0x00,0x00,0x00,0x00, //VGL level select;
+	0x39,6,0xD9,0x00,0x00,0x00,0x00,0x00,
+	0x15,2,0xE7,0x00,
+
+	0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x03, //===page 3====//gate timing control
+	0x39,3,0xB0,0x20,0x00,
+	0x39,3,0xB1,0x20,0x00,
+	0x39,6,0xB2,0x05,0x00,0x42,0x00,0x00,
+	0x39,6,0xB6,0x05,0x00,0x42,0x00,0x00,
+	0x39,6,0xBA,0x53,0x00,0x42,0x00,0x00,
+	0x39,6,0xBB,0x53,0x00,0x42,0x00,0x00,
+	0x15,2,0xC4,0x40,
+
+	0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x05, //===page 5====//
+	0x39,3,0xB0,0x17,0x06,
+	0x15,2,0xB8,0x00,
+	0x39,6,0xBD,0x03,0x01,0x01,0x00,0x01,
+	0x39,3,0xB1,0x17,0x06,
+	0x39,3,0xB9,0x00,0x01,
+	0x39,3,0xB2,0x17,0x06,
+	0x39,3,0xBA,0x00,0x01,
+	0x39,3,0xB3,0x17,0x06,
+	0x39,3,0xBB,0x0A,0x00,
+	0x39,3,0xB4,0x17,0x06,
+	0x39,3,0xB5,0x17,0x06,
+	0x39,3,0xB6,0x14,0x03,
+	0x39,3,0xB7,0x00,0x00,
+	0x39,3,0xBC,0x02,0x01,
+	0x15,2,0xC0,0x05,
+	0x15,2,0xC4,0xA5,
+	0x39,3,0xC8,0x03,0x30,
+	0x39,3,0xC9,0x03,0x51,
+	0x39,6,0xD1,0x00,0x05,0x03,0x00,0x00,
+	0x39,6,0xD2,0x00,0x05,0x09,0x00,0x00,
+	0x15,2,0xE5,0x02,
+	0x15,2,0xE6,0x02,
+	0x15,2,0xE7,0x02,
+	0x15,2,0xE9,0x02,
+	0x15,2,0xED,0x33,
+
+	0x05,1,0x11, //sleep out
+	0xff,30,     //delay 30ms
+	0x05,1,0x29, //display on
+	0xff,30,     //delay 30ms
+	0xff,0xff,   //ending flag
+};
+
+static unsigned char mipi_init_off_table[] = {
+	0x05,1,0x28, //display off
+	0xff,10,     //delay 10ms
+	0x05,1,0x10, //sleep in
+	0xff,10,     //delay 10ms
+	0xff,0xff,   //ending flag
+};
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->init_on_cmd_8  = &mipi_init_on_table[0];
+		ext_drv->init_off_cmd_8 = &mipi_init_off_table[0];
+	} else {
+		LCD_EXT_PR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+int aml_lcd_extern_mipi_N070ICN_probe(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	ret = lcd_extern_driver_update(ext_drv);
+
+	DBG_PRINT("%s: %d\n", __func__, ret);
+	return ret;
+}
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/spi_LD070WS2.c b/drivers/amlogic/display/lcd/aml_lcd_extern/spi_LD070WS2.c
new file mode 100644
index 000000000000..35bde2b93619
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/spi_LD070WS2.c
@@ -0,0 +1,209 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * SPI
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "lcd_extern.h"
+
+#define LCD_EXTERN_NAME			"spi_LD070WS2"
+
+#define SPI_DELAY		30 //unit: us
+
+static struct lcd_extern_config_t *ext_config;
+
+static unsigned char spi_init_table[][2] = {
+	{0x00,0x21},  //reset
+	{0x00,0xa5},  //standby
+	{0x01,0x30},  //enable FRC/Dither
+	{0x02,0x40},  //enable normally black
+	{0x0e,0x5f},  //enable test mode1
+	{0x0f,0xa4},  //enable test mode2
+	{0x0d,0x00},  //enable SDRRS, enlarge OE width
+	{0x02,0x43},  //adjust charge sharing time
+	{0x0a,0x28},  //trigger bias reduction
+	{0x10,0x41},  //adopt 2 line/1 dot
+	{0xff,50},    //delay 50ms
+	{0x00,0xad},  //display on
+	{0xff,0xff},  //ending flag
+};
+
+static unsigned char spi_off_table[][2] = {
+	{0x00,0xa5},  //standby
+	{0xff,0xff},
+};
+
+static void lcd_extern_set_csb(unsigned v)
+{
+	lcd_ext_gpio_direction_output(ext_config->spi_cs, v);
+	udelay(SPI_DELAY);
+}
+
+static void lcd_extern_set_scl(unsigned v)
+{
+	lcd_ext_gpio_direction_output(ext_config->spi_clk, v);
+	udelay(SPI_DELAY);
+}
+
+static void lcd_extern_set_sda(unsigned v)
+{
+	lcd_ext_gpio_direction_output(ext_config->spi_data, v);
+	udelay(SPI_DELAY);
+}
+
+static void spi_gpio_init(void)
+{
+	lcd_extern_set_csb(1);
+	lcd_extern_set_scl(1);
+	lcd_extern_set_sda(1);
+}
+
+static void spi_gpio_off(void)
+{
+	lcd_extern_set_sda(0);
+	lcd_extern_set_scl(0);
+	lcd_extern_set_csb(0);
+}
+
+static void spi_write_8(unsigned char addr, unsigned char data)
+{
+	int i;
+	unsigned int sdata;
+
+	sdata = (unsigned int)(addr & 0x3f);
+	sdata <<= 10;
+	sdata |= (data & 0xff);
+	sdata &= ~(1<<9); //write flag
+
+	lcd_extern_set_csb(1);
+	lcd_extern_set_scl(1);
+	lcd_extern_set_sda(1);
+
+	lcd_extern_set_csb(0);
+	for (i = 0; i < 16; i++) {
+		lcd_extern_set_scl(0);
+		if (sdata & 0x8000)
+			lcd_extern_set_sda(1);
+		else
+			lcd_extern_set_sda(0);
+		sdata <<= 1;
+		lcd_extern_set_scl(1);
+	}
+
+	lcd_extern_set_csb(1);
+	lcd_extern_set_scl(1);
+	lcd_extern_set_sda(1);
+	udelay(SPI_DELAY);
+}
+
+static int lcd_extern_spi_init(void)
+{
+	int ending_flag = 0;
+	int i=0;
+
+	spi_gpio_init();
+
+	while (ending_flag == 0) {
+		if (spi_init_table[i][0] == 0xff) {
+			if (spi_init_table[i][1] == 0xff)
+				ending_flag = 1;
+			else
+				mdelay(spi_init_table[i][1]);
+		} else {
+			spi_write_8(spi_init_table[i][0], spi_init_table[i][1]);
+		}
+		i++;
+	}
+	LCD_EXT_PR("%s: %s\n", __func__, ext_config->name);
+
+	return 0;
+}
+
+static int lcd_extern_spi_off(void)
+{
+	int ending_flag = 0;
+	int i = 0;
+
+	spi_gpio_init();
+
+	while (ending_flag == 0) {
+		if (spi_off_table[i][0] == 0xff) {
+			if (spi_off_table[i][1] == 0xff)
+				ending_flag = 1;
+			else
+				mdelay(spi_off_table[i][1]);
+		} else {
+			spi_write_8(spi_off_table[i][0], spi_off_table[i][1]);
+		}
+		i++;
+	}
+	mdelay(10);
+	spi_gpio_off();
+	LCD_EXT_PR("%s: %s\n", __func__, ext_config->name);
+
+	return 0;
+}
+
+static int lcd_extern_power_on(void)
+{
+	int ret;
+
+	ret = lcd_extern_spi_init();
+	return ret;
+}
+
+static int lcd_extern_power_off(void)
+{
+	int ret;
+
+	ret = lcd_extern_spi_off();
+	return ret;
+}
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->power_on  = lcd_extern_power_on;
+		ext_drv->power_off = lcd_extern_power_off;
+	} else {
+		LCD_EXT_PR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+int aml_lcd_extern_spi_LD070WS2_probe(struct aml_lcd_extern_driver_t *ext_drv)
+{
+	int ret = 0;
+
+	ext_config = &ext_drv->config;
+	ret = lcd_extern_driver_update(ext_drv);
+
+	DBG_PRINT("%s: %d\n", __func__, ret);
+	return ret;
+}
+
diff --git a/drivers/amlogic/display/lcd/aml_lcd_tv.c b/drivers/amlogic/display/lcd/aml_lcd_tv.c
index 88ab10a2762a..10ac897e7073 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_tv.c
+++ b/drivers/amlogic/display/lcd/aml_lcd_tv.c
@@ -30,9 +30,13 @@
 #include <linux/amlogic/aml_gpio_consumer.h>
 #include <mach/register.h>
 #include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/amlogic/display/lcd.h>
+#ifdef CONFIG_AML_LCD_EXTERN
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#endif
 
 #include "aml_lcd_tv.h"
 #include "aml_tv_lcd_port/lcd_common.h"
@@ -225,6 +229,9 @@ static const vinfo_t *get_valid_vinfo(char *mode)
 	return vinfo;
 }
 
+//******************************************************
+//debug function
+//******************************************************
 static ssize_t tv_lcd_spread_show(struct class *class,
 	struct class_attribute *attr, char *buf)
 {
@@ -248,12 +255,230 @@ static ssize_t tv_lcd_spread_stroe(struct class *cls,
 	return count;
 }
 
-static const char * lcd_usage_str =
-{"Usage:\n"
+static const char * lcd_usage_str = {"Usage:\n"
 "    echo test <num> > debug ; bist pattern test, 0=pattern off, 1~7=different pattern\n"
 "    echo fr_type <type> > debug ; set frame_rate change type: 0=hotal adjust, 1=clock adjust\n"
+"    echo info > debug; dump lcd parameters\n"
+"    echo reg > debug; dump lcd regs\n"
+"    echo status > debug; dump lcd status\n"
+"    echo dump > debug; dump all lcd information\n"
 };
 
+static void tv_lcd_timing_info_print(void)
+{
+	unsigned int hs_width, hs_bp, h_period;
+	unsigned int vs_width, vs_bp, v_period;
+	unsigned int video_on_pixel, video_on_line;
+	unsigned int sync_start, sync_end;
+
+	video_on_pixel = pDev->pConf->lcd_basic.video_on_pixel;
+	video_on_line = pDev->pConf->lcd_basic.video_on_line;
+	h_period = pDev->pConf->lcd_basic.h_period;
+	v_period = pDev->pConf->lcd_basic.v_period;
+
+	sync_start = pDev->pConf->lcd_timing.sth1_hs_addr;
+	sync_end = pDev->pConf->lcd_timing.sth1_he_addr;
+	hs_width = sync_end - sync_start;
+	hs_bp = video_on_pixel - sync_end;
+
+	sync_start = pDev->pConf->lcd_timing.stv1_vs_addr;
+	sync_end = pDev->pConf->lcd_timing.stv1_ve_addr;
+	vs_width = sync_end - sync_start;
+	vs_bp = video_on_line - sync_end;
+
+	printk("h_period          %d\n"
+	   "v_period          %d\n"
+	   "hs_width          %d\n"
+	   "hs_backporch      %d\n"
+	   "vs_width          %d\n"
+	   "vs_backporch      %d\n"
+	   "video_on_pixel    %d\n"
+	   "video_on_line     %d\n\n",
+	   h_period, v_period, hs_width, hs_bp, vs_width, vs_bp,
+	   video_on_pixel, video_on_line);
+}
+
+static void tv_lcd_info_parameters(void)
+{
+	unsigned int lcd_clk;
+	unsigned int sync_duration;
+
+	printk("lcd: parameters info:\n");
+
+	lcd_clk = (pDev->pConf->lcd_timing.lcd_clk / 1000);
+	sync_duration = lcd_info[lcd_output_mode].sync_duration_num;
+	sync_duration = (sync_duration * 10 / lcd_info[lcd_output_mode].sync_duration_den);
+	printk("LCD mode: %s, %s, %ux%u@%u.%uHz\n"
+	   "fr_adj_type       %d\n"
+	   "lcd_clk           %u.%03uMHz\n\n",
+	   pDev->pConf->lcd_basic.model_name,
+	   lcd_type_table[pDev->pConf->lcd_basic.lcd_type],
+	   pDev->pConf->lcd_basic.h_active, pDev->pConf->lcd_basic.v_active,
+	   (sync_duration / 10), (sync_duration % 10),
+	   pDev->pConf->lcd_timing.frame_rate_adj_type,
+	   (lcd_clk / 1000), (lcd_clk % 1000));
+
+	tv_lcd_timing_info_print();
+
+	switch (pDev->pConf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		printk("lvds_bits         %u\n"
+		   "lvds_repack       %u\n"
+		   "pn_swap           %u\n"
+		   "dual_port         %u\n"
+		   "port_reverse      %u\n"
+		   "lvds_fifo_wr_mode %u\n\n",
+		   pDev->pConf->lcd_control.lvds_config->lvds_bits,
+		   pDev->pConf->lcd_control.lvds_config->lvds_repack,
+		   pDev->pConf->lcd_control.lvds_config->pn_swap,
+		   pDev->pConf->lcd_control.lvds_config->dual_port,
+		   pDev->pConf->lcd_control.lvds_config->port_reverse,
+		   pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
+		break;
+	case LCD_DIGITAL_VBYONE:
+		printk("lane_count        %u\n"
+		   "byte_mode         %u\n"
+		   "region            %u\n\n",
+		   pDev->pConf->lcd_control.vbyone_config->lane_count,
+		   pDev->pConf->lcd_control.vbyone_config->byte_mode,
+		   pDev->pConf->lcd_control.vbyone_config->region);
+		break;
+	default:
+		break;
+	}
+
+	printk("power gpio        %d\n"
+	   "power on_value    %d\n"
+	   "power off_value   %d\n"
+	   "power on_delay    %d\n"
+	   "power off_delay   %d\n\n",
+	   pDev->pConf->lcd_power_ctrl.panel_power->gpio,
+	   pDev->pConf->lcd_power_ctrl.panel_power->on_value,
+	   pDev->pConf->lcd_power_ctrl.panel_power->off_value,
+	   pDev->pConf->lcd_power_ctrl.panel_power->panel_on_delay,
+	   pDev->pConf->lcd_power_ctrl.panel_power->panel_off_delay);
+#ifdef CONFIG_AML_LCD_EXTERN
+	printk("extern index      %d\n"
+	   "extern on_delay   %d\n"
+	   "extern off_delay  %d\n\n",
+	   pDev->pConf->lcd_control.ext_config->index,
+	   pDev->pConf->lcd_control.ext_config->on_delay,
+	   pDev->pConf->lcd_control.ext_config->off_delay);
+#endif
+}
+
+static void tv_lcd_reg_dump(void)
+{
+	unsigned int reg_start, reg_end, count, reg;
+	int i;
+
+	printk("lcd: reg dump:\n");
+
+	/* clk setting: cbus */
+	printk("clock regs:\n");
+	reg_start = HHI_HDMI_PLL_CNTL;
+	reg_end = HHI_HDMI_PLL_CNTL6;
+	count = reg_end - reg_start;
+	for (i = 0; i <= count; i++) {
+		reg = reg_start + i;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	}
+	reg = HHI_VID_PLL_CLK_DIV;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	reg = HHI_VID_CLK_DIV;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	reg = HHI_VID_CLK_CNTL;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	reg = HHI_VIID_CLK_DIV;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	reg = HHI_VIID_CLK_CNTL;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	reg = HHI_VID_CLK_CNTL2;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	printk("\n");
+
+	/* encl setting: vcbus */
+	printk("encl regs:\n");
+	reg_start = ENCL_VIDEO_EN;
+	reg_end = ENCL_MAX_LINE_SWITCH_POINT;
+	count = reg_end - reg_start;
+	for (i = 0; i <= count; i++) {
+		reg = reg_start + i;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_REG(reg));
+	}
+	reg = VPU_VIU_VENC_MUX_CTRL;
+	printk("0x%04x = 0x%08x\n", reg, READ_LCD_REG(reg));
+	printk("\n");
+
+	/* interface controller setting */
+	switch (pDev->pConf->lcd_basic.lcd_type) {
+	case LCD_DIGITAL_LVDS:
+		printk("lvds regs:\n");
+		reg = HHI_LVDS_TX_PHY_CNTL0;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+		reg = HHI_LVDS_TX_PHY_CNTL1;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+		reg = LVDS_GEN_CNTL;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_REG(reg));
+		reg = LVDS_PACK_CNTL_ADDR;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_REG(reg));
+		printk("\n");
+
+		reg_start = LVDS_PHY_CNTL0;
+		reg_end = LVDS_PHY_CNTL4;
+		count = reg_end - reg_start;
+		for (i = 0; i <= count; i++) {
+			reg = reg_start + i;
+			printk("0x%04x = 0x%08x\n", reg, READ_LCD_REG(reg));
+		}
+		printk("\n");
+		break;
+	case LCD_DIGITAL_VBYONE:
+		printk("vbyone regs:\n");
+		reg_start = VBO_CTRL_L;
+		reg_end = LCD_PORT_SWAP;
+		count = reg_end - reg_start;
+		for (i = 0; i <= count; i++) {
+			reg = reg_start + i;
+			printk("0x%04x = 0x%08x\n", reg, READ_LCD_REG(reg));
+		}
+		printk("\n");
+
+		printk("pinmux & gpio regs:\n");
+		reg = PERIPHS_PIN_MUX_7;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+		reg_start = PREG_PAD_GPIO1_EN_N;
+		reg_end = PREG_PAD_GPIO1_I;
+		count = reg_end - reg_start;
+		for (i = 0; i <= count; i++) {
+			reg = reg_start + i;
+			printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+		}
+		printk("\n");
+	default:
+		break;
+	}
+
+	/* phy setting: cbus */
+	printk("phy regs:\n");
+	reg_start = HHI_DIF_CSI_PHY_CNTL1;
+	reg_end = HHI_DIF_CSI_PHY_CNTL3;
+	count = reg_end - reg_start;
+	for (i = 0; i <= count; i++) {
+		reg = reg_start + i;
+		printk("0x%04x = 0x%08x\n", reg, READ_LCD_CBUS_REG(reg));
+	}
+	printk("\n");
+}
+
+static void tv_lcd_status_dump(void)
+{
+	unsigned int status;
+
+	status = aml_read_reg32(P_ENCL_VIDEO_EN);
+	printk("lcd: status: %s\n", (status ? "ON" : "OFF"));
+}
+
 static ssize_t tv_lcd_debug_show(struct class *class,
 	struct class_attribute *attr, char *buf)
 {
@@ -283,6 +508,12 @@ static ssize_t tv_lcd_debug_store(struct class *cls,
 	if (argn < 1 || argn > LCD_ARG_NUM)
 		goto end;
 
+	if (pDev == NULL) {
+		printk("lcd: [error]: no lcd device, exit\n");
+		kfree(buf_work);
+		return -EINVAL;
+	}
+
 	cmd = argv[0][0];
 	switch (cmd) {
 	case 't':
@@ -298,6 +529,24 @@ static ssize_t tv_lcd_debug_store(struct class *cls,
 		pDev->pConf->lcd_timing.frame_rate_adj_type = (unsigned char)value;
 		printk("change lcd frame rate change type: %d\n", value);
 		break;
+	case 'i':
+		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		tv_lcd_info_parameters();
+		break;
+	case 'r':
+		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		tv_lcd_reg_dump();
+		break;
+	case 's':
+		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		tv_lcd_status_dump();
+		break;
+	case 'd':
+		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		tv_lcd_info_parameters();
+		tv_lcd_reg_dump();
+		tv_lcd_status_dump();
+		break;
 	default:
 		goto end;
 	}
@@ -312,6 +561,7 @@ end:
 
 static CLASS_ATTR(spread, S_IWUSR | S_IRUGO, tv_lcd_spread_show, tv_lcd_spread_stroe);
 static CLASS_ATTR(debug, S_IWUSR | S_IRUGO, tv_lcd_debug_show, tv_lcd_debug_store);
+//******************************************************
 
 #ifdef CONFIG_USE_OF
 static inline int aml_lcd_get_property_string(struct device_node *np,
@@ -352,6 +602,9 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	struct aml_lcd_platdata *pd;
 	Lcd_Config_t *plcd_config;
 	Panel_Power_Config_t *ppanel_power_config;
+#ifdef CONFIG_AML_LCD_EXTERN
+	struct lcd_extern_config_s *ext_conf;
+#endif
 
 	pd = kmalloc(sizeof(struct aml_lcd_platdata), GFP_KERNEL);
 	if (pd == NULL) {
@@ -376,6 +629,16 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	memset(ppanel_power_config, 0, sizeof(*ppanel_power_config));
 	pd->pConf->lcd_power_ctrl.panel_power = ppanel_power_config;
 
+#ifdef CONFIG_AML_LCD_EXTERN
+	ext_conf = kmalloc(sizeof(struct lcd_extern_config_s), GFP_KERNEL);
+	if (ext_conf == NULL) {
+		TV_LCD_ERR("plcd_config ext_conf Not enough memory\n");
+		return NULL;
+	}
+	memset(ext_conf, 0, sizeof(*ext_conf));
+	pd->pConf->lcd_control.ext_config = ext_conf;
+#endif
+
 	lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*20, GFP_KERNEL);
 	if (lcd_para == NULL) {
 		kfree(pd);
@@ -387,7 +650,8 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	memset(lcd_para, 0, sizeof(*lcd_para));
 
 	if (of_node) {
-		child = of_get_child_by_name(of_node,lcd_propname);
+		pd->pConf->lcd_basic.model_name = lcd_propname;
+		child = of_get_child_by_name(of_node, lcd_propname);
 		if (child == NULL) {
 			kfree(lcd_para);
 			kfree(pd);
@@ -551,7 +815,19 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 		} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
 
 		}
+
+#ifdef CONFIG_AML_LCD_EXTERN
+		if (aml_lcd_get_property_array(child, "lcd_extern_att", &lcd_para[0], 3)) {
+			ext_conf->index = LCD_EXTERN_INDEX_INVALID;
+			ext_conf->on_delay = 0;
+			ext_conf->off_delay = 0;
+		} else {
+			ext_conf->index = lcd_para[0];
+			ext_conf->on_delay = lcd_para[1];
+			ext_conf->off_delay = lcd_para[2];
+		}
 	}
+#endif
 
 	TV_LCD_INFO("lcd_type = %s(%s)\n", lcd_type_table[pd->pConf->lcd_basic.lcd_type],lcd_propname);
 	TV_LCD_INFO("h_active = %u, v_active = %u \n", pd->pConf->lcd_basic.h_active, pd->pConf->lcd_basic.v_active);
@@ -586,6 +862,13 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	} else if (pd->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
 
 	}
+#ifdef CONFIG_AML_LCD_EXTERN
+	if (pd->pConf->lcd_control.ext_config->index < LCD_EXTERN_INDEX_INVALID) {
+		TV_LCD_INFO("lcd_extern index = %d \n",pd->pConf->lcd_control.ext_config->index);
+		TV_LCD_INFO("lcd_extern on_delay = %d \n",pd->pConf->lcd_control.ext_config->on_delay);
+		TV_LCD_INFO("lcd_extern off_delay = %d \n",pd->pConf->lcd_control.ext_config->off_delay);
+	}
+#endif
 
 	kfree(lcd_para);
 
@@ -606,8 +889,12 @@ static void panel_power_ctrl(Bool_t status)
 {
 	const char *owner = "aml_tv_lcd";
 	Lcd_Config_t *pConf;
-	pConf = pDev->pConf;
+#ifdef CONFIG_AML_LCD_EXTERN
+	struct aml_lcd_extern_driver_t *ext_drv;
+	int index;
+#endif
 
+	pConf = pDev->pConf;
 	TV_LCD_INFO("statu=%s gpio=%d value=%d \n",(status ? "ON" : "OFF"),
 		pConf->lcd_power_ctrl.panel_power->gpio,
 		(status ?pConf->lcd_power_ctrl.panel_power->on_value:
@@ -618,7 +905,27 @@ static void panel_power_ctrl(Bool_t status)
 		amlogic_gpio_direction_output(pConf->lcd_power_ctrl.panel_power->gpio,
 			pConf->lcd_power_ctrl.panel_power->on_value,owner);
 		mdelay(pConf->lcd_power_ctrl.panel_power->panel_on_delay);
+#ifdef CONFIG_AML_LCD_EXTERN
+		index = pConf->lcd_control.ext_config->index;
+		if (index < LCD_EXTERN_INDEX_INVALID) {
+			ext_drv = aml_lcd_extern_get_driver(index);
+			if (ext_drv)
+				ext_drv->power_on();
+			if (pConf->lcd_control.ext_config->on_delay > 0)
+				mdelay(pConf->lcd_control.ext_config->on_delay);
+		}
+#endif
 	} else {
+#ifdef CONFIG_AML_LCD_EXTERN
+		index = pConf->lcd_control.ext_config->index;
+		if (index < LCD_EXTERN_INDEX_INVALID) {
+			if (pConf->lcd_control.ext_config->off_delay > 0)
+				mdelay(pConf->lcd_control.ext_config->off_delay);
+			ext_drv = aml_lcd_extern_get_driver(index);
+			if (ext_drv)
+				ext_drv->power_off();
+		}
+#endif
 		mdelay(pConf->lcd_power_ctrl.panel_power->panel_off_delay);
 		amlogic_gpio_request(pConf->lcd_power_ctrl.panel_power->gpio,owner);
 		amlogic_gpio_direction_output(pConf->lcd_power_ctrl.panel_power->gpio,
@@ -689,6 +996,11 @@ static int lcd_vmode_change(int index)
 static void _lcd_module_enable(void)
 {
 	printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+	if (pDev == NULL) {
+		printk("lcd: [error]: no lcd device, exit\n");
+		return;
+	}
+
 	lcd_vmode_change(lcd_output_mode);
 	_init_display_driver(pDev);
 }
@@ -700,7 +1012,6 @@ static const vinfo_t *lcd_get_current_info(void)
 	return &lcd_info[lcd_output_mode];
 }
 
-/* static unsigned int first_init = 0; */
 static int lcd_set_current_vmode(vmode_t mode)
 {
 	unsigned int ret = 0;
@@ -708,13 +1019,7 @@ static int lcd_set_current_vmode(vmode_t mode)
 	mutex_lock(&lcd_vout_mutex);
 /*	printk("initcall %s mode = %d\n", __func__, (mode & VMODE_MODE_BIT_MASK)); */
 	lcd_output_mode = get_lcd_vmode(mode & VMODE_MODE_BIT_MASK);
-/*	if (first_init == 0) {
-		first_init = 1;
-		printk("skip %s when first enter kernel\n", __func__);
-		mutex_unlock(&lcd_vout_mutex);
-		return ret;
-	}
-*/
+
 	if (!(mode & VMODE_LOGO_BIT_MASK)) {
 		switch (mode & VMODE_MODE_BIT_MASK) {
 		case VMODE_1080P:
@@ -925,7 +1230,6 @@ static int lcd_probe(struct platform_device *pdev)
 
 	lcd_function_probe(pDev);
 
-	/* first_init = 0; */
 	TV_LCD_INFO("LCD probe ok\n");
 
 	return 0;
diff --git a/drivers/amlogic/display/lcd/aml_lcd_tv.h b/drivers/amlogic/display/lcd/aml_lcd_tv.h
index 4ec5b8e2d1b8..bf4b2f51aca5 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_tv.h
+++ b/drivers/amlogic/display/lcd/aml_lcd_tv.h
@@ -25,15 +25,17 @@
 #define AML_TV_LCD_H
 
 #include <linux/amlogic/vout/vinfo.h>
+#ifdef CONFIG_AML_LCD_EXTERN
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#endif
 
-#define LCD_TV_DRIVER_VERSION        "20150914"
+#define LCD_TV_DRIVER_VERSION        "20150916"
 
 typedef enum {
     OFF = 0,
     ON = 1,
 } Bool_t;
 
-
 typedef enum {
 	LCD_DIGITAL_LVDS = 0,
 	LCD_DIGITAL_VBYONE,
@@ -155,15 +157,20 @@ typedef struct {
     unsigned int bit_rate;
 } Vbyone_Config_t;
 
+#ifdef CONFIG_AML_LCD_EXTERN
+struct lcd_extern_config_s {
+	unsigned int index;
+	unsigned int on_delay;
+	unsigned int off_delay;
+};
+#endif
+
 typedef struct {
 	Lvds_Config_t *lvds_config;
 	Vbyone_Config_t *vbyone_config;
-
-	//TTL_Config_t *ttl_config;
-	//DSI_Config_t *mipi_config;
-	//EDP_Config_t *edp_config;
-	//MLVDS_Config_t *mlvds_config;
-	//MLVDS_Tcon_Config_t *mlvds_tcon_config;
+#ifdef CONFIG_AML_LCD_EXTERN
+	struct lcd_extern_config_s *ext_config;
+#endif
 } Lcd_Control_Config_t;
 
 //****panel power control only for uboot ***//
diff --git a/drivers/amlogic/display/vout/Makefile b/drivers/amlogic/display/vout/Makefile
index e4ba43c61caf..5ec890a1c9fb 100644
--- a/drivers/amlogic/display/vout/Makefile
+++ b/drivers/amlogic/display/vout/Makefile
@@ -12,6 +12,5 @@ tvout-objs += enc_clk_config.o
 endif
 endif
 obj-$(CONFIG_AML_LCD_TABLET)		+= lcdoutc.o
-obj-$(CONFIG_AML_LCD_TABLET)		+= lcd_extern/
 
 #EXTRA_CFLAGS += -DCONFIG_PM
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
old mode 100755
new mode 100644
index b4947f48ebf7..beb91c902ddd
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -210,7 +210,8 @@
                     0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_KD079D1>
@@ -261,7 +262,8 @@
                     0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAA101FP05XG>
@@ -312,7 +314,8 @@
                     0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_LD070WX4>
@@ -374,7 +377,8 @@
                     0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<0>;  /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_N070ICN>
@@ -419,7 +423,8 @@
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<1>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HSD101PUW1>
@@ -463,7 +468,8 @@
         dsi_init_on=<0x32 0  //turn on peripheral
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_LT070ME05>
@@ -525,7 +531,8 @@
                     0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_KD080D13>
@@ -570,7 +577,8 @@
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
         dsi_init_on=<0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        lcd_extern_init=<1>;    /** lcd extern init command control(0=disable, 1=enable) */
+
+        lcd_extern_index=<0>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //******************************************************************************
@@ -603,6 +611,7 @@
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<4>; /** max lane count supported */
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_LM270WQ1_SDA2>
@@ -632,6 +641,7 @@
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<4>; /** max lane count supported */
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_B140XTN02>
@@ -661,6 +671,7 @@
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<1>; /** max lane count supported */
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 	
 //$$ MATCH "lcd_model_config_match" = <&lcd_B140RTN02>
@@ -690,6 +701,7 @@
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<1>; /** max lane count supported */
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 	
 //$$ MATCH "lcd_model_config_match" = <&lcd_LP097QX2>
@@ -719,6 +731,7 @@
 		pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
  
 		max_lane_count=<4>; /** max lane count supported */
+		lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
 	};
 
 //******************************************************************************
@@ -748,6 +761,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<3 27>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAA070WP03>
@@ -774,6 +789,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HE070IA>
@@ -800,6 +817,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_EJ070NA>
@@ -826,6 +845,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HJ080IA>
@@ -852,6 +873,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HJ101NA>
@@ -878,6 +901,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_TM081JFH01>
@@ -904,6 +929,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HSD101PWW1>
@@ -930,6 +957,8 @@
         hsync_width_backporch=<5 115>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 30>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_KD101N4>
@@ -956,6 +985,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HM185WX3>
@@ -982,6 +1013,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_LD070WS2>
@@ -1010,7 +1043,7 @@
         vsync_width_backporch=<2 23>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
-        lcd_extern_init=<1>;/** lcd extern init command control(0=disable, 1=enable) */
+        lcd_extern_index=<0>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_IVO785H4026172>
@@ -1037,6 +1070,8 @@
         hsync_width_backporch=<10 70>; /** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 21>;  /** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;    /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 //******************************************************************************
 //Interface: ttl
@@ -1065,6 +1100,8 @@
         hsync_width_backporch=<10 160>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_TN070TN92>
@@ -1091,6 +1128,8 @@
         hsync_width_backporch=<10 36>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_KR070PB2S>
@@ -1117,6 +1156,8 @@
         hsync_width_backporch=<20 26>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HE050NA01F>
@@ -1143,6 +1184,8 @@
         hsync_width_backporch=<10 36>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //$$ MATCH "lcd_model_config_match" = <&lcd_HSD043I9W1>
@@ -1169,6 +1212,8 @@
         hsync_width_backporch=<5 35>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 6>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 //******************************************************************************
@@ -1198,6 +1243,8 @@
         hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
         vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        lcd_extern_index=<0xff>;    /** lcd extern index(0xff=invalid, assigned by user) */
     };
 
 #endif
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
index 4239e4cbdad1..e735bd372446 100644
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -46,7 +46,9 @@
 #include <linux/reboot.h>
 #include <linux/of.h>
 #include <linux/amlogic/aml_lcd_bl.h>
+#ifdef CONFIG_AML_LCD_EXTERN
 #include <linux/amlogic/vout/aml_lcd_extern.h>
+#endif
 #ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
 #include <linux/amlogic/aml_pmu_common.h>
 #endif
@@ -168,7 +170,10 @@ static int lcd_power_ctrl(Bool_t status)
 #ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
 	struct aml_pmu_driver *pmu_driver;
 #endif
-	struct aml_lcd_extern_driver_t *lcd_extern_driver;
+#ifdef CONFIG_AML_LCD_EXTERN
+	struct aml_lcd_extern_driver_t *ext_drv;
+	int index;
+#endif
 
 	lcd_print("%s(): %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
 	if (status) {
@@ -209,16 +214,20 @@ static int lcd_power_ctrl(Bool_t status)
 						pDev->pConf->lcd_power_ctrl.ports_ctrl(ON);
 					break;
 				case LCD_POWER_TYPE_INITIAL:
-					lcd_extern_driver = aml_lcd_extern_get_driver();
-					if (lcd_extern_driver == NULL) {
-						printk("no lcd_extern driver\n");
-					}
-					else {
-						if (lcd_extern_driver->power_on) {
-							lcd_extern_driver->power_on();
-							printk("%s power on init\n", lcd_extern_driver->name);
+#ifdef CONFIG_AML_LCD_EXTERN
+					index = pDev->pConf->lcd_control.extern_index;
+					if (index < LCD_EXTERN_INDEX_INVALID) {
+						ext_drv = aml_lcd_extern_get_driver(index);
+						if (ext_drv == NULL) {
+							printk("no lcd_extern driver\n");
+						} else {
+							if (ext_drv->power_on) {
+								ext_drv->power_on();
+								printk("%s power on init\n", ext_drv->config.name);
+							}
 						}
 					}
+#endif
 					break;
 				default:
 					printk("lcd power ctrl ON step %d is null.\n", i+1);
@@ -273,16 +282,20 @@ static int lcd_power_ctrl(Bool_t status)
 						pDev->pConf->lcd_power_ctrl.ports_ctrl(OFF);
 					break;
 				case LCD_POWER_TYPE_INITIAL:
-					lcd_extern_driver = aml_lcd_extern_get_driver();
-					if (lcd_extern_driver == NULL) {
-						printk("no lcd_extern driver\n");
-					}
-					else {
-						if (lcd_extern_driver->power_off) {
-							lcd_extern_driver->power_off();
-							printk("%s power off init\n", lcd_extern_driver->name);
+#ifdef CONFIG_AML_LCD_EXTERN
+					index = pDev->pConf->lcd_control.extern_index;
+					if (index < LCD_EXTERN_INDEX_INVALID) {
+						ext_drv = aml_lcd_extern_get_driver(index);
+						if (ext_drv == NULL) {
+							printk("no lcd_extern driver\n");
+						} else {
+							if (ext_drv->power_off) {
+								ext_drv->power_off();
+								printk("%s power off init\n", ext_drv->config.name);
+							}
 						}
 					}
+#endif
 					break;
 				default:
 					printk("lcd power ctrl OFF step %d is null.\n", i+1);
@@ -1063,6 +1076,9 @@ static void read_current_lcd_config(Lcd_Config_t *pConf)
            "video_on_line     %d\n\n", 
            pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl,
            pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
+#ifdef CONFIG_AML_LCD_EXTERN
+    printk("lcd_extern_index  %d\n", pConf->lcd_control.extern_index);
+#endif
 }
 
 static void save_lcd_config(Lcd_Config_t *pConf)
@@ -1858,14 +1874,14 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
                     }
                 }
             }
-            ret = of_property_read_u32(lcd_model_node,"lcd_extern_init",&val);
-            if(ret){
-                printk("faild to get lcd_extern_init\n");
-                pConf->lcd_control.mipi_config->lcd_extern_init =0;
-            } else {
-                pConf->lcd_control.mipi_config->lcd_extern_init =(unsigned char)(val);
-            }
-            lcd_print("lcd_extern_init = %d\n",  pConf->lcd_control.mipi_config->lcd_extern_init);
+//            ret = of_property_read_u32(lcd_model_node,"lcd_extern_init",&val);
+//            if(ret){
+//                printk("faild to get lcd_extern_init\n");
+//                pConf->lcd_control.mipi_config->lcd_extern_init =0;
+//            } else {
+//                pConf->lcd_control.mipi_config->lcd_extern_init =(unsigned char)(val);
+//            }
+//            lcd_print("lcd_extern_init = %d\n",  pConf->lcd_control.mipi_config->lcd_extern_init);
         }
         else if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
             ret = of_property_read_u32(lcd_model_node,"max_lane_count",&val);
@@ -1887,6 +1903,17 @@ static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pd
             lcd_print("dual_port = %d\n", pConf->lcd_control.lvds_config->dual_port);
         }
 
+#ifdef CONFIG_AML_LCD_EXTERN
+        ret = of_property_read_u32(lcd_model_node, "lcd_extern_index", &val);
+        if (ret) {
+            lcd_print("failed to get lcd_extern_index, default invalid\n");
+            pConf->lcd_control.extern_index = LCD_EXTERN_INDEX_INVALID;
+        } else {
+            pConf->lcd_control.extern_index = val;
+        }
+        lcd_print("lcd_extern_index = %d\n", pConf->lcd_control.extern_index);
+#endif
+
     kfree(lcd_para);
     return ret;
 }
diff --git a/include/linux/amlogic/vout/aml_lcd_extern.h b/include/linux/amlogic/vout/aml_lcd_extern.h
old mode 100755
new mode 100644
index 5e703ec5667e..df51c19ffd27
--- a/include/linux/amlogic/vout/aml_lcd_extern.h
+++ b/include/linux/amlogic/vout/aml_lcd_extern.h
@@ -1,9 +1,6 @@
 
-#ifndef __AMLOGIC_LCD_EXTERN_H_
-#define __AMLOGIC_LCD_EXTERN_H_
-
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include <linux/pinctrl/consumer.h>
+#ifndef _INC_AMLOGIC_LCD_EXTERN_H_
+#define _INC_AMLOGIC_LCD_EXTERN_H_
 
 typedef enum {
 	LCD_EXTERN_I2C = 0,
@@ -12,8 +9,11 @@ typedef enum {
 	LCD_EXTERN_MAX,
 } Lcd_Extern_Type_t;
 
+#define LCD_EXTERN_INDEX_INVALID   0xff
+#define LCD_EXTERN_NAME_LEN_MAX    30
 struct lcd_extern_config_t {
-	char *name;
+	int index;
+	char name[LCD_EXTERN_NAME_LEN_MAX];
 	Lcd_Extern_Type_t type;
 	int status;
 	int i2c_addr;
@@ -24,31 +24,18 @@ struct lcd_extern_config_t {
 };
 
 //global API
+#define LCD_EXT_DRIVER_MAX    10
 struct aml_lcd_extern_driver_t {
-	char *name;
-	Lcd_Extern_Type_t type;
+	struct lcd_extern_config_t config;
 	int (*reg_read)  (unsigned char reg, unsigned char *buf);
 	int (*reg_write) (unsigned char reg, unsigned char value);
 	int (*power_on)(void);
 	int (*power_off)(void);
 	unsigned char *init_on_cmd_8;
 	unsigned char *init_off_cmd_8;
-	//unsigned short *init_on_cmd_16;
-	//unsigned short *init_off_cmd_16;
 };
 
-#define LCD_EXTERN_DRIVER		"lcd_extern"
-
-#define lcd_extern_gpio_request(gpio) 				amlogic_gpio_request(gpio, LCD_EXTERN_DRIVER)
-#define lcd_extern_gpio_free(gpio) 					amlogic_gpio_free(gpio, LCD_EXTERN_DRIVER)
-#define lcd_extern_gpio_direction_input(gpio) 		amlogic_gpio_direction_input(gpio, LCD_EXTERN_DRIVER)
-#define lcd_extern_gpio_direction_output(gpio, val) amlogic_gpio_direction_output(gpio, val, LCD_EXTERN_DRIVER)
-#define lcd_extern_gpio_get_value(gpio) 			amlogic_get_value(gpio, LCD_EXTERN_DRIVER)
-#define lcd_extern_gpio_set_value(gpio,val) 		amlogic_set_value(gpio, val, LCD_EXTERN_DRIVER)
-
-extern struct aml_lcd_extern_driver_t* aml_lcd_extern_get_driver(void);
-extern int lcd_extern_driver_check(void);
-extern int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern_config_t *pdata);
+extern struct aml_lcd_extern_driver_t *aml_lcd_extern_get_driver(int index);
 
 #endif
 
diff --git a/include/linux/amlogic/vout/lcdoutc.h b/include/linux/amlogic/vout/lcdoutc.h
index be61b0458e2a..5d863eaaf915 100644
--- a/include/linux/amlogic/vout/lcdoutc.h
+++ b/include/linux/amlogic/vout/lcdoutc.h
@@ -207,7 +207,7 @@ typedef struct DSI_Config_s{
 
     unsigned char *dsi_init_on;
     unsigned char *dsi_init_off;
-    unsigned char lcd_extern_init;
+    //unsigned char lcd_extern_init;
 }DSI_Config_t;
 
 typedef struct {
@@ -262,6 +262,7 @@ typedef struct {
 } MLVDS_Config_t;
 
 typedef struct {
+	int extern_index;
 	DSI_Config_t *mipi_config;
 	EDP_Config_t *edp_config;
 	LVDS_Config_t *lvds_config;
-- 
2.19.0

