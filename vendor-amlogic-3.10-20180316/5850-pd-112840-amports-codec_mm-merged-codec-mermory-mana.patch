From b0b5191da9db65435075063262300b67f093f5b2 Mon Sep 17 00:00:00 2001
From: Zhi Zhou <zhi.zhou@amlogic.com>
Date: Wed, 16 Sep 2015 07:13:28 -0400
Subject: [PATCH 5850/5965] pd#112840: amports:codec_mm:merged codec mermory
 manager from 3.14

Change-Id: I0bbaaf34a40d41db9fb8a762697a74723870af56
---
 .../arm/boot/dts/amlogic/meson8m2_n200_1G.dtd |  23 +-
 drivers/amlogic/Kconfig                       |   1 +
 drivers/amlogic/Makefile                      |   2 +
 drivers/amlogic/amports/Kconfig               |   1 +
 drivers/amlogic/amports/amports_priv.h        |   2 +
 drivers/amlogic/amports/amstream.c            |  97 ++-
 drivers/amlogic/amports/streambuf.c           |  72 +-
 drivers/amlogic/amports/streambuf.h           |  28 +-
 drivers/amlogic/amports/vdec.c                | 120 ++-
 drivers/amlogic/amports/vdec.h                |   2 +-
 drivers/amlogic/amports/vh264_4k2k.c          |  77 +-
 drivers/amlogic/amports/vh265.c               | 245 +++---
 drivers/amlogic/codec_mm/Kconfig              |   9 +
 drivers/amlogic/codec_mm/Makefile             |  12 +
 drivers/amlogic/codec_mm/codec_mm.c           | 803 ++++++++++++++++++
 drivers/amlogic/codec_mm/codec_mm_priv.h      |  70 ++
 drivers/base/dma-contiguous.c                 |   7 +
 include/linux/amlogic/codec_mm/codec_mm.h     |  78 ++
 include/linux/dma-contiguous.h                |   6 +-
 19 files changed, 1437 insertions(+), 218 deletions(-)
 mode change 100755 => 100644 drivers/amlogic/Kconfig
 mode change 100755 => 100644 drivers/amlogic/Makefile
 mode change 100755 => 100644 drivers/amlogic/amports/Kconfig
 mode change 100755 => 100644 drivers/amlogic/amports/amports_priv.h
 mode change 100755 => 100644 drivers/amlogic/amports/streambuf.h
 create mode 100644 drivers/amlogic/codec_mm/Kconfig
 create mode 100644 drivers/amlogic/codec_mm/Makefile
 create mode 100644 drivers/amlogic/codec_mm/codec_mm.c
 create mode 100644 drivers/amlogic/codec_mm/codec_mm_priv.h
 create mode 100644 include/linux/amlogic/codec_mm/codec_mm.h
 mode change 100755 => 100644 include/linux/dma-contiguous.h

diff --git a/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd b/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
index c28446b3dd20..a94bfdf4e40b 100644
--- a/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
+++ b/arch/arm/boot/dts/amlogic/meson8m2_n200_1G.dtd
@@ -90,7 +90,7 @@ void root_func(){
 		mem_4k2k_decoder: region@1 {
 			region_name = "cma_4k2k";
 			linux,contiguous-region;
-			reg = <0x00000000 0x0ca00000>;
+			reg = <0x00000000 0xbc00000>;
 		};
 
         cma_0:region@0 {
@@ -169,7 +169,7 @@ void root_func(){
 		compatible = "amlogic,mesonstream";
 		dev_name = "mesonstream.0";
 		status = "okay";
-		reserve-memory = <0x02000000>; // 32M
+		///reserve-memory = <0x02000000>; // 32M
 		//reserve-iomap = "true";
 	};
 
@@ -183,10 +183,21 @@ void root_func(){
                 compatible = "amlogic,vdec";
                 dev_name = "vdec.0";
                 status = "okay";
-								reserve-memory = <0x04000000>; // 64M
-//		reserve-iomap = "true";
-		linux,contiguous-region = <&mem_4k2k_decoder>;
+///				reserve-memory = <0x04000000>; // 64M
+//				reserve-iomap = "true";
+//				linux,contiguous-region = <&mem_4k2k_decoder>;
         };
+
+
+	codec_mm{
+		compatible = "amlogic, codec, mm";
+		dev_name = "codec_mm";
+		status = "okay";
+		reserve-memory = <0x04100000>; // 65M
+		//reserve-iomap = "true";
+		linux,contiguous-region = <&mem_4k2k_decoder>;
+	};
+
 ///	-	picture decoder
 //$$ MODULE="picture decoder"
 //$$ DEVICE="picdec"
@@ -196,7 +207,7 @@ void root_func(){
 		compatible = "amlogic,picdec";
 		dev_name = "picdec";
 		status = "okay";
-                share-memory-name = "vdec0";
+                share-memory-name = "codec_mm0";
                 share-memory-offset = <0>;
                 share-memory-size = <0x04000000>; //64M
 	};
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
old mode 100755
new mode 100644
index e4c455425a20..b823e9c937ec
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -115,4 +115,5 @@ source "drivers/amlogic/crypto/Kconfig"
 source "drivers/amlogic/mhl/Kconfig"
 isource "../hardware/amlogic/pmu/Kconfig"
 isource "../hardware/amlogic/touch/Kconfig"
+source "drivers/amlogic/codec_mm/Kconfig"
 endmenu
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
old mode 100755
new mode 100644
index 5ce0c52c92cf..f33717cb7bc1
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -123,6 +123,8 @@ obj-$(CONFIG_D2D3_PROCESS) += d2d3/
 
 obj-$(CONFIG_AML_REG_DEBUG) += regd/
 
+obj-$(CONFIG_AML_CODEC_MM)  	+= codec_mm/
+
 obj-$(CONFIG_AML_WATCHDOG) += watchdog/
 
 obj-$(CONFIG_AMLOGIC_JTAG) += jtag/
diff --git a/drivers/amlogic/amports/Kconfig b/drivers/amlogic/amports/Kconfig
old mode 100755
new mode 100644
index 368c07b614da..5a397b78119f
--- a/drivers/amlogic/amports/Kconfig
+++ b/drivers/amlogic/amports/Kconfig
@@ -28,6 +28,7 @@ config AM_VIDEO
 	select AM_PTSMGR
 	select AM_TIMESYNC
 	select AM_PTSSERVER
+	select AML_CODEC_MM
 	help
 	  Driver for video display.
 
diff --git a/drivers/amlogic/amports/amports_priv.h b/drivers/amlogic/amports/amports_priv.h
old mode 100755
new mode 100644
index d81fdd0ae53e..97d774450be8
--- a/drivers/amlogic/amports/amports_priv.h
+++ b/drivers/amlogic/amports/amports_priv.h
@@ -7,6 +7,8 @@ stream_buf_t *get_buf_by_type(u32  type);
 
 /*video.c provide*/
 struct amvideocap_req;
+extern u32 set_blackout_policy(int policy);
+extern u32 get_blackout_policy(void);
 int calculation_stream_ext_delayed_ms(u8 type);
 int ext_get_cur_video_frame(vframe_t **vf,int *canvas_index);
 int ext_put_video_frame(vframe_t *vf);
diff --git a/drivers/amlogic/amports/amstream.c b/drivers/amlogic/amports/amstream.c
index 1541916a4486..415e4cadd861 100644
--- a/drivers/amlogic/amports/amstream.c
+++ b/drivers/amlogic/amports/amstream.c
@@ -73,6 +73,7 @@
 
 #include <linux/of.h>
 #include <linux/of_fdt.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
 
 #define DEVICE_NAME "amstream-dev"
 #define DRIVER_NAME "amstream"
@@ -119,7 +120,9 @@ void debug_file_write(const char __user *buf, size_t count)
 }
 #endif
 
-#define DEFAULT_VIDEO_BUFFER_SIZE       (1024*1024*3)
+#define DEFAULT_VIDEO_BUFFER_SIZE       (1024*1024*15)
+#define DEFAULT_VIDEO_BUFFER_SIZE_4K       (1024*1024*32)
+
 #define DEFAULT_AUDIO_BUFFER_SIZE       (1024*768*2)
 #define DEFAULT_SUBTITLE_BUFFER_SIZE     (1024*256)
 
@@ -310,21 +313,24 @@ static stream_buf_t bufs[BUF_MAX_NUM] = {
         .reg_base = VLD_MEM_VIFIFO_REG_BASE,
         .type = BUF_TYPE_VIDEO,
         .buf_start = 0,
-        .buf_size = 0,
+        .buf_size = DEFAULT_VIDEO_BUFFER_SIZE,
+        .default_buf_size = DEFAULT_VIDEO_BUFFER_SIZE,
         .first_tstamp = INVALID_PTS
     },
     {
         .reg_base = AIU_MEM_AIFIFO_REG_BASE,
         .type = BUF_TYPE_AUDIO,
         .buf_start = 0,
-        .buf_size = 0,
+        .buf_size = DEFAULT_AUDIO_BUFFER_SIZE,
+        .default_buf_size = DEFAULT_AUDIO_BUFFER_SIZE,
         .first_tstamp = INVALID_PTS
     },
     {
         .reg_base = 0,
         .type = BUF_TYPE_SUBTITLE,
         .buf_start = 0,
-        .buf_size = 0,
+        .buf_size = DEFAULT_SUBTITLE_BUFFER_SIZE,
+        .default_buf_size = DEFAULT_SUBTITLE_BUFFER_SIZE,
         .first_tstamp = INVALID_PTS
     },
     {
@@ -332,6 +338,7 @@ static stream_buf_t bufs[BUF_MAX_NUM] = {
         .type = BUF_TYPE_USERDATA,
         .buf_start = 0,
         .buf_size = 0,
+        .default_buf_size = 0,
         .first_tstamp = INVALID_PTS
     },
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
@@ -339,7 +346,8 @@ static stream_buf_t bufs[BUF_MAX_NUM] = {
         .reg_base = HEVC_STREAM_REG_BASE,
         .type = BUF_TYPE_HEVC,
         .buf_start = 0,
-        .buf_size = 0,
+        .buf_size = DEFAULT_VIDEO_BUFFER_SIZE_4K,
+        .default_buf_size = DEFAULT_VIDEO_BUFFER_SIZE_4K,
         .first_tstamp = INVALID_PTS
     },
 #endif
@@ -349,7 +357,7 @@ stream_buf_t *get_buf_by_type(u32  type)
 {
     if (PTS_TYPE_VIDEO == type) {
         return &bufs[BUF_TYPE_VIDEO];
-    } 
+    }
     if (PTS_TYPE_AUDIO == type) {
         return &bufs[BUF_TYPE_AUDIO];
     }
@@ -388,20 +396,39 @@ static void amstream_change_vbufsize(stream_port_t *port,struct stream_buf_s *pv
     } else {
         condition = pvbuf->type == BUF_TYPE_VIDEO;
     }
-
-    if (pvbuf->type == condition) {
-        if (port->vformat == VFORMAT_H264_4K2K){				
-            pvbuf->buf_size = pvbuf->default_buf_size;
-
-            //printk(" amstream_change_vbufsize 4k2k bufsize[0x%x] defaultsize[0x%x]\n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size);
-        }else if((pvbuf->default_buf_size > MAX_STREAMBUFFER_SIZE)&& (port->vformat != VFORMAT_H264_4K2K)) {
-            pvbuf->buf_size = MAX_STREAMBUFFER_SIZE;
-
-            //printk(" amstream_change_vbufsize MAX_STREAMBUFFER_SIZE-[0x%x] defaultsize-[0x%x] vformat-[%d]\n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size,port->vformat);
+    if (pvbuf->type == BUF_TYPE_VIDEO || pvbuf->type == BUF_TYPE_HEVC) {
+        if (port->vformat == VFORMAT_H264_4K2K ||
+                port->vformat == VFORMAT_HEVC) {
+            int framesize = amstream_dec_info.height *
+            amstream_dec_info.width;
+            pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_4K;
+            if ((framesize > 0) &&
+              (port->vformat == VFORMAT_HEVC) &&
+              (framesize <= 1920 * 1088)) {
+                /*if hevc not 4k used 15M streambuf.*/
+                pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE;
+            }
+            if ((pvbuf->buf_size > 30 * SZ_1M) &&
+              (codec_mm_get_total_size() < 220 * SZ_1M)) {
+                /*if less than 250M, used 20M for 4K & 265*/
+                pvbuf->buf_size = pvbuf->buf_size >> 1;
+            }
+            /* pr_err(" amstream_change_vbufsize 4k2k
+            * bufsize[0x%x] defaultsize[0x%x]\n",
+            * bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size); */
+        } else if (pvbuf->buf_size > DEFAULT_VIDEO_BUFFER_SIZE) {
+            pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE;
+            /* pr_err(" amstream_change_vbufsize
+            * MAX_STREAMBUFFER_SIZE-[0x%x]
+            * defaultsize-[0x%x] vformat-[%d]\n",
+            * bufs[BUF_TYPE_VIDEO].buf_size,
+            * pvbuf->default_buf_size,port->vformat); */
         } else {
-            //printk(" amstream_change_vbufsize bufsize[0x%x] defaultbufsize [0x%x] \n",bufs[BUF_TYPE_VIDEO].buf_size,pvbuf->default_buf_size);	
+            /* pr_err(" amstream_change_vbufsize bufsize[0x%x]
+            * defaultbufsize [0x%x]\n",
+            * bufs[BUF_TYPE_VIDEO].buf_size,
+            * pvbuf->default_buf_size); */
         }
-
         reset_canuse_buferlevel(10000);
     }
 
@@ -451,7 +478,9 @@ static  int video_port_init(stream_port_t *port, struct stream_buf_s * pbuf)
         return r;
     }
 
-    r = vdec_init(port->vformat);
+    r = vdec_init(port->vformat,
+        (amstream_dec_info.height *
+        amstream_dec_info.width) > 1920*1088);
     if (r < 0) {
         printk("video_port_init %d, vdec_init failed\n", __LINE__);
         video_port_release(port, pbuf, 2);
@@ -969,7 +998,7 @@ static ssize_t amstream_sub_read(struct file *file, char __user *buf, size_t cou
         int first_num = s_buf->buf_size - (sub_rp - sub_start);
 
         if (data_size <= first_num) {
-            res = copy_to_user((void *)buf, (void *)(phys_to_virt(sub_rp)), data_size);
+            res = copy_to_user((void *)buf, (void *)(codec_mm_phys_to_virt(sub_rp)), data_size);
             if (res >= 0) {
                 stbuf_sub_rp_set(sub_rp + data_size - res);
             }
@@ -977,7 +1006,7 @@ static ssize_t amstream_sub_read(struct file *file, char __user *buf, size_t cou
             return data_size - res;
         } else {
             if (first_num > 0) {
-                res = copy_to_user((void *)buf, (void *)(phys_to_virt(sub_rp)), first_num);
+                res = copy_to_user((void *)buf, (void *)(codec_mm_phys_to_virt(sub_rp)), first_num);
                 if (res >= 0) {
                     stbuf_sub_rp_set(sub_rp + first_num - res);
                 }
@@ -985,7 +1014,7 @@ static ssize_t amstream_sub_read(struct file *file, char __user *buf, size_t cou
                 return first_num - res;
             }
 
-            res = copy_to_user((void *)buf, (void *)(phys_to_virt(sub_start)), data_size - first_num);
+            res = copy_to_user((void *)buf, (void *)(codec_mm_phys_to_virt(sub_start)), data_size - first_num);
 
             if (res >= 0) {
                 stbuf_sub_rp_set(sub_start + data_size - first_num - res);
@@ -994,7 +1023,7 @@ static ssize_t amstream_sub_read(struct file *file, char __user *buf, size_t cou
             return data_size - first_num - res;
         }
     } else {
-        res = copy_to_user((void *)buf, (void *)(phys_to_virt(sub_rp)), data_size);
+        res = copy_to_user((void *)buf, (void *)(codec_mm_phys_to_virt(sub_rp)), data_size);
 
         if (res >= 0) {
             stbuf_sub_rp_set(sub_rp + data_size - res);
@@ -1935,7 +1964,7 @@ static ssize_t bufs_show(struct class *class, struct class_attribute *attr, char
         pbuf += sprintf(pbuf, ")\n");
         /*buf stats*/
 
-        pbuf += sprintf(pbuf, "\tbuf addr:%#x\n", p->buf_start);
+        pbuf += sprintf(pbuf, "\tbuf addr:%p\n", (void *)p->buf_start);
 
         if (p->type != BUF_TYPE_SUBTITLE) {
             pbuf += sprintf(pbuf, "\tbuf size:%#x\n", p->buf_size);
@@ -2140,22 +2169,22 @@ int request_video_firmware(const char * file_name,char *buf,int size)
 
 	memcpy(buf,(char*)firmware->data,firmware->size);
     mb();
-	printk("load mcode size=%d\n mcode name %s\n",firmware->size,file_name);
-	err=firmware->size;
+    printk("load mcode size=%d\n mcode name %s\n",firmware->size,file_name);
+    err=firmware->size;
 release:	
-	release_firmware(firmware);
+    release_firmware(firmware);
 error1:
-	device_destroy(&amstream_class, MKDEV(AMSTREAM_MAJOR, 100));
+    device_destroy(&amstream_class, MKDEV(AMSTREAM_MAJOR, 100));
 	return err;
 }
 
-static struct resource memobj;
+///static struct resource memobj;
 static int  amstream_probe(struct platform_device *pdev)
 {
     int i;
     int r;
     stream_port_t *st;
-    struct resource *res;
+    ///struct resource *res;
 
     printk("Amlogic A/V streaming port init\n");
 
@@ -2204,7 +2233,7 @@ static int  amstream_probe(struct platform_device *pdev)
 
 #if 0
     res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-#else
+
     res = &memobj;
     r = find_reserve_block(pdev->dev.of_node->name,0);
     if(r < 0){
@@ -2214,7 +2243,7 @@ static int  amstream_probe(struct platform_device *pdev)
     }
     res->start = (phys_addr_t)get_reserve_block_addr(r);
     res->end = res->start+ (phys_addr_t)get_reserve_block_size(r)-1;
-#endif
+
     if (!res) {
         printk("Can not obtain I/O memory, and will allocate stream buffer!\n");
 
@@ -2261,6 +2290,7 @@ static int  amstream_probe(struct platform_device *pdev)
 
         bufs[BUF_TYPE_HEVC].default_buf_size = bufs[BUF_TYPE_VIDEO].default_buf_size;
     }
+#endif
 
     if (stbuf_fetch_init() != 0) {
         r = (-ENOMEM);
@@ -2273,6 +2303,8 @@ static int  amstream_probe(struct platform_device *pdev)
     return 0;
 
 error7:
+#if 0
+
     if (bufs[BUF_TYPE_SUBTITLE].flag & BUF_FLAG_ALLOC) {
         stbuf_change_size(&bufs[BUF_TYPE_SUBTITLE], 0);
     }
@@ -2285,6 +2317,7 @@ error5:
         stbuf_change_size(&bufs[BUF_TYPE_VIDEO], 0);
     }
 error4:
+#endif
     tsdemux_class_unregister();
 error3:
     for (st = &ports[0], i = 0; i < amstream_port_num; i++, st++) {
diff --git a/drivers/amlogic/amports/streambuf.c b/drivers/amlogic/amports/streambuf.c
index 8ffd04a9cc1f..71c12c2bbfe5 100755
--- a/drivers/amlogic/amports/streambuf.c
+++ b/drivers/amlogic/amports/streambuf.c
@@ -36,9 +36,11 @@
 #include "streambuf_reg.h"
 #include "streambuf.h"
 #include "amports_config.h"
+#include <linux/amlogic/codec_mm/codec_mm.h>
 
 #define STBUF_SIZE   (64*1024)
 #define STBUF_WAIT_INTERVAL  HZ/100
+#define MEM_NAME "streambuf"
 
 ulong fetchbuf = 0;
 ulong *fetchbuf_remap = NULL;
@@ -49,21 +51,50 @@ static s32 _stbuf_alloc(stream_buf_t *buf)
         return -ENOBUFS;
     }
 
-    if (buf->buf_start == 0) {
-        buf->buf_start = __get_free_pages(GFP_KERNEL, get_order(buf->buf_size));
+    while (buf->buf_start == 0) {
+        int flags = CODEC_MM_FLAGS_DMA;
 
+        buf->buf_page_num = PAGE_ALIGN(buf->buf_size) / PAGE_SIZE;
+        if (buf->type == BUF_TYPE_SUBTITLE)
+            flags = CODEC_MM_FLAGS_DMA_CPU;
+
+        /*if 4k,
+        used cma first,for less mem fragments.
+        */
+        if (buf->buf_size > 20 * 1024 * 1024)
+            flags = CODEC_MM_FLAGS_CMA_FIRST;
+
+        buf->buf_start = codec_mm_alloc_for_dma(MEM_NAME,
+        buf->buf_page_num, 4 + PAGE_SHIFT, flags);
         if (!buf->buf_start) {
+            int is_video = (buf->type == BUF_TYPE_HEVC) ||
+                (buf->type == BUF_TYPE_VIDEO);
+            if (is_video && buf->buf_size >= 9 * SZ_1M) {/*min 6M*/
+                int old_size = buf->buf_size;
+                buf->buf_size  = PAGE_ALIGN(buf->buf_size * 2/3);
+                pr_info("%s stbuf alloced size = %d failed try small %d size\n",
+                    (buf->type == BUF_TYPE_HEVC) ? "HEVC" :
+                    (buf->type == BUF_TYPE_VIDEO) ? "Video" :
+                    (buf->type == BUF_TYPE_AUDIO) ? "Audio" :
+                    "Subtitle", old_size, buf->buf_size);
+                continue;
+            }
+            pr_info("%s stbuf alloced size = %d failed\n",
+                (buf->type == BUF_TYPE_HEVC) ? "HEVC" :
+                (buf->type == BUF_TYPE_VIDEO) ? "Video" :
+                (buf->type == BUF_TYPE_AUDIO) ? "Audio" :
+                "Subtitle", buf->buf_size);
             return -ENOMEM;
         }
-
-        printk("%s stbuf alloced at 0x%x, size = %d\n",
-               (buf->type == BUF_TYPE_HEVC) ? "HEVC" :
-               (buf->type == BUF_TYPE_VIDEO) ? "Video" :
-               (buf->type == BUF_TYPE_AUDIO) ? "Audio" :
-                "Subtitle",
-               buf->buf_start, buf->buf_size);
+        pr_info("%s stbuf alloced at %p, size = %d\n",
+            (buf->type == BUF_TYPE_HEVC) ? "HEVC" :
+            (buf->type == BUF_TYPE_VIDEO) ? "Video" :
+            (buf->type == BUF_TYPE_AUDIO) ? "Audio" :
+            "Subtitle", (void *)buf->buf_start,
+            buf->buf_size);
     }
 
+
     buf->flag |= BUF_FLAG_ALLOC;
 
     return 0;
@@ -71,10 +102,11 @@ static s32 _stbuf_alloc(stream_buf_t *buf)
 
 int stbuf_change_size(struct stream_buf_s *buf, int size)
 {
-    u32 old_buf, old_size;
+    u32 old_buf;
+    int old_size, old_pagenum;
     int ret;
 
-    printk("buffersize=%d,%d,start=%x\n", size, buf->buf_size, buf->buf_start);
+    printk("buffersize=%d,%d,start=%p\n", size, buf->buf_size, (void *)buf->buf_start);
 
     if (buf->buf_size == size && buf->buf_start != 0) {
         return 0;
@@ -82,7 +114,7 @@ int stbuf_change_size(struct stream_buf_s *buf, int size)
 
     old_buf = buf->buf_start;
     old_size = buf->buf_size;
-
+    old_pagenum = buf->buf_page_num;
     buf->buf_start = 0;
     buf->buf_size = size;
     ret = size;
@@ -93,7 +125,7 @@ int stbuf_change_size(struct stream_buf_s *buf, int size)
          * alloc ok,changed to new buffer
          */
         if (old_buf != 0) {
-            free_pages(old_buf, get_order(old_size));
+            codec_mm_free_for_dma(MEM_NAME, old_buf);
         }
 
         printk("changed the (%d) buffer size from %d to %d\n", buf->type, old_size, size);
@@ -101,6 +133,7 @@ int stbuf_change_size(struct stream_buf_s *buf, int size)
         /* alloc failed */
         buf->buf_start = old_buf;
         buf->buf_size = old_size;
+        buf->buf_page_num = old_pagenum;
         printk("changed the (%d) buffer size from %d to %d,failed\n", buf->type, old_size, size);
     }
 
@@ -242,7 +275,7 @@ s32 stbuf_init(struct stream_buf_s *buf)
         if (r < 0) {
             return r;
         }
-        phy_addr = virt_to_phys((void *)buf->buf_start);
+        phy_addr = buf->buf_start;
     }
 
     init_waitqueue_head(&buf->wq);
@@ -347,12 +380,13 @@ s32 stbuf_wait_space(struct stream_buf_s *stream_buf, size_t count)
 void stbuf_release(struct stream_buf_s *buf)
 {
     buf->first_tstamp = INVALID_PTS;
-	stbuf_init(buf);	//reinit buffer 
-    if (buf->flag & BUF_FLAG_IOMEM) {
-        buf->flag = BUF_FLAG_IOMEM;
-    } else {
-        buf->flag = 0;
+    stbuf_init(buf);	/* reinit buffer */
+    if (buf->flag & BUF_FLAG_ALLOC && buf->buf_start) {
+        codec_mm_free_for_dma(MEM_NAME, buf->buf_start);
+        buf->flag &= ~BUF_FLAG_ALLOC;
+        buf->buf_start = 0;
     }
+    buf->flag &= ~BUF_FLAG_IN_USE;
 }
 
 u32 stbuf_sub_rp_get(void)
diff --git a/drivers/amlogic/amports/streambuf.h b/drivers/amlogic/amports/streambuf.h
old mode 100755
new mode 100644
index bb82ace6b43c..18be28daaa7c
--- a/drivers/amlogic/amports/streambuf.h
+++ b/drivers/amlogic/amports/streambuf.h
@@ -44,19 +44,21 @@
 typedef struct stream_buf_s {
     s32   flag;
     u32   type;
-    u32   buf_start;
-    u32   buf_size;
-    u32   default_buf_size;	
-    u32   canusebuf_size;	
-    u32   first_tstamp;
-    const ulong reg_base;
-    wait_queue_head_t   wq;
-    struct timer_list timer;
-    u32   wcnt;
-	u32	buf_wp;
-	u32	buf_rp;
-    u32 max_buffer_delay_ms;
-    u64 last_write_jiffies64;
+	unsigned long buf_start;
+	struct page *buf_pages;
+	int buf_page_num;
+	u32 buf_size;
+	u32 default_buf_size;
+	u32 canusebuf_size;
+	u32 first_tstamp;
+	const ulong reg_base;
+	wait_queue_head_t wq;
+	struct timer_list timer;
+	u32 wcnt;
+	u32 buf_wp;
+	u32 buf_rp;
+	u32 max_buffer_delay_ms;
+	u64 last_write_jiffies64;
 } stream_buf_t;
 
 typedef struct stream_port_s {
diff --git a/drivers/amlogic/amports/vdec.c b/drivers/amlogic/amports/vdec.c
index 438cad5a3c5c..bfc3811b0059 100755
--- a/drivers/amlogic/amports/vdec.c
+++ b/drivers/amlogic/amports/vdec.c
@@ -40,19 +40,24 @@
 
 #include "amports_config.h"
 #include "amvdec.h"
+#include <linux/amlogic/codec_mm/codec_mm.h>
 
 #include "vdec_clk.h"
 
 static DEFINE_SPINLOCK(lock);
 
 #define MC_SIZE (4096 * 4)
-
+#define CMA_ALLOC_SIZE SZ_64M
+#define MEM_NAME "vdec_prealloc"
 #define SUPPORT_VCODEC_NUM  1
 static int inited_vcodec_num = 0;
 static int poweron_clock_level = 0;
+static int keep_vdec_mem;
+
 static unsigned int debug_trace_num = 16*20;
 static struct platform_device *vdec_device = NULL;
 static struct platform_device *vdec_core_device = NULL;
+int vdec_mem_alloced_from_codec, delay_release;
 struct am_reg {
     char *name;
     int offset;
@@ -75,6 +80,24 @@ static const char *vdec_device_name[] = {
     "amvdec_h265"
 };
 
+static int vdec_default_buf_size[] = {
+    32, /*"amvdec_mpeg12",*/
+    32, /*"amvdec_mpeg4",*/
+    48, /*"amvdec_h264",*/
+    32, /*"amvdec_mjpeg",*/
+    32, /*"amvdec_real",*/
+    32, /*"amjpegdec",*/
+    32, /*"amvdec_vc1",*/
+    32, /*"amvdec_avs",*/
+    32, /*"amvdec_yuv",*/
+    64, /*"amvdec_h264mvc",*/
+    64, /*"amvdec_h264_4k2k", else alloc on decoder*/
+    48, /*"amvdec_h265", else alloc on decoder*/
+    0
+};
+
+
+
 void vdec_set_decinfo(struct dec_sysinfo *p)
 {
     vdec_dev_reg.sys_info = p;
@@ -94,9 +117,10 @@ int vdec_set_resource(unsigned long start, unsigned long end, struct device *p)
     return 0;
 }
 
-s32 vdec_init(vformat_t vf)
+s32 vdec_init(vformat_t vf, int is_4k)
 {
     s32 r;
+    int retry_num = 0;
 
     if (inited_vcodec_num >= SUPPORT_VCODEC_NUM) {
         printk("We only support the one video code at each time\n");
@@ -105,6 +129,51 @@ s32 vdec_init(vformat_t vf)
 
     inited_vcodec_num++;
 
+    if (vf == VFORMAT_H264_4K2K ||
+        (vf == VFORMAT_HEVC && is_4k)) {
+        //try_free_keep_video();
+    }
+
+    pr_info("vdec_dev_reg.mem[0x%lx -- 0x%lx]\n",
+        vdec_dev_reg.mem_start,
+        vdec_dev_reg.mem_end);
+
+    /*retry alloc:*/
+    while (vdec_dev_reg.mem_start == vdec_dev_reg.mem_end) {
+        int alloc_size = vdec_default_buf_size[vf] * SZ_1M;
+        if (alloc_size == 0)
+            break;/*alloc end*/
+        if (is_4k) {
+            /*used 264 4k's setting for 265.*/
+            int m4k_size =
+            vdec_default_buf_size[VFORMAT_H264_4K2K] *
+            SZ_1M;
+            if ((m4k_size > 0) && (m4k_size < 200 * SZ_1M))
+                alloc_size = m4k_size;
+        }
+        vdec_dev_reg.mem_start = codec_mm_alloc_for_dma(MEM_NAME,
+            alloc_size / PAGE_SIZE, 4 + PAGE_SHIFT,
+            CODEC_MM_FLAGS_CMA_CLEAR);
+        if (!vdec_dev_reg.mem_start) {
+            if (retry_num < 1) {
+                pr_err("vdec base CMA allocation failed,try again\\n");
+                retry_num++;
+                ////try_free_keep_video();
+                continue;/*retry alloc*/
+            }
+            pr_err("vdec base CMA allocation failed.\n");
+            inited_vcodec_num--;
+            return -ENOMEM;
+        }
+        pr_info("vdec base memory alloced %p\n",
+            (void *)vdec_dev_reg.mem_start);
+
+        vdec_dev_reg.mem_end = vdec_dev_reg.mem_start +
+        alloc_size - 1;
+        vdec_mem_alloced_from_codec = 1;
+        break;/*alloc end*/
+    }
+
     vdec_device = platform_device_register_data(&vdec_core_device->dev, vdec_device_name[vf], -1,
                                             &vdec_dev_reg, sizeof(vdec_dev_reg));
 
@@ -130,6 +199,14 @@ s32 vdec_release(vformat_t vf)
     if (vdec_device) {
         platform_device_unregister(vdec_device);
     }
+    if (delay_release-- <= 0 &&
+        !keep_vdec_mem &&
+        vdec_mem_alloced_from_codec &&
+        vdec_dev_reg.mem_start) {
+            codec_mm_free_for_dma(MEM_NAME, vdec_dev_reg.mem_start);
+            vdec_dev_reg.mem_start = 0;
+            vdec_dev_reg.mem_end = 0;
+    }
 
     inited_vcodec_num--;
 
@@ -637,13 +714,35 @@ static struct class vdec_class = {
         .class_attrs = vdec_class_attrs,
     };
 
+/*
+pre alloced enough memory for decoder
+fast start.
+*/
+void pre_alloc_vdec_memory(void)
+{
+    if (!keep_vdec_mem || vdec_dev_reg.mem_start)
+        return;
+    vdec_dev_reg.mem_start = codec_mm_alloc_for_dma(MEM_NAME,
+        CMA_ALLOC_SIZE / PAGE_SIZE, 4 + PAGE_SHIFT,
+        CODEC_MM_FLAGS_CMA_CLEAR);
+    if (!vdec_dev_reg.mem_start)
+        return;
+    pr_info("vdec base memory alloced %p\n",
+        (void *)vdec_dev_reg.mem_start);
+    vdec_dev_reg.mem_end = vdec_dev_reg.mem_start + CMA_ALLOC_SIZE - 1;
+    vdec_mem_alloced_from_codec = 1;
+    delay_release = 3;
+}
+
+
 static int vdec_probe(struct platform_device *pdev)
 {
     s32 r;
+#if 0
     const void * name;
     int offset, size;
     unsigned long start, end;
-
+#endif
     r = class_register(&vdec_class);
     if (r) {
         printk("vdec class create fail.\n");
@@ -651,7 +750,7 @@ static int vdec_probe(struct platform_device *pdev)
     }
 
     vdec_core_device = pdev;
-
+#if 0
     r = find_reserve_block(pdev->dev.of_node->name,0);
 
     if(r < 0){
@@ -695,17 +794,26 @@ static int vdec_probe(struct platform_device *pdev)
     printk("init vdec memsource %lx->%lx\n", start, end);
 
     vdec_set_resource(start, end, &pdev->dev);
+#endif
 
 #if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON6TVD
     /* default to 250MHz */
     vdec_clock_hi_enable();
 #endif
-    return 0;
+    if (codec_mm_get_reserved_size() >= 48 * SZ_1M
+    && codec_mm_get_reserved_size() <=  96 * SZ_1M) {
+        vdec_default_buf_size[VFORMAT_H264_4K2K] =
+        codec_mm_get_reserved_size() / SZ_1M;
+        /*all reserved size for prealloc*/
+    }
 
+    pre_alloc_vdec_memory();
+    return 0;
+#if 0
 error:
     class_unregister(&vdec_class);
-
     return r;
+#endif
 }
 
 static int  vdec_remove(struct platform_device *pdev)
diff --git a/drivers/amlogic/amports/vdec.h b/drivers/amlogic/amports/vdec.h
index c76d0e008b84..108a77600141 100755
--- a/drivers/amlogic/amports/vdec.h
+++ b/drivers/amlogic/amports/vdec.h
@@ -38,7 +38,7 @@ typedef struct vdec_dev_reg_s {
 extern void vdec_set_decinfo(struct dec_sysinfo *p);
 extern int vdec_set_resource(unsigned long start, unsigned long end, struct device *p);
 
-extern s32 vdec_init(vformat_t vf);
+extern s32 vdec_init(vformat_t vf, int is_4k);
 extern s32 vdec_release(vformat_t vf);
 
 s32 vdec_dev_register(void);
diff --git a/drivers/amlogic/amports/vh264_4k2k.c b/drivers/amlogic/amports/vh264_4k2k.c
index 7be46c128516..d00c12e7f9a3 100755
--- a/drivers/amlogic/amports/vh264_4k2k.c
+++ b/drivers/amlogic/amports/vh264_4k2k.c
@@ -36,7 +36,10 @@
 #include <linux/dma-mapping.h>
 #include <linux/dma-contiguous.h>
 #include <linux/delay.h>
+#include "amports_priv.h"
 
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#define MEM_NAME "codec_264_4k"
 #include <mach/am_regs.h>
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 #include <mach/vpu.h>
@@ -244,6 +247,7 @@ typedef struct {
 #endif
 
     struct page *alloc_pages;
+    unsigned long phy_addr;
     int alloc_count;
 } buffer_spec_t;
 
@@ -405,38 +409,49 @@ int init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width, int
             int page_count = PAGE_ALIGN((mb_total << 8) + (mb_total << 7)) / PAGE_SIZE;
 #endif
 
-            if (buffer_spec[i].alloc_pages) {
+            if (buffer_spec[i].phy_addr) {
                 if (page_count != buffer_spec[i].alloc_count) {
-                    printk("Delay released CMA buffer %d\n", i);
-
-                    dma_release_from_contiguous(cma_dev, buffer_spec[i].alloc_pages, buffer_spec[i].alloc_count);
-                    buffer_spec[i].alloc_pages = NULL;
-                    buffer_spec[i].alloc_count = 0;
-                } else {
-                    printk("Re-use CMA buffer %d\n", i);
-                }
+                    pr_info("Delay release CMA buffer%d\n", i);
+
+                    /*dma_release_from_contiguous(cma_dev,
+                    buffer_spec[i].
+                    alloc_pages,
+                    buffer_spec[i].
+                    alloc_count);
+                    */
+                    codec_mm_free_for_dma(MEM_NAME,
+                        buffer_spec[i].phy_addr);
+                        buffer_spec[i].phy_addr = 0;
+                        buffer_spec[i].alloc_pages = NULL;
+                        buffer_spec[i].alloc_count = 0;
+                } else
+                   pr_info("Re-use CMA buffer %d\n", i);
             }
-
-            if (!buffer_spec[i].alloc_pages) {
+            if (!buffer_spec[i].phy_addr) {
                 buffer_spec[i].alloc_count = page_count;
-                buffer_spec[i].alloc_pages = dma_alloc_from_contiguous(cma_dev, page_count, 4);
-            } 
+                buffer_spec[i].phy_addr =
+                codec_mm_alloc_for_dma(
+                    MEM_NAME, buffer_spec[i].alloc_count,
+                    4 + PAGE_SHIFT,
+                    CODEC_MM_FLAGS_CMA_CLEAR);
+            }
             alloc_count++;
 
-            if (!buffer_spec[i].alloc_pages) {
+            if (!buffer_spec[i].phy_addr) {
                 buffer_spec[i].alloc_count = 0;
-                printk("264 4K2K decoder memory allocation failed %d.\n", i);
+                pr_info("264 4K2K decoder memory alloc failed %d.\n", i);
                 mutex_unlock(&vh264_4k2k_mutex);
                 return -1;
             }
-
-            addr = page_to_phys(buffer_spec[i].alloc_pages);
+            addr = buffer_spec[i].phy_addr;
             dpb_addr = addr;
         } else {
-            if (buffer_spec[i].alloc_pages) {
-                dma_release_from_contiguous(cma_dev, buffer_spec[i].alloc_pages, buffer_spec[i].alloc_count);
-                buffer_spec[i].alloc_pages = NULL;
-                buffer_spec[i].alloc_count = 0;
+            if (buffer_spec[i].phy_addr) {
+                codec_mm_free_for_dma(MEM_NAME,
+                    buffer_spec[i].phy_addr);
+                    buffer_spec[i].phy_addr = 0;
+                    buffer_spec[i].alloc_pages = NULL;
+                    buffer_spec[i].alloc_count = 0;
             }
 
             addr = dpb_addr;
@@ -1443,16 +1458,18 @@ static int vh264_4k2k_stop(void)
 #ifdef CONFIG_VSYNC_RDMA
     msleep(100);
 #endif
-
-    canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff), &cur_canvas);
-    disp_addr = cur_canvas.addr;
-
+    if (!get_blackout_policy()) {
+        canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff), &cur_canvas);
+        disp_addr = cur_canvas.addr;
+    }
     for (i=0; i<ARRAY_SIZE(buffer_spec); i++) {
-        if (buffer_spec[i].alloc_pages) {
-            if (disp_addr == page_to_phys(buffer_spec[i].alloc_pages)) {
-                printk("Skip releasing CMA buffer %d\n", i);
-            } else {
-                dma_release_from_contiguous(cma_dev, buffer_spec[i].alloc_pages, buffer_spec[i].alloc_count);
+        if (buffer_spec[i].phy_addr) {
+            if (disp_addr == (u32)buffer_spec[i].phy_addr)
+                pr_info("Skip releasing CMA buffer %d\n", i);
+            else {
+                codec_mm_free_for_dma(MEM_NAME,
+                buffer_spec[i].phy_addr);
+                buffer_spec[i].phy_addr = 0;
                 buffer_spec[i].alloc_pages = NULL;
                 buffer_spec[i].alloc_count = 0;
             }
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index c0a24fd91fda..8ac2e9d3d9c8 100755
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -39,7 +39,9 @@
 #include <linux/dma-contiguous.h>
 #include <linux/slab.h>
 #include "amports_priv.h"
+#include <linux/amlogic/codec_mm/codec_mm.h>
 
+#define MEM_NAME "codec_265"
 #include <mach/am_regs.h>
 #include "vdec_reg.h"
 
@@ -770,15 +772,14 @@ enum SliceType
 
 #define MAX_BUF_NUM 16
 typedef struct BUF_{
-  int index;
-  unsigned int alloc_flag;
-	/*buffer*/
-  unsigned int  cma_page_count;
-  struct page *alloc_pages;
-	unsigned long start_adr;
-	unsigned long size;
-	
-	unsigned long free_start_adr;
+    int index;
+    unsigned int alloc_flag;
+    /*buffer*/
+    unsigned int  cma_page_count;
+    unsigned long alloc_addr;
+    unsigned long start_adr;
+    unsigned int size;
+    unsigned long free_start_adr;
 }BUF_t;
 static BUF_t m_BUF[MAX_BUF_NUM];
 static u32 max_buf_num = MAX_BUF_NUM;
@@ -1121,123 +1122,147 @@ static void uninit_buf_list(hevc_stru_t* hevc)
       }
   }
 
-  if (release_cma_flag) {
-      for (i = 0; i < used_buf_num; i++) {
-        if (m_BUF[i].alloc_pages != NULL && m_BUF[i].cma_page_count > 0) {
-            if ((release_cma_flag == 2) && (previous_display_buf_adr >= m_BUF[i].start_adr)
-                && (previous_display_buf_adr < (m_BUF[i].start_adr + m_BUF[i].size)))
-              continue;
-            dma_release_from_contiguous(cma_dev, m_BUF[i].alloc_pages, m_BUF[i].cma_page_count);
-            printk("release cma buffer[%d] (%d %x)\n", i, m_BUF[i].cma_page_count, (unsigned)m_BUF[i].alloc_pages);
-            m_BUF[i].alloc_pages=NULL;
-            m_BUF[i].cma_page_count=0;
-        }
-      }
-  }
+   if (release_cma_flag) {
+       for (i = 0; i < used_buf_num; i++) {
+       if (m_BUF[i].alloc_addr != 0
+           && m_BUF[i].cma_page_count > 0) {
+               if ((release_cma_flag == 2)
+                   && (previous_display_buf_adr >=
+                   m_BUF[i].start_adr)
+                   && (previous_display_buf_adr <
+                   (m_BUF[i].start_adr +
+                   m_BUF[i].size)))
+               continue;
+
+               pr_info("release cma buffer[%d] (%d %ld)\n", i,
+                   m_BUF[i].cma_page_count,
+                   m_BUF[i].alloc_addr);
+               codec_mm_free_for_dma(MEM_NAME,
+                   m_BUF[i].alloc_addr);
+                   m_BUF[i].alloc_addr = 0;
+                   m_BUF[i].cma_page_count = 0;
+
+           }
+       }
+   }
 
-  hevc->pic_list_init_flag = 0;
-  hevc->buf_num = 0;
+    hevc->pic_list_init_flag = 0;
+    hevc->buf_num = 0;
 }
 
 static void init_buf_list(hevc_stru_t* hevc)
 {
-	int i;
-	int buf_size;
-	int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
-	
-	if (dynamic_buf_num_margin > 0)
-		used_buf_num = hevc->sps_num_reorder_pics_0
-		+ dynamic_buf_num_margin;
-	else
-		used_buf_num = max_buf_num;
-
-	if (used_buf_num > MAX_BUF_NUM)
-		used_buf_num = MAX_BUF_NUM;
-
-	if(buf_alloc_size>0){
-	    buf_size = buf_alloc_size;
-	    if(debug)printk("[Buffer Management] init_buf_list:\n");	
-	}
-	else{
-	    int pic_width = buf_alloc_width?buf_alloc_width:hevc->pic_w;
-	    int pic_height = buf_alloc_height?buf_alloc_height:hevc->pic_h;
-	    int pic_width_64 = (pic_width + 63) & (~0x3f);
-	    int pic_height_32 = (pic_height + 31) & (~0x1f);
-	    int lcu_size = hevc->lcu_size ;
+    int i;
+    int buf_size;
+    int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
+
+    if (dynamic_buf_num_margin > 0)
+        used_buf_num = hevc->sps_num_reorder_pics_0 + dynamic_buf_num_margin;
+    else
+        used_buf_num = max_buf_num;
+
+    if (used_buf_num > MAX_BUF_NUM)
+        used_buf_num = MAX_BUF_NUM;
+
+    if (buf_alloc_size>0) {
+        buf_size = buf_alloc_size;
+        if (debug) printk("[Buffer Management] init_buf_list:\n");
+     } else {
+        int pic_width = buf_alloc_width?buf_alloc_width:hevc->pic_w;
+        int pic_height = buf_alloc_height?buf_alloc_height:hevc->pic_h;
+        int pic_width_64 = (pic_width + 63) & (~0x3f);
+        int pic_height_32 = (pic_height + 31) & (~0x1f);
+        int lcu_size = hevc->lcu_size ;
 #if 1
-	    int pic_width_lcu  = (pic_width_64 % lcu_size) ? pic_width_64 / lcu_size  + 1 : pic_width_64 / lcu_size;
-	    int pic_height_lcu = (pic_height_32 % lcu_size) ? pic_height_32 / lcu_size + 1 : pic_height_32 / lcu_size;
-	    //int pic_height_lcu_2 = (pic_height_lcu + 1) & (~0x1);
-	    int pic_height_lcu_2 = (lcu_size == 32) ? (pic_height_lcu + 1) & (~0x1): ((lcu_size == 16) ? (pic_height_lcu + 3) & (~0x3) :
-	                             pic_height_lcu);
-	    int lcu_total       = pic_width_lcu * pic_height_lcu_2;
+        int pic_width_lcu  = (pic_width_64 % lcu_size) ? pic_width_64 / lcu_size  + 1 : pic_width_64 / lcu_size;
+        int pic_height_lcu = (pic_height_32 % lcu_size) ? pic_height_32 / lcu_size + 1 : pic_height_32 / lcu_size;
+        //int pic_height_lcu_2 = (pic_height_lcu + 1) & (~0x1);
+        int pic_height_lcu_2 = (lcu_size == 32) ? (pic_height_lcu + 1) & (~0x1): ((lcu_size == 16) ? (pic_height_lcu + 3) & (~0x3) :
+        pic_height_lcu);
+        int lcu_total       = pic_width_lcu * pic_height_lcu_2;
 #else
-	    int pic_width_lcu  = (pic_width % lcu_size) ? pic_width / lcu_size  + 1 : pic_width /lcu_size;
-	    int pic_height_lcu = (pic_height % lcu_size) ? pic_height / lcu_size + 1 : pic_height/lcu_size;
-	    int lcu_total       = pic_width_lcu * pic_height_lcu;
+        int pic_width_lcu  = (pic_width % lcu_size) ? pic_width / lcu_size  + 1 : pic_width /lcu_size;
+        int pic_height_lcu = (pic_height % lcu_size) ? pic_height / lcu_size + 1 : pic_height/lcu_size;
+        int lcu_total       = pic_width_lcu * pic_height_lcu;
 #endif
-	    int mc_buffer_size_u_v = lcu_total*lcu_size*lcu_size/2;
-	    int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16; //64k alignment
+        int mc_buffer_size_u_v = lcu_total*lcu_size*lcu_size/2;
+        int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16; //64k alignment
 
-	    buf_size = (mc_buffer_size_u_v_h<<16)*3;
-	    if (debug) printk("[Buffer Management] init_buf_list num %d (width %d height %d):\n",
-	         used_buf_num, pic_width, pic_height);
-  }  
+        buf_size = (mc_buffer_size_u_v_h<<16)*3;
+        if (debug)
+            printk("[Buffer Management] init_buf_list num %d (width %d height %d):\n",
+                   used_buf_num, pic_width, pic_height);
+    }
 
-	for (i = 0; i < used_buf_num; i++) {
-		if(((i+1)*buf_size) > hevc->mc_buf->buf_size){
-        if(use_cma){
-            hevc->use_cma_flag = 1;
-        }
-        else{
-            if(debug)printk("%s maximum buf size is used\n", __func__);
-              break;
+    for (i = 0; i < used_buf_num; i++) {
+        if (((i + 1) * buf_size) > hevc->mc_buf->buf_size) {
+            if (use_cma) {
+                hevc->use_cma_flag = 1;
+            } else {
+                if (debug) printk("%s maximum buf size is used\n", __func__);
+                    break;
+            }
         }
-    }
-    m_BUF[i].alloc_flag = 0;
-    m_BUF[i].index = i;
-		
-		if(hevc->use_cma_flag){
-		    if((m_BUF[i].cma_page_count!=0) && (m_BUF[i].alloc_pages!=NULL) &&
-		        (m_BUF[i].size != buf_size)){
-            dma_release_from_contiguous(cma_dev, m_BUF[i].alloc_pages, m_BUF[i].cma_page_count);
-            printk("release cma buffer[%d] (%d %x)\n", i, m_BUF[i].cma_page_count, (unsigned)m_BUF[i].alloc_pages);
-            m_BUF[i].alloc_pages=NULL;
-            m_BUF[i].cma_page_count=0;		        
-		    }
-		    if(m_BUF[i].alloc_pages == NULL){
-    		    m_BUF[i].cma_page_count = PAGE_ALIGN(buf_size)/PAGE_SIZE;
-            m_BUF[i].alloc_pages = dma_alloc_from_contiguous(cma_dev, m_BUF[i].cma_page_count, 4);
-            if(m_BUF[i].alloc_pages == NULL){
-                printk("allocate cma buffer[%d] fail\n", i);
+        m_BUF[i].alloc_flag = 0;
+        m_BUF[i].index = i;
+
+        if (hevc->use_cma_flag) {
+            if ((m_BUF[i].cma_page_count != 0)
+              && (m_BUF[i].alloc_addr != 0)
+              && (m_BUF[i].size != buf_size)) {
+                codec_mm_free_for_dma(MEM_NAME,
+                m_BUF[i].alloc_addr);
+                pr_info("release cma buffer[%d] (%d %ld)\n", i,
+                m_BUF[i].cma_page_count,
+                m_BUF[i].alloc_addr);
+                m_BUF[i].alloc_addr = 0;
                 m_BUF[i].cma_page_count = 0;
-                break;
             }
-            m_BUF[i].start_adr = page_to_phys(m_BUF[i].alloc_pages);
-            printk("allocate cma buffer[%d] (%d,%x,%x)\n", i, m_BUF[i].cma_page_count , (unsigned)m_BUF[i].alloc_pages, (unsigned)m_BUF[i].start_adr);
-        }
-        else{
-            printk("reuse cma buffer[%d] (%d,%x,%x)\n", i, m_BUF[i].cma_page_count , (unsigned)m_BUF[i].alloc_pages, (unsigned)m_BUF[i].start_adr);
+            if (m_BUF[i].alloc_addr == 0) {
+                m_BUF[i].cma_page_count =
+                PAGE_ALIGN(buf_size) / PAGE_SIZE;
+                m_BUF[i].alloc_addr = codec_mm_alloc_for_dma(
+                MEM_NAME, m_BUF[i].cma_page_count,
+                4 + PAGE_SHIFT, 0);
+                if (m_BUF[i].alloc_addr == 0) {
+                    pr_info("alloc cma buffer[%d] fail\n", i);
+                    m_BUF[i].cma_page_count = 0;
+                    break;
+                }
+                pr_info("allocate cma buffer[%d] (%d,%ld,%ld)\n",
+                i, m_BUF[i].cma_page_count,
+                m_BUF[i].alloc_addr,
+                m_BUF[i].start_adr);
+            } else {
+                pr_info("reuse cma buffer[%d] (%d,%ld,%ld)\n",
+                   i,
+                   m_BUF[i].cma_page_count,
+                   m_BUF[i].alloc_addr,
+                   m_BUF[i].start_adr);
+            }
+            m_BUF[i].start_adr =  m_BUF[i].alloc_addr;
+        } else {
+            m_BUF[i].cma_page_count = 0;
+            m_BUF[i].alloc_addr = 0;
+            m_BUF[i].start_adr =
+            hevc->mc_buf->buf_start + i * buf_size;
         }
-		}
-		else{
-		    m_BUF[i].cma_page_count = 0;
-		    m_BUF[i].alloc_pages = NULL;
-		    m_BUF[i].start_adr = hevc->mc_buf->buf_start + i*buf_size;
-    }		    
-    m_BUF[i].size = buf_size;
-    m_BUF[i].free_start_adr = m_BUF[i].start_adr;
-
-		if(((m_BUF[i].start_adr+buf_size) > mc_buffer_end) && (m_BUF[i].alloc_pages==NULL)){
-	    if(debug) printk("Max mc buffer or mpred_mv buffer is used\n");		
-			break;
-		}
+        m_BUF[i].size = buf_size;
+        m_BUF[i].free_start_adr = m_BUF[i].start_adr;
 
-    if(debug){
-        printk("Buffer %d: start_adr %lx size %lx\n", i, m_BUF[i].start_adr, m_BUF[i].size);
+        if (((m_BUF[i].start_adr + buf_size) > mc_buffer_end)
+            && (m_BUF[i].alloc_addr == 0)) {
+            if (debug) {
+                pr_info("Max mc buffer or mpred_mv buffer is used\n");
+            }
+            break;
+        }
+        if (debug) {
+            pr_info("Buffer %d: start_adr %p size %x\n", i,
+                (void *)m_BUF[i].start_adr, m_BUF[i].size);
+        }
     }
-	}
-	
+
 	hevc->buf_num = i;
 
 }
diff --git a/drivers/amlogic/codec_mm/Kconfig b/drivers/amlogic/codec_mm/Kconfig
new file mode 100644
index 000000000000..76f1b58a3542
--- /dev/null
+++ b/drivers/amlogic/codec_mm/Kconfig
@@ -0,0 +1,9 @@
+#
+# Codec mermory manager driver configuration
+#
+#
+config AML_CODEC_MM
+	boolean "Amlogic codec memory management driver"
+	default n
+	---help---
+          Select to enable codec related memory management driver.
diff --git a/drivers/amlogic/codec_mm/Makefile b/drivers/amlogic/codec_mm/Makefile
new file mode 100644
index 000000000000..de05c0c04a3e
--- /dev/null
+++ b/drivers/amlogic/codec_mm/Makefile
@@ -0,0 +1,12 @@
+##########################################
+########## Amlogic codec memory manager ###############
+##########################################
+
+##########################################
+## The order of directories matter.
+## Do not change.
+##########################################
+
+
+obj-$(CONFIG_AML_CODEC_MM)	+= codec_mm.o
+
diff --git a/drivers/amlogic/codec_mm/codec_mm.c b/drivers/amlogic/codec_mm/codec_mm.c
new file mode 100644
index 000000000000..3902ea872977
--- /dev/null
+++ b/drivers/amlogic/codec_mm/codec_mm.c
@@ -0,0 +1,803 @@
+/*
+ * drivers/amlogic/codec_mm/codec_mm.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+
+///#include <linux/cma.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/libfdt_env.h>
+//#include <linux/of_reserved_mem.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/genalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+
+#include "codec_mm_priv.h"
+
+
+struct reserved_mem {
+    unsigned long base;
+    int size;
+
+};
+
+#define CODEC_MM_FOR_DMA_ONLY(flags) \
+    ((flags & CODEC_MM_FLAGS_FROM_MASK) == CODEC_MM_FLAGS_DMA)
+
+#define CODEC_MM_FOR_CPU_ONLY(flags) \
+    ((flags & CODEC_MM_FLAGS_FROM_MASK) == CODEC_MM_FLAGS_CPU)
+
+#define CODEC_MM_FOR_DMACPU(flags) \
+    ((flags & CODEC_MM_FLAGS_FROM_MASK) == CODEC_MM_FLAGS_DMA_CPU)
+
+#define RESERVE_MM_ALIGNED_2N   17
+
+struct codec_mm_mgt_s {
+    struct cma *cma;
+    struct device *dev;
+    struct list_head mem_list;
+    struct gen_pool *res_pool;
+    struct gen_pool *tvp_pool;
+    struct reserved_mem rmem;
+    struct reserved_mem tvp_rmem;
+    int total_codec_mem_size;
+    int total_alloced_size;
+    int max_used_mem_size;
+
+    int alloced_res_size;
+    int alloced_cma_size;
+    int alloced_sys_size;
+    int alloced_tvp_size;
+
+    int alloc_from_sys_pages_max;
+    int enable_kmalloc_on_nomem;
+    spinlock_t lock;
+};
+
+#define PHY_OFF() offsetof(struct codec_mm_s, phy_addr)
+#define HANDLE_OFF() offsetof(struct codec_mm_s, mem_handle)
+#define VADDR_OFF() offsetof(struct codec_mm_s, vbuffer)
+#define VAL_OFF_VAL(mem, off) (*(unsigned long *)((unsigned long)(mem) + off))
+
+static struct codec_mm_mgt_s *get_mem_mgt(void) {
+    static struct codec_mm_mgt_s mgt;
+    static int inited;
+
+    if (!inited) {
+        memset(&mgt, 0, sizeof(struct codec_mm_mgt_s));
+        inited++;
+    }
+    return &mgt;
+};
+
+static int codec_mm_alloc_in(
+    struct codec_mm_mgt_s *mgt, struct codec_mm_s *mem)
+{
+    int try_alloced_from_sys = 0;
+    int try_alloced_from_reserved = 0;
+    int align_2n = mem->align2n < PAGE_SHIFT ? PAGE_SHIFT : mem->align2n;
+    int try_cma_first = mem->flags & CODEC_MM_FLAGS_CMA_FIRST;
+    do {
+        if ((mem->flags & CODEC_MM_FLAGS_DMA_CPU) &&
+            mem->page_count <= mgt->alloc_from_sys_pages_max &&
+            align_2n <= PAGE_SHIFT) {
+            mem->mem_handle = (void *)__get_free_pages(GFP_KERNEL,
+                              get_order(mem->buffer_size));
+            mem->from_flags =
+                AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES;
+            if (mem->mem_handle) {
+                mem->vbuffer = mem->mem_handle;
+                mem->phy_addr = virt_to_phys(mem->mem_handle);
+                break;
+            }
+            try_alloced_from_sys = 1;
+        }
+        /*reserved first..*/
+        if (!try_cma_first && /*if cma first, ignore this alloc.*/
+            (CODEC_MM_FOR_DMA_ONLY(mem->flags) |
+             (mem->flags & CODEC_MM_FLAGS_RESERVED))
+            && mgt->res_pool != NULL &&
+            (align_2n <= RESERVE_MM_ALIGNED_2N)) {
+            int aligned_buffer_size = ALIGN(mem->buffer_size,
+                                            (1 << RESERVE_MM_ALIGNED_2N));
+            mem->mem_handle = (void *)gen_pool_alloc(mgt->res_pool,
+                              aligned_buffer_size);
+            mem->from_flags =
+                AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED;
+            if (mem->mem_handle) {
+                /*default is no maped */
+                mem->vbuffer = NULL;
+                mem->phy_addr = (unsigned long)mem->mem_handle;
+                mem->buffer_size = aligned_buffer_size;
+                break;
+            }
+            try_alloced_from_reserved = 1;
+        }
+        /*cma first..*/
+        if (mem->flags &
+            (CODEC_MM_FLAGS_CMA | CODEC_MM_FLAGS_DMA_CPU)) {
+            mem->mem_handle = dma_alloc_from_contiguous(mgt->dev,
+                              mem->page_count,
+                              align_2n - PAGE_SHIFT);
+            mem->from_flags = AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA;
+            if (mem->mem_handle) {
+                mem->vbuffer = mem->mem_handle;
+                mem->phy_addr =
+                    page_to_phys((struct page *)mem->mem_handle);
+#ifdef CONFIG_ARM64
+                if (mem->flags & CODEC_MM_FLAGS_CMA_CLEAR) {
+                    dma_clear_buffer(
+                        (struct page *)mem->vbuffer,
+                        mem->buffer_size);
+                }
+#endif
+                break;
+            }
+        }
+
+        if (!try_alloced_from_reserved &&
+            (CODEC_MM_FOR_DMA_ONLY(mem->flags) |
+             (mem->flags & CODEC_MM_FLAGS_RESERVED))
+            && mgt->res_pool != NULL &&
+            (align_2n <= RESERVE_MM_ALIGNED_2N)) {
+            int aligned_buffer_size = ALIGN(mem->buffer_size,
+                                            (1 << RESERVE_MM_ALIGNED_2N));
+            mem->mem_handle = (void *)gen_pool_alloc(mgt->res_pool,
+                              aligned_buffer_size);
+            mem->from_flags =
+                AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED;
+            if (mem->mem_handle) {
+                /*default is no maped */
+                mem->vbuffer = NULL;
+                mem->phy_addr = (unsigned long)mem->mem_handle;
+                mem->buffer_size = aligned_buffer_size;
+                break;
+            }
+        }
+
+        if ((mem->flags & CODEC_MM_FLAGS_TVP) &&
+            mgt->tvp_pool != NULL &&
+            align_2n <= RESERVE_MM_ALIGNED_2N) {
+            /* 64k,aligend */
+            int aligned_buffer_size = ALIGN(mem->buffer_size,
+                                            (1 << RESERVE_MM_ALIGNED_2N));
+            mem->mem_handle = (void *)gen_pool_alloc(mgt->tvp_pool,
+                              aligned_buffer_size);
+            mem->from_flags =
+                AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED;
+            if (mem->mem_handle) {
+                /*no vaddr for TVP MEMORY */
+                mem->vbuffer = NULL;
+                mem->phy_addr = (unsigned long)mem->mem_handle;
+                mem->buffer_size = aligned_buffer_size;
+                break;
+            }
+        }
+
+        if ((mem->flags & CODEC_MM_FLAGS_DMA_CPU) &&
+            mgt->enable_kmalloc_on_nomem &&
+            !try_alloced_from_sys) {
+            mem->mem_handle = (void *)__get_free_pages(GFP_KERNEL,
+                              get_order(mem->buffer_size));
+            mem->from_flags =
+                AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES;
+            if (mem->mem_handle) {
+                mem->vbuffer = mem->mem_handle;
+                mem->phy_addr =
+                    virt_to_phys((void *)mem->mem_handle);
+                break;
+            }
+        }
+    } while (0);
+    if (mem->mem_handle) {
+        return 0;
+    } else {
+        return -ENOMEM;
+    }
+}
+
+static void codec_mm_free_in(struct codec_mm_mgt_s *mgt,
+                             struct codec_mm_s *mem)
+{
+    mgt->total_alloced_size -= mem->buffer_size;
+    if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA) {
+        dma_release_from_contiguous(mgt->dev,
+                                    mem->mem_handle, mem->page_count);
+        mgt->alloced_cma_size -= mem->buffer_size;
+    } else if (mem->from_flags ==
+               AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED) {
+        gen_pool_free(mgt->res_pool,
+                      (unsigned long)mem->mem_handle, mem->buffer_size);
+        mgt->alloced_res_size -= mem->buffer_size;
+    } else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP) {
+        gen_pool_free(mgt->tvp_pool,
+                      (unsigned long)mem->mem_handle, mem->buffer_size);
+        mgt->alloced_tvp_size -= mem->buffer_size;
+    } else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES) {
+        __free_pages((struct page *)mem->mem_handle,
+                     get_order(mem->buffer_size));
+        mgt->alloced_sys_size -= mem->buffer_size;
+    }
+
+    return;
+}
+
+static struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
+        int align2n, int memflags) {
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    struct codec_mm_s *mem = kmalloc(sizeof(struct codec_mm_s),
+                                     GFP_KERNEL);
+    int count;
+    int ret;
+    unsigned long flags;
+
+    if (!mem) {
+        pr_err("not enough mem for struct codec_mm_s\n");
+        return NULL;
+    }
+
+    if ((memflags & CODEC_MM_FLAGS_FROM_MASK) == 0) {
+        memflags |= CODEC_MM_FLAGS_DMA;
+    }
+
+    memset(mem, 0, sizeof(struct codec_mm_s));
+    mem->buffer_size = PAGE_ALIGN(size);
+    count = mem->buffer_size / PAGE_SIZE;
+    mem->page_count = count;
+    mem->align2n = align2n;
+    mem->flags = memflags;
+    ret = codec_mm_alloc_in(mgt, mem);
+    if (ret < 0) {
+        pr_err("not enough mem for %s size %d\n", owner, size);
+        kfree(mem);
+        return NULL;
+    }
+
+    atomic_set(&mem->use_cnt, 1);
+    mem->owner[0] = owner;
+    spin_lock_init(&mem->lock);
+    spin_lock_irqsave(&mgt->lock, flags);
+    list_add_tail(&mem->list, &mgt->mem_list);
+    switch (mem->from_flags) {
+    case AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES:
+        mgt->alloced_sys_size += mem->buffer_size;
+        break;
+    case AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA:
+        mgt->alloced_cma_size += mem->buffer_size;
+        break;
+    case AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP:
+        mgt->alloced_tvp_size += mem->buffer_size;
+        break;
+    case AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED:
+        mgt->alloced_res_size += mem->buffer_size;
+        break;
+    default:
+        pr_err("error alloc flags %d\n", mem->from_flags);
+    }
+    mgt->total_alloced_size += mem->buffer_size;
+    if (mgt->total_alloced_size > mgt->max_used_mem_size) {
+        mgt->max_used_mem_size = mgt->total_alloced_size;
+    }
+    spin_unlock_irqrestore(&mgt->lock, flags);
+    /*
+    pr_err("%s alloc mem size %d at %lx from %d\n",
+            owner, size, mem->phy_addr,
+            mem->from_flags);
+    */
+    return mem;
+}
+
+static void codec_mm_release(struct codec_mm_s *mem, const char *owner)
+{
+
+    int index;
+    unsigned long flags;
+    int i;
+    const char *max_owner;
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    if (!mem) {
+        return;
+    }
+
+    spin_lock_irqsave(&mem->lock, flags);
+    index = atomic_dec_return(&mem->use_cnt);
+    max_owner = mem->owner[index];
+    for (i = 0; i < index; i++) {
+        if (mem->owner[i] && strcmp(owner, mem->owner[i]) == 0) {
+            mem->owner[i] = max_owner;
+        }
+    }
+    mem->owner[index] = NULL;
+    if (index == 0) {
+        spin_unlock_irqrestore(&mem->lock, flags);
+        codec_mm_free_in(mgt, mem);
+        list_del(&mem->list);
+        kfree(mem);
+        return;
+    }
+    spin_unlock_irqrestore(&mem->lock, flags);
+    return;
+}
+
+void codec_mm_dma_flush(void *vaddr,
+                        int size,
+                        enum dma_data_direction dir)
+{
+
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    dma_addr_t dma_addr;
+    dma_addr = dma_map_single(mgt->dev, vaddr, size, dir);
+    if (dma_addr) {
+        dma_unmap_single(mgt->dev, dma_addr, size, dir);
+    }
+    return;
+}
+
+int codec_mm_request_shared_mem(struct codec_mm_s *mem, const char *owner)
+{
+    if (!mem || atomic_read(&mem->use_cnt) > 7) {
+        return -1;
+    }
+    mem->owner[atomic_inc_return(&mem->use_cnt) - 1] = owner;
+    return 0;
+}
+
+static struct codec_mm_s *codec_mm_get_by_val_off(unsigned long val, int off) {
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    struct codec_mm_s *mem, *want_mem;
+    unsigned long flags;
+
+    want_mem = NULL;
+    spin_lock_irqsave(&mgt->lock, flags);
+    if (!list_empty(&mgt->mem_list)) {
+        list_for_each_entry(mem, &mgt->mem_list, list) {
+            if (mem && VAL_OFF_VAL(mem, off) == val) {
+                want_mem = mem;
+            }
+        }
+    }
+    spin_unlock_irqrestore(&mgt->lock, flags);
+    return want_mem;
+}
+
+unsigned long codec_mm_alloc_for_dma(const char *owner, int page_cnt,
+                                     int align2n, int memflags)
+{
+    struct codec_mm_s *mem;
+    mem = codec_mm_alloc(owner, page_cnt << PAGE_SHIFT, align2n, memflags);
+    if (!mem) {
+        return 0;
+    }
+    return mem->phy_addr;
+}
+
+int codec_mm_free_for_dma(const char *owner, unsigned long phy_addr)
+{
+    struct codec_mm_s *mem;
+    mem = codec_mm_get_by_val_off(phy_addr, PHY_OFF());
+
+    if (mem) {
+        codec_mm_release(mem, owner);
+    } else {
+        return -1;
+    }
+    return 0;
+}
+
+
+void *codec_mm_phys_to_virt(unsigned long phy_addr)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+    if (phy_addr >= mgt->rmem.base &&
+        phy_addr < mgt->rmem.base + mgt->rmem.size) {
+        return NULL;    /* no virt for reserved memory; */
+    }
+    if (phy_addr >= mgt->tvp_rmem.base &&
+        phy_addr < mgt->tvp_rmem.base + mgt->tvp_rmem.size) {
+        return NULL;    /* no virt for tvp memory; */
+    }
+    return phys_to_virt(phy_addr);
+}
+
+unsigned long codec_mm_virt_to_phys(void *vaddr)
+{
+    return page_to_phys((struct page *)vaddr);
+}
+
+int codec_mm_get_cma_size(void)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    return dma_get_cma_size(mgt->dev);
+}
+int dump_mem_infos(void *buf, int size)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    struct codec_mm_s *mem;
+    unsigned long flags;
+
+    char *pbuf = buf;
+    char sbuf[512];
+    int tsize = 0;
+    int s;
+
+    if (!pbuf) {
+        pbuf = sbuf;
+    }
+    s = sprintf(pbuf, "codec mem info:\n\ttotal codec mem size:%d MB\n",
+                mgt->total_codec_mem_size / SZ_1M);
+    tsize += s;
+    pbuf += s;
+
+    s = sprintf(pbuf, "\talloced size= %d MB\n\tmax alloced: %d MB\n",
+                mgt->total_alloced_size / SZ_1M,
+                mgt->max_used_mem_size / SZ_1M);
+    tsize += s;
+    pbuf += s;
+
+    s = sprintf(pbuf, "\tCMA:%d,RES:%d,TVP:%d,SYS:%d MB\n",
+                mgt->alloced_cma_size / SZ_1M,
+                mgt->alloced_res_size / SZ_1M,
+                mgt->alloced_tvp_size / SZ_1M,
+                mgt->alloced_sys_size / SZ_1M);
+    tsize += s;
+    pbuf += s;
+
+    if (mgt->res_pool) {
+        s = sprintf(pbuf,
+                    "\t[%d]RES size:%d MB,alloced:%d MB free:%d MB\n",
+                    AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED,
+                    (int)(gen_pool_size(mgt->res_pool) / SZ_1M),
+                    (int)(mgt->alloced_res_size / SZ_1M),
+                    (int)(gen_pool_avail(mgt->res_pool) / SZ_1M));
+        tsize += s;
+        pbuf += s;
+    }
+
+    s = sprintf(pbuf, "\t[%d]CMA size:%d MB:alloced: %d MB,free:%d MB\n",
+                AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA,
+                (int)(codec_mm_get_cma_size() / SZ_1M),
+                (int)(mgt->alloced_cma_size / SZ_1M),
+                (int)((codec_mm_get_cma_size() -
+                       mgt->alloced_cma_size) / SZ_1M));
+    tsize += s;
+    pbuf += s;
+
+    if (!buf && tsize > 0) {
+        pr_info("%s", sbuf);
+        pbuf = sbuf;
+        sbuf[0] = '\0';
+        tsize = 0;
+    }
+    spin_lock_irqsave(&mgt->lock, flags);
+    if (list_empty(&mgt->mem_list)) {
+        spin_unlock_irqrestore(&mgt->lock, flags);
+        return tsize;
+    }
+    list_for_each_entry(mem, &mgt->mem_list, list) {
+        s = sprintf(pbuf,
+                    "\towner: %s:%s,addr=%p,s=%d,from=%d,cnt=%d\n",
+                    mem->owner[0] ? mem->owner[0] : "no",
+                    mem->owner[1] ? mem->owner[1] : "no",
+                    (void *)mem->phy_addr,
+                    mem->buffer_size, mem->from_flags,
+                    atomic_read(&mem->use_cnt));
+
+        if (buf) {
+            pbuf += s;
+        } else {
+            pr_info("%s", sbuf);
+        }
+        tsize += s;
+    }
+    spin_unlock_irqrestore(&mgt->lock, flags);
+
+    return tsize;
+}
+
+int codec_mm_get_total_size(void)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    return mgt->total_codec_mem_size;
+}
+
+int codec_mm_get_free_size(void)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    return mgt->total_codec_mem_size -
+           mgt->total_alloced_size;
+}
+
+int codec_mm_get_reserved_size(void)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    return mgt->rmem.size & (~((1 << RESERVE_MM_ALIGNED_2N) - 1));
+}
+
+int codec_mm_mgt_init(struct device *dev)
+{
+
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    INIT_LIST_HEAD(&mgt->mem_list);
+    mgt->dev = dev;
+    mgt->alloc_from_sys_pages_max = 4;
+    if (mgt->rmem.size > 0) {
+        unsigned long aligned_addr;
+        int aligned_size;
+        /*mem aligned,*/
+        mgt->res_pool = gen_pool_create(RESERVE_MM_ALIGNED_2N, -1);
+        if (!mgt->res_pool) {
+            return -ENOMEM;
+        }
+        aligned_addr = ((unsigned long)mgt->rmem.base +
+                        ((1 << RESERVE_MM_ALIGNED_2N) - 1)) &
+                       (~((1 << RESERVE_MM_ALIGNED_2N) - 1));
+        aligned_size = mgt->rmem.size -
+                       (int)(aligned_addr - (unsigned long)mgt->rmem.base);
+        gen_pool_add(mgt->res_pool,
+                     aligned_addr, aligned_size, -1);
+        pr_info("add reserve memory %p(aligned %p) size=%x(aligned %x)\n",
+                (void *)mgt->rmem.base, (void *)aligned_addr,
+                (int)mgt->rmem.size, (int)aligned_size);
+        mgt->total_codec_mem_size = aligned_size;
+    }
+    mgt->total_codec_mem_size += codec_mm_get_cma_size();
+    spin_lock_init(&mgt->lock);
+    return 0;
+}
+
+static int __init amstream_test_init(void)
+{
+#if 0
+    unsigned long buf[4];
+    struct codec_mm_s *mem[20];
+    mem[0] = codec_mm_alloc("test0", 1024 * 1024, 0, 0);
+    mem[1] = codec_mm_alloc("test1", 1024 * 1024, 0, 0);
+    mem[2] = codec_mm_alloc("test2", 1024 * 1024, 0, 0);
+    mem[3] = codec_mm_alloc("test32", 1024 * 1024, 0, 0);
+    mem[4] = codec_mm_alloc("test3", 400 * 1024, 0, 0);
+    mem[5] = codec_mm_alloc("test3", 400 * 1024, 0, 0);
+    mem[6] = codec_mm_alloc("test666", 400 * 1024, 0, 0);
+    mem[7] = codec_mm_alloc("test3", 8 * 1024 * 1024, 0, 0);
+    mem[8] = codec_mm_alloc("test4", 3 * 1024 * 1024, 0, 0);
+    pr_info("TT:%p,%p,%p,%p\n", mem[0], mem[1], mem[2], mem[3]);
+    dump_mem_infos(NULL, 0);
+    codec_mm_release(mem[1], "test1");
+    codec_mm_release(mem[7], "test3");
+    codec_mm_request_shared_mem(mem[3], "test55");
+    codec_mm_request_shared_mem(mem[6], "test667");
+    dump_mem_infos(NULL, 0);
+    codec_mm_release(mem[3], "test32");
+    codec_mm_release(mem[0], "test1");
+    codec_mm_request_shared_mem(mem[3], "test57");
+    codec_mm_request_shared_mem(mem[3], "test58");
+    codec_mm_release(mem[3], "test55");
+    dump_mem_infos(NULL, 0);
+    mem[8] = codec_mm_alloc("test4", 8 * 1024 * 1024, 0,
+                            CODEC_MM_FLAGS_DMA);
+    mem[9] = codec_mm_alloc("test5", 4 * 1024 * 1024, 0,
+                            CODEC_MM_FLAGS_TVP);
+    mem[10] = codec_mm_alloc("test6", 10 * 1024 * 1024, 0,
+                             CODEC_MM_FLAGS_DMA_CPU);
+    dump_mem_infos(NULL, 0);
+
+
+
+    buf[0] = codec_mm_alloc_for_dma("streambuf1",
+                                    8 * 1024 * 1024 / PAGE_SIZE, 0, 0);
+    buf[1] = codec_mm_alloc_for_dma("streambuf2",
+                                    2 * 1024 * 1024 / PAGE_SIZE, 0, 0);
+    buf[2] = codec_mm_alloc_for_dma("streambuf2",
+                                    118 * 1024 / PAGE_SIZE, 0, 0);
+    buf[3] = codec_mm_alloc_for_dma("streambuf2",
+                                    (jiffies & 0x7f) * 1024 / PAGE_SIZE, 0, 0);
+    dump_mem_infos(NULL, 0);
+    codec_mm_free_for_dma("streambuf2", buf[3]);
+    codec_mm_free_for_dma("streambuf2", buf[1]);
+    codec_mm_free_for_dma("streambuf2", buf[2]);
+    codec_mm_free_for_dma("streambuf1", buf[0]);
+    dump_mem_infos(NULL, 0);
+#endif
+
+    return 0;
+}
+
+static ssize_t codec_mm_dump_show(struct class *class,
+                                  struct class_attribute *attr, char *buf)
+{
+    size_t ret;
+    ret = dump_mem_infos(buf, PAGE_SIZE);
+    return ret;
+}
+
+static struct class_attribute codec_mm_class_attrs[] = {
+    __ATTR_RO(codec_mm_dump),
+    __ATTR_NULL
+};
+
+static struct class codec_mm_class = {
+        .name = "codec_mm",
+        .class_attrs = codec_mm_class_attrs,
+    };
+
+static int codec_mm_probe(struct platform_device *pdev)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    int r;
+    const void * name;
+    int offset, size;
+    r = class_register(&codec_mm_class);
+    if (r) {
+        pr_info("vdec class create fail.\n");
+        return r;
+    }
+    pdev->dev.platform_data = mgt;
+    do {
+        r = find_reserve_block(pdev->dev.of_node->name, 0);
+        if (r < 0) {
+            name = of_get_property(pdev->dev.of_node, "share-memory-name", NULL);
+            if (!name) {
+                printk("can not find %s%d reserve block1\n", codec_mm_class.name, 0);
+                r = -EFAULT;
+                break;
+
+            } else {
+                r = find_reserve_block_by_name(name);
+                if (r < 0) {
+                    printk("can not find %s%d reserve block2\n", codec_mm_class.name, 0);
+                    r = -EFAULT;
+                    break;
+                }
+                name = of_get_property(pdev->dev.of_node, "share-memory-offset", NULL);
+                if (name) {
+                    offset = of_read_ulong(name, 1);
+                } else {
+                    printk("can not find %s%d reserve block3\n", codec_mm_class.name, 0);
+                    r = -EFAULT;
+                    break;
+                }
+                name = of_get_property(pdev->dev.of_node, "share-memory-size", NULL);
+                if (name) {
+                    size = of_read_ulong(name, 1);
+                } else {
+                    printk("can not find %s%d reserve block4\n", codec_mm_class.name, 0);
+                    r = -EFAULT;
+                    break;
+                }
+
+                mgt->rmem.base = (phys_addr_t)get_reserve_block_addr(r) + offset;
+                mgt->rmem.size = size;
+            }
+        } else {
+            mgt->rmem.base = (phys_addr_t)get_reserve_block_addr(r);
+            mgt->rmem.size = (phys_addr_t)get_reserve_block_size(r);
+        }
+    } while (0);
+
+    codec_mm_mgt_init(&pdev->dev);
+
+    pr_info("codec_mm_probe ok\n");
+    amstream_test_init();
+
+    return 0;
+}
+
+static const struct of_device_id amlogic_mem_dt_match[] = {
+    {
+        .compatible = "amlogic, codec, mm",
+    },
+    {},
+};
+
+static struct platform_driver codec_mm_driver = {
+    .probe = codec_mm_probe,
+    .remove = NULL,
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = "codec_mm",
+        .of_match_table = amlogic_mem_dt_match,
+
+    }
+};
+
+static int __init codec_mm_module_init(void)
+{
+
+    pr_err("codec_mm_module_init\n");
+
+    if (platform_driver_register(&codec_mm_driver)) {
+        pr_err("failed to register amports mem module\n");
+        return -ENODEV;
+
+    }
+
+    return 0;
+}
+
+arch_initcall(codec_mm_module_init);
+MODULE_DESCRIPTION("AMLOGIC amports mem  driver");
+MODULE_LICENSE("GPL");
+
+#if 0
+static int __init codec_mm_cma_setup(struct reserved_mem *rmem)
+{
+    int ret;
+    phys_addr_t base, size, align;
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+    align = (phys_addr_t) PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);
+    base = ALIGN(rmem->base, align);
+    size = round_down(rmem->size - (base - rmem->base), align);
+    ret = cma_init_reserved_mem(base, size, 0, &mgt->cma);
+    if (ret) {
+        pr_info("TT:vdec: cma init reserve area failed.\n");
+        mgt->cma = NULL;
+        return ret;
+    }
+
+#ifndef CONFIG_ARM64
+    dma_contiguous_early_fixup(base, size);
+#endif
+    pr_info("TT:vdec: cma setup\n");
+    return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(codec_mm_cma, "amlogic, codec-mm-cma",
+                       codec_mm_cma_setup);
+
+#endif
+
+#if 0
+static int codec_mm_reserved_init(struct reserved_mem *rmem, struct device *dev)
+{
+    struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+    mgt->rmem = *rmem;
+    pr_info("codec_mm_reserved_init %p->%p\n",
+            (void *)mgt->rmem.base,
+            (void *)mgt->rmem.base + mgt->rmem.size);
+    return 0;
+}
+
+static const struct reserved_mem_ops codec_mm_rmem_vdec_ops = {
+    .device_init = codec_mm_reserved_init,
+};
+
+static int __init codec_mm_res_setup(struct reserved_mem *rmem)
+{
+    rmem->ops = &codec_mm_rmem_vdec_ops;
+    pr_info("vdec: reserved mem setup\n");
+
+    return 0;
+}
+
+
+RESERVEDMEM_OF_DECLARE(codec_mm_reserved, "amlogic, codec-mm-reserved",
+                       codec_mm_res_setup);
+#endif
diff --git a/drivers/amlogic/codec_mm/codec_mm_priv.h b/drivers/amlogic/codec_mm/codec_mm_priv.h
new file mode 100644
index 000000000000..c010a719edb2
--- /dev/null
+++ b/drivers/amlogic/codec_mm/codec_mm_priv.h
@@ -0,0 +1,70 @@
+/*
+ * drivers/amlogic/codec_mm/codec_mm.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef AML_MM_HEADER
+#define AML_MM_HEADER
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+struct codec_mm_s {
+
+    /*can be shared by many user */
+    const char *owner[8];
+
+    /*virtual buffer of this memory */
+    char *vbuffer;
+
+    void *mem_handle;   /*used for top level.alloc/free */
+
+    ulong phy_addr;     /*if phy continue or one page only */
+
+    int buffer_size;
+
+    int page_count;
+
+    int align2n;
+
+    /*if vbuffer is no cache set
+       AMPORTS_MEM_FLAGS_NOCACHED  to flags */
+#define AMPORTS_MEM_FLAGS_NOCACHED (1<<0)
+    /*phy continue,need dma
+     */
+#define AMPORTS_MEM_FLAGS_DMA (1<<1)
+    int flags;
+
+#define AMPORTS_MEM_FLAGS_FROM_SYS 1
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES 2
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED 3
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA 4
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP 5
+
+    int from_flags;
+
+    /*may can be shared on many user..
+       decoder/di/ppmgr,
+     */
+    atomic_t use_cnt;
+
+    spinlock_t lock;
+
+    struct list_head list;
+
+};
+extern void dma_clear_buffer(struct page *page, size_t size);
+#endif              /*
+*/
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
index 3e4a4f49ae3f..f64f3f1eb752 100644
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -571,3 +571,10 @@ bool dma_release_from_contiguous(struct device *dev, struct page *pages,
 
 	return true;
 }
+
+int dma_get_cma_size(struct device *dev)
+{
+	struct cma *cma = dev_get_cma_area(dev);
+	return cma->count * PAGE_SIZE;
+}
+
diff --git a/include/linux/amlogic/codec_mm/codec_mm.h b/include/linux/amlogic/codec_mm/codec_mm.h
new file mode 100644
index 000000000000..f861a93240b6
--- /dev/null
+++ b/include/linux/amlogic/codec_mm/codec_mm.h
@@ -0,0 +1,78 @@
+
+/*
+ * include/linux/amlogic/codec_mm/codec_mm.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CODEC_MM_API_HEADER
+#define CODEC_MM_API_HEADER
+#include <linux/dma-direction.h>
+
+/*
+memflags
+*/
+#define CODEC_MM_FLAGS_DMA 1
+#define CODEC_MM_FLAGS_CPU 2
+#define CODEC_MM_FLAGS_TVP 4
+
+#define CODEC_MM_FLAGS_RESERVED 0x100
+#define CODEC_MM_FLAGS_CMA      0x200
+/*alloc from cma first,
+cma->then ..reserved.
+for less memory fragment;
+*/
+#define CODEC_MM_FLAGS_CMA_FIRST 0x400
+
+/*if cma,
+clear thie buffer cache.
+*/
+#define CODEC_MM_FLAGS_CMA_CLEAR 0x10000
+
+
+#define CODEC_MM_FLAGS_FROM_MASK \
+    (CODEC_MM_FLAGS_DMA |\
+    CODEC_MM_FLAGS_CPU |\
+    CODEC_MM_FLAGS_TVP)
+
+#define CODEC_MM_FLAGS_DMA_CPU  (CODEC_MM_FLAGS_DMA | CODEC_MM_FLAGS_CPU)
+#define CODEC_MM_FLAGS_ANY  CODEC_MM_FLAGS_DMA_CPU
+
+
+
+
+
+unsigned long codec_mm_alloc_for_dma(const char *owner, int page_cnt,
+                                     int align2n, int memflags);
+int codec_mm_free_for_dma(const char *owner, unsigned long phy_addr);
+
+void *codec_mm_phys_to_virt(unsigned long phy_addr);
+unsigned long codec_mm_virt_to_phys(void *vaddr);
+
+void codec_mm_dma_flush(void *vaddr,
+                        int size,
+                        enum dma_data_direction dir);
+
+
+
+
+int codec_mm_get_total_size(void);
+int codec_mm_get_free_size(void);
+int codec_mm_get_reserved_size(void);
+
+
+
+#endif  /*
+*/
+
diff --git a/include/linux/dma-contiguous.h b/include/linux/dma-contiguous.h
old mode 100755
new mode 100644
index 3216448a5c10..9deb57ea9e88
--- a/include/linux/dma-contiguous.h
+++ b/include/linux/dma-contiguous.h
@@ -115,6 +115,7 @@ struct page *dma_alloc_from_contiguous(struct device *dev, int count,
 bool dma_release_from_contiguous(struct device *dev, struct page *pages,
 				 int count);
 
+int dma_get_cma_size(struct device *dev);
 #else
 
 #define MAX_CMA_AREAS	(0)
@@ -141,7 +142,10 @@ bool dma_release_from_contiguous(struct device *dev, struct page *pages,
 {
 	return false;
 }
-
+static inline int dma_get_cma_size(struct device *dev)
+{
+	return 0;
+}
 #endif
 
 #endif
-- 
2.19.0

