From bc81c054addc0b4c0f3e8b806a8d96e74546111e Mon Sep 17 00:00:00 2001
From: Evoke Zhang <evoke.zhang@amlogic.com>
Date: Sat, 10 Oct 2015 17:49:44 +0800
Subject: [PATCH 5876/5965] PD#113733: lcd_tv: uboot support 50hz compatible
 with kernel

Change-Id: I500143f4ae43260b452f35e32274810160a389c8
---
 arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd  |   8 +-
 arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd  |  10 +-
 .../display/lcd/aml_lcd_extern/lcd_extern.c   |  12 +-
 drivers/amlogic/display/lcd/aml_lcd_tv.c      | 459 ++++++++++--------
 drivers/amlogic/display/lcd/aml_lcd_tv.h      | 108 ++---
 .../display/lcd/aml_tv_lcd_port/lcd_common.c  | 191 +++++++-
 .../display/lcd/aml_tv_lcd_port/lcd_common.h  |   4 +-
 .../display/lcd/aml_tv_lcd_port/lvds_drv.c    | 149 +++---
 .../display/lcd/aml_tv_lcd_port/vbyone_drv.c  |  47 +-
 9 files changed, 605 insertions(+), 383 deletions(-)

diff --git a/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd b/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
index 41b77c3f02b6..eeb03ff28363 100644
--- a/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9bb_n303.dtd
@@ -736,10 +736,10 @@
 		/* AOC: public Platform lvds : 1920x1080@60hz 8bit pixel clk@74.25mhz 2prot*/
 		lvds_0{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<148000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1920 1080 2200 1125 148 41>; /**h_active v_active h_period v_period h_blank v_blank*/
 			lcd_timing = <0x500404ad 0x00414400 0x71486980 44 2156 0 1079 2100 2164 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -749,10 +749,10 @@
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
 		lvds_2{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<80000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1648 810 280 42>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -765,6 +765,7 @@
 			basic_setting = <1366 768 1560 806 190 30>;
 			lcd_timing = <0x500404ad 0x00454400 0x71486980 20 30 0 809 20 1200 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -774,10 +775,10 @@
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
 		lvds_4{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<82000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1696 806 300 38>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -790,6 +791,7 @@
 			basic_setting = <3840 2160 4400 2250 557 90>;
 			lcd_timing = <0xffffffff 0xffffffff 0xffffffff 47 80 47 80 47 47 3 9>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			vbyone_att = <8 4 2 4>;
 			panel_power_pin ="GPIOH_9";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
diff --git a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
index 139e3d78be4d..9eeb9dc92c7a 100644
--- a/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
+++ b/arch/arm/boot/dts/amlogic/mesong9tv_n301.dtd
@@ -1040,10 +1040,10 @@
 		/* AOC: public Platform lvds : 1920x1080@60hz 8bit pixel clk@74.25mhz 2prot*/
 		lvds_0{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<148000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1920 1080 2200 1125 148 41>; /**h_active v_active h_period v_period h_blank v_blank*/
 			lcd_timing = <0x500404ad 0x00414400 0x71486900 44 2156 0 1079 2100 2164 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 1 1 0x3>;	/** lvds_bits lvds_repack pn_swap dual_port port_reverse lvds_fifo_wr_mode*/
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -1053,10 +1053,10 @@
 		/*AUO: T320XVN02.9 lvds : 1366x768@60hz 8bit pixel clk@80mhz 1port*/
 		lvds_2{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<80000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1648 810 280 42>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -1066,10 +1066,10 @@
 		/*BOE: HV320WHB-N80 lvds : 1366x768@60hz 8bit pixel clk@74.25mhz 1port*/
 		lvds_3{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<74250000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1560 806 190 30>;
 			lcd_timing = <0x500404ad 0x00454400 0x71486900 20 30 0 809 20 1200 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -1079,10 +1079,10 @@
 		/*PANDA: TPT315B5-0TU3A.Q lvds : 1366x768@60hz 8bit pixel clk@82mhz 1port*/
 		lvds_4{
 			interface="lvds";		/** lcd_interface(lvds, vbyone, ttl) */
-			pixel_clock=<82000000>; /** pixel clock_hz(unit in Hz)*/
 			basic_setting = <1366 768 1696 806 300 38>;
 			lcd_timing = <0x5000068c 0x00454400 0x71c86900 20 30 0 809 20 1200 3 5>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			lvds_att = <8 1 0 0 0 0x101>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>;		/** on off on_delay off_delay*/
@@ -1095,6 +1095,7 @@
 			basic_setting = <3840 2160 4400 2250 557 90>;
 			lcd_timing = <0xffffffff 0xffffffff 0xffffffff 47 80 47 80 47 47 3 9>;
 			frame_rate_adjust_type=<0>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			vbyone_att = <8 4 2 4>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>; /** on off on_delay off_delay*/
@@ -1105,6 +1106,7 @@
 			basic_setting = <3840 2160 4400 2250 557 90>;
 			lcd_timing = <0xffffffff 0xffffffff 0xffffffff 47 80 47 80 47 47 3 9>;
 			frame_rate_adjust_type=<2>; /** 0=clock adjust, 1=htotal adjust, 2=vtotal adjust */
+			clk_att = <1 0>; /** clk_auto_generate clk_ss_level */
 			vbyone_att = <8 4 2 4>;
 			panel_power_pin ="GPIOH_10";
 			panel_power_att = <1 0 50 50>; /** on off on_delay off_delay*/
diff --git a/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c b/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c
index 492bf6452c3f..9c395cac4564 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c
+++ b/drivers/amlogic/display/lcd/aml_lcd_extern/lcd_extern.c
@@ -80,6 +80,16 @@ static int aml_lcd_extern_get_dt_config(struct device_node *of_node, struct lcd_
 		return -1;
 	}
 
+	err = of_property_read_string(of_node, "status", &str);
+	if (err) {
+		LCD_EXT_PR("get index %d status failed\n", econfig->index);
+		return -1;
+	} else {
+		DBG_PRINT("index %d status = %s\n", econfig->index, str);
+		if (strncmp(str, "dis", 3) == 0) //disabled
+			return -1;
+	}
+
 	err = of_property_read_string(of_node, "extern_name", &str);
 	if (err) {
 		str = "none";
@@ -432,7 +442,7 @@ static int aml_lcd_extern_probe(struct platform_device *pdev)
 	creat_lcd_extern_class();
 
 	LCD_EXT_PR("%s ok\n", __func__);
-	return ret;
+	return 0;
 }
 
 static int aml_lcd_extern_remove(struct platform_device *pdev)
diff --git a/drivers/amlogic/display/lcd/aml_lcd_tv.c b/drivers/amlogic/display/lcd/aml_lcd_tv.c
index 06ec4cb2758d..c57e4aa5ab24 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_tv.c
+++ b/drivers/amlogic/display/lcd/aml_lcd_tv.c
@@ -50,8 +50,6 @@ struct aml_lcd *pDev = NULL;
 static struct class *tv_lcd_class;
 #define LCD_ARG_NUM 4
 
-static unsigned short h_period_store, v_period_store;
-
 static const char* lcd_type_table[]={
 	"LVDS",
 	"vbyone",
@@ -276,15 +274,23 @@ static void tv_lcd_timing_info_print(void)
 	h_period = pDev->pConf->lcd_basic.h_period;
 	v_period = pDev->pConf->lcd_basic.v_period;
 
-	sync_start = pDev->pConf->lcd_timing.sth1_hs_addr;
-	sync_end = pDev->pConf->lcd_timing.sth1_he_addr;
-	hs_width = sync_end - sync_start;
-	hs_bp = video_on_pixel - sync_end;
+	if (pDev->pConf->version) {
+		hs_width = pDev->pConf->lcd_timing.hsync_width;
+		hs_bp = pDev->pConf->lcd_timing.hsync_bp;
 
-	sync_start = pDev->pConf->lcd_timing.stv1_vs_addr;
-	sync_end = pDev->pConf->lcd_timing.stv1_ve_addr;
-	vs_width = sync_end - sync_start;
-	vs_bp = video_on_line - sync_end;
+		vs_width = pDev->pConf->lcd_timing.vsync_width;
+		vs_bp = pDev->pConf->lcd_timing.vsync_bp;
+	} else {
+		sync_start = pDev->pConf->lcd_timing.sth1_hs_addr;
+		sync_end = pDev->pConf->lcd_timing.sth1_he_addr;
+		hs_width = sync_end - sync_start;
+		hs_bp = (video_on_pixel + h_period - sync_end) % h_period;
+
+		sync_start = pDev->pConf->lcd_timing.stv1_vs_addr;
+		sync_end = pDev->pConf->lcd_timing.stv1_ve_addr;
+		vs_width = sync_end - sync_start;
+		vs_bp = (video_on_line + v_period - sync_end) % v_period;
+	}
 
 	printk("h_period          %d\n"
 	   "v_period          %d\n"
@@ -303,6 +309,7 @@ static void tv_lcd_info_parameters(void)
 	unsigned int lcd_clk;
 	unsigned int sync_duration;
 
+	printk("lcd: driver version: %s.%d\n", LCD_TV_DRIVER_VERSION, pDev->pConf->version);
 	printk("lcd: parameters info:\n");
 
 	lcd_clk = (pDev->pConf->lcd_timing.lcd_clk / 1000);
@@ -326,19 +333,17 @@ static void tv_lcd_info_parameters(void)
 		   "lvds_repack       %u\n"
 		   "pn_swap           %u\n"
 		   "dual_port         %u\n"
-		   "port_reverse      %u\n"
-		   "lvds_fifo_wr_mode %u\n\n",
+		   "port_swap      %u\n\n",
 		   pDev->pConf->lcd_control.lvds_config->lvds_bits,
 		   pDev->pConf->lcd_control.lvds_config->lvds_repack,
 		   pDev->pConf->lcd_control.lvds_config->pn_swap,
 		   pDev->pConf->lcd_control.lvds_config->dual_port,
-		   pDev->pConf->lcd_control.lvds_config->port_reverse,
-		   pDev->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
+		   pDev->pConf->lcd_control.lvds_config->port_swap);
 		break;
 	case LCD_DIGITAL_VBYONE:
 		printk("lane_count        %u\n"
 		   "byte_mode         %u\n"
-		   "region            %u\n\n",
+		   "region_num        %u\n\n",
 		   pDev->pConf->lcd_control.vbyone_config->lane_count,
 		   pDev->pConf->lcd_control.vbyone_config->byte_mode,
 		   pDev->pConf->lcd_control.vbyone_config->region);
@@ -530,19 +535,19 @@ static ssize_t tv_lcd_debug_store(struct class *cls,
 		printk("change lcd frame rate change type: %d\n", value);
 		break;
 	case 'i':
-		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		printk("lcd: driver version: %s.%d\n", LCD_TV_DRIVER_VERSION, pDev->pConf->version);
 		tv_lcd_info_parameters();
 		break;
 	case 'r':
-		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		printk("lcd: driver version: %s.%d\n", LCD_TV_DRIVER_VERSION, pDev->pConf->version);
 		tv_lcd_reg_dump();
 		break;
 	case 's':
-		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		printk("lcd: driver version: %s.%d\n", LCD_TV_DRIVER_VERSION, pDev->pConf->version);
 		tv_lcd_status_dump();
 		break;
 	case 'd':
-		printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+		printk("lcd: driver version: %s.%d\n", LCD_TV_DRIVER_VERSION, pDev->pConf->version);
 		tv_lcd_info_parameters();
 		tv_lcd_reg_dump();
 		tv_lcd_status_dump();
@@ -606,6 +611,11 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	struct lcd_extern_config_s *ext_conf;
 #endif
 
+	if (of_node == NULL) {
+		TV_LCD_ERR("no lcd node in dts\n");
+		return NULL;
+	}
+
 	pd = kmalloc(sizeof(struct aml_lcd_platdata), GFP_KERNEL);
 	if (pd == NULL) {
 		TV_LCD_ERR("failed to get pd Not enough memory\n");
@@ -649,196 +659,224 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	}
 	memset(lcd_para, 0, sizeof(*lcd_para));
 
-	if (of_node) {
-		pd->pConf->lcd_basic.model_name = lcd_propname;
-		child = of_get_child_by_name(of_node, lcd_propname);
-		if (child == NULL) {
-			kfree(lcd_para);
-			kfree(pd);
-			kfree(plcd_config);
-			kfree(ppanel_power_config);
-			TV_LCD_ERR("faild to get lcd_model_config!! \n");
-			return NULL;
-		}
+	/* read lcd parameters */
+	if (of_property_read_u32(of_node, "version", &val)) {
+		//TV_LCD_INFO("failed to get version, default to 0\n");
+		plcd_config->version = 0;
+	} else {
+		plcd_config->version = (unsigned char)val;
+	}
 
-		if (aml_lcd_get_property_string(child, "interface", &str)) {
-			kfree(lcd_para);
-			kfree(pd);
-			kfree(plcd_config);
-			kfree(ppanel_power_config);
-			return NULL;
-		} else {
-			for (val = 0; val < LCD_TYPE_MAX; val++) {
-			if (!strcasecmp(str, lcd_type_table[val]))
-				break;
-			}
-			plcd_config->lcd_basic.lcd_type = val;
-		}
+	pd->pConf->lcd_basic.model_name = lcd_propname;
+	child = of_get_child_by_name(of_node, lcd_propname);
+	if (child == NULL) {
+		kfree(lcd_para);
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		TV_LCD_ERR("failed to get lcd_model_config!! \n");
+		return NULL;
+	}
 
-		if (of_property_read_u32(child, "frame_rate_adjust_type", &val)) {
-			TV_LCD_INFO("failed to get frame_rate_adjust_type, default to 0\n");
-			/* default use clock adjust */
-			plcd_config->lcd_timing.frame_rate_adj_type = 0;
-		} else {
-			plcd_config->lcd_timing.frame_rate_adj_type = (unsigned char)val;
+	if (aml_lcd_get_property_string(child, "interface", &str)) {
+		kfree(lcd_para);
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		return NULL;
+	} else {
+		for (val = 0; val < LCD_TYPE_MAX; val++) {
+		if (!strcasecmp(str, lcd_type_table[val]))
+			break;
 		}
+		plcd_config->lcd_basic.lcd_type = val;
+	}
 
-		if (aml_lcd_get_property_array(child, "basic_setting", &lcd_para[0], 6)) {
-			kfree(lcd_para);
-			kfree(pd);
-			kfree(plcd_config);
-			kfree(ppanel_power_config);
-			return NULL;
-		} else {
-			plcd_config->lcd_basic.h_active = lcd_para[0];
-			plcd_config->lcd_basic.v_active = lcd_para[1];
-			plcd_config->lcd_basic.h_period = lcd_para[2];
-			plcd_config->lcd_basic.v_period = lcd_para[3];
-			plcd_config->lcd_basic.video_on_pixel = lcd_para[4];
-			plcd_config->lcd_basic.video_on_line = lcd_para[5];
-		}
+	if (aml_lcd_get_property_array(child, "basic_setting", &lcd_para[0], 6)) {
+		kfree(lcd_para);
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		return NULL;
+	} else {
+		plcd_config->lcd_basic.h_active = lcd_para[0];
+		plcd_config->lcd_basic.v_active = lcd_para[1];
+		plcd_config->lcd_basic.h_period = lcd_para[2];
+		plcd_config->lcd_basic.v_period = lcd_para[3];
+		/* version 0 */
+		plcd_config->lcd_basic.video_on_pixel = lcd_para[4];
+		plcd_config->lcd_basic.video_on_line = lcd_para[5];
+	}
+
+	if (aml_lcd_get_property_array(child, "lcd_timing", &lcd_para[0], 11)) {
+		kfree(lcd_para);
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		return NULL;
+	} else {
+		plcd_config->lcd_timing.hpll_clk = lcd_para[0];
+		plcd_config->lcd_timing.hpll_od  = lcd_para[1];
+		plcd_config->lcd_timing.hdmi_pll_cntl5 = lcd_para[2];
+		/* version 1 */
+		plcd_config->lcd_timing.hsync_width	 = lcd_para[3];
+		plcd_config->lcd_timing.hsync_bp	 = lcd_para[4];
+		plcd_config->lcd_timing.vsync_width	 = lcd_para[5];
+		plcd_config->lcd_timing.vsync_bp	 = lcd_para[6];
+		/* version 0 */
+		plcd_config->lcd_timing.sth1_hs_addr	 = lcd_para[3];
+		plcd_config->lcd_timing.sth1_he_addr	 = lcd_para[4];
+		plcd_config->lcd_timing.sth1_vs_addr	 = lcd_para[5];
+		plcd_config->lcd_timing.sth1_ve_addr	 = lcd_para[6];
+		plcd_config->lcd_timing.stv1_hs_addr	 = lcd_para[7];
+		plcd_config->lcd_timing.stv1_he_addr	 = lcd_para[8];
+		plcd_config->lcd_timing.stv1_vs_addr	 = lcd_para[9];
+		plcd_config->lcd_timing.stv1_ve_addr	 = lcd_para[10];
+	}
+
+	if (of_property_read_u32(child, "frame_rate_adjust_type", &val)) {
+		TV_LCD_INFO("failed to get frame_rate_adjust_type, default to 0\n");
+		/* default use clock adjust */
+		plcd_config->lcd_timing.frame_rate_adj_type = 0;
+	} else {
+		plcd_config->lcd_timing.frame_rate_adj_type = (unsigned char)val;
+	}
+
+	if (aml_lcd_get_property_array(child, "clk_att", &lcd_para[0], 2)) {
+		TV_LCD_INFO("failed to get clk_att, set default value\n");
+		plcd_config->lcd_timing.clk_auto = 1;
+		plcd_config->lcd_timing.ss_level = 0;
+	} else {
+		plcd_config->lcd_timing.clk_auto = (unsigned char)lcd_para[0];
+		plcd_config->lcd_timing.ss_level = (unsigned char)lcd_para[1];
+	}
 
-		if (aml_lcd_get_property_array(child, "lcd_timing", &lcd_para[0], 11)) {
+	if (aml_lcd_get_property_string(child, "panel_power_pin", &str)) {
+		kfree(lcd_para);
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		return NULL;
+	} else {
+		panel_power_pin = amlogic_gpio_name_map_num(str);
+		if (panel_power_pin<0) {
 			kfree(lcd_para);
-			kfree(pd);
-			kfree(plcd_config);
-			kfree(ppanel_power_config);
+			TV_LCD_ERR("wrong gpio number %s\n",str);
 			return NULL;
-		} else {
-			plcd_config->lcd_timing.hpll_clk = lcd_para[0];
-			plcd_config->lcd_timing.hpll_od  = lcd_para[1];
-			plcd_config->lcd_timing.hdmi_pll_cntl5 = lcd_para[2];
-			plcd_config->lcd_timing.sth1_hs_addr	 = lcd_para[3];
-			plcd_config->lcd_timing.sth1_he_addr	 = lcd_para[4];
-			plcd_config->lcd_timing.sth1_vs_addr	 = lcd_para[5];
-			plcd_config->lcd_timing.sth1_ve_addr	 = lcd_para[6];
-			plcd_config->lcd_timing.stv1_hs_addr	 = lcd_para[7];
-			plcd_config->lcd_timing.stv1_he_addr	 = lcd_para[8];
-			plcd_config->lcd_timing.stv1_vs_addr	 = lcd_para[9];
-			plcd_config->lcd_timing.stv1_ve_addr	 = lcd_para[10];
 		}
+		ppanel_power_config->gpio	= panel_power_pin;
+	}
+
+	if (aml_lcd_get_property_array(child, "panel_power_att", &lcd_para[0], 4)) {
+		kfree(lcd_para);
+		kfree(pd);
+		kfree(plcd_config);
+		kfree(ppanel_power_config);
+		return NULL;
+	} else {
+		ppanel_power_config->on_value  = lcd_para[0];
+		ppanel_power_config->off_value = lcd_para[1];
+		ppanel_power_config->panel_on_delay = lcd_para[2];
+		ppanel_power_config->panel_off_delay = lcd_para[3];
+	}
 
-		if (aml_lcd_get_property_string(child, "panel_power_pin", &str)) {
+	if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+		if (aml_lcd_get_property_array(child, "lvds_att", &lcd_para[0], 6)) {
 			kfree(lcd_para);
 			kfree(pd);
 			kfree(plcd_config);
 			kfree(ppanel_power_config);
 			return NULL;
-		} else {
-			panel_power_pin = amlogic_gpio_name_map_num(str);
-			if (panel_power_pin<0) {
+		}else {
+			Lvds_Config_t *plvds_config;
+			plvds_config = kmalloc(sizeof(Lvds_Config_t), GFP_KERNEL);
+			if (plvds_config == NULL) {
+				TV_LCD_ERR("plvds_config Not enough memory\n");
 				kfree(lcd_para);
-				TV_LCD_ERR("wrong gpio number %s\n",str);
+				kfree(pd);
+				kfree(plcd_config);
+				kfree(ppanel_power_config);
 				return NULL;
 			}
-			ppanel_power_config->gpio	= panel_power_pin;
+			memset(plvds_config, 0, sizeof(*plvds_config));
+			pd->pConf->lcd_control.lvds_config = plvds_config;
+
+			plvds_config->lvds_bits	 = lcd_para[0];
+			plvds_config->lvds_repack  = lcd_para[1];
+			plvds_config->pn_swap 	 = lcd_para[2];
+			plvds_config->dual_port	 = lcd_para[3];
+			if (plcd_config->version)
+				plvds_config->port_swap = (lcd_para[4] ? 1 : 0);
+			else
+				plvds_config->port_swap = (lcd_para[4] ? 0 : 1);
+			//plvds_config->port_reverse	 = lcd_para[4];
+			//plvds_config->lvds_fifo_wr_mode	 = lcd_para[5];
 		}
 
-		if (aml_lcd_get_property_array(child, "panel_power_att", &lcd_para[0], 4)) {
+	} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
+		if (aml_lcd_get_property_array(child, "vbyone_att", &lcd_para[0], 4)) {
 			kfree(lcd_para);
 			kfree(pd);
 			kfree(plcd_config);
 			kfree(ppanel_power_config);
 			return NULL;
 		} else {
-			ppanel_power_config->on_value  = lcd_para[0];
-			ppanel_power_config->off_value = lcd_para[1];
-			ppanel_power_config->panel_on_delay = lcd_para[2];
-			ppanel_power_config->panel_off_delay = lcd_para[3];
-		}
-
-		if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
-/*			if (aml_lcd_get_property_array(child, "pixel_clock", &lcd_para[0], 1)) {
-				kfree(lcd_para);
-				kfree(pd);
-				kfree(plcd_config);
-				kfree(ppanel_power_config);
-				return NULL;
-			} else {
-				plcd_config->lcd_timing.lcd_clk = lcd_para[0];
-			}
-*/
-			if (aml_lcd_get_property_array(child, "lvds_att", &lcd_para[0], 6)) {
-				kfree(lcd_para);
-				kfree(pd);
-				kfree(plcd_config);
-				kfree(ppanel_power_config);
-				return NULL;
-			}else {
-				Lvds_Config_t *plvds_config;
-				plvds_config = kmalloc(sizeof(Lvds_Config_t), GFP_KERNEL);
-				if (plvds_config == NULL) {
-					TV_LCD_ERR("pvbyone_config plvds_config Not enough memory\n");
-					kfree(lcd_para);
-					kfree(pd);
-					kfree(plcd_config);
-					kfree(ppanel_power_config);
-					return NULL;
-				}
-				memset(plvds_config, 0, sizeof(*plvds_config));
-				pd->pConf->lcd_control.lvds_config = plvds_config;
-
-				plvds_config->lvds_bits	 = lcd_para[0];
-				plvds_config->lvds_repack  = lcd_para[1];
-				plvds_config->pn_swap 	 = lcd_para[2];
-				plvds_config->dual_port	 = lcd_para[3];
-				plvds_config->port_reverse		 = lcd_para[4];
-				plvds_config->lvds_fifo_wr_mode	 = lcd_para[5];
-			}
-
-		} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
-			if (aml_lcd_get_property_array(child, "vbyone_att", &lcd_para[0], 4)) {
+			Vbyone_Config_t *pvbyone_config;
+			pvbyone_config = kmalloc(sizeof(Vbyone_Config_t), GFP_KERNEL);
+			if (pvbyone_config == NULL) {
 				kfree(lcd_para);
 				kfree(pd);
 				kfree(plcd_config);
 				kfree(ppanel_power_config);
+				TV_LCD_ERR("pvbyone_config Not enough memory\n");
 				return NULL;
-			} else {
-				Vbyone_Config_t *pvbyone_config;
-				pvbyone_config = kmalloc(sizeof(Vbyone_Config_t), GFP_KERNEL);
-				if (pvbyone_config == NULL) {
-					kfree(lcd_para);
-					kfree(pd);
-					kfree(plcd_config);
-					kfree(ppanel_power_config);
-					TV_LCD_ERR("failed to get pvbyone_config Not enough memory\n");
-					return NULL;
-				}
-				memset(pvbyone_config, 0, sizeof(*pvbyone_config));
-				pd->pConf->lcd_control.vbyone_config= pvbyone_config;
-
-				pvbyone_config->lane_count	= lcd_para[0];
-				pvbyone_config->byte_mode	= lcd_para[1];
-				pvbyone_config->region		= lcd_para[2];
-				pvbyone_config->color_fmt 	= lcd_para[3];
 			}
-		} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+			memset(pvbyone_config, 0, sizeof(*pvbyone_config));
+			pd->pConf->lcd_control.vbyone_config= pvbyone_config;
 
+			pvbyone_config->lane_count	= lcd_para[0];
+			pvbyone_config->byte_mode	= lcd_para[1];
+			pvbyone_config->region		= lcd_para[2];
+			pvbyone_config->color_fmt 	= lcd_para[3];
 		}
+	} else if (plcd_config->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+
+	}
 
 #ifdef CONFIG_AML_LCD_EXTERN
-		if (aml_lcd_get_property_array(child, "lcd_extern_att", &lcd_para[0], 3)) {
-			ext_conf->index = LCD_EXTERN_INDEX_INVALID;
-			ext_conf->on_delay = 0;
-			ext_conf->off_delay = 0;
-		} else {
-			ext_conf->index = lcd_para[0];
-			ext_conf->on_delay = lcd_para[1];
-			ext_conf->off_delay = lcd_para[2];
-		}
-#endif
+	if (aml_lcd_get_property_array(child, "lcd_extern_att", &lcd_para[0], 3)) {
+		ext_conf->index = LCD_EXTERN_INDEX_INVALID;
+		ext_conf->on_delay = 0;
+		ext_conf->off_delay = 0;
+	} else {
+		ext_conf->index = lcd_para[0];
+		ext_conf->on_delay = lcd_para[1];
+		ext_conf->off_delay = lcd_para[2];
 	}
+#endif
 
 	TV_LCD_INFO("lcd_type = %s(%s)\n", lcd_type_table[pd->pConf->lcd_basic.lcd_type],lcd_propname);
 	TV_LCD_INFO("h_active = %u, v_active = %u \n", pd->pConf->lcd_basic.h_active, pd->pConf->lcd_basic.v_active);
 	TV_LCD_INFO("h_period = %u, v_period = %u \n", pd->pConf->lcd_basic.h_period, pd->pConf->lcd_basic.v_period );
-	TV_LCD_INFO("video_on_pixel = %u, video_on_line = %u \n", pd->pConf->lcd_basic.video_on_pixel, pd->pConf->lcd_basic.video_on_line);
-	TV_LCD_INFO("hpll_clk = %x, hpll_od =%x hdmi_pll_cntl5 = %x \n", pd->pConf->lcd_timing.hpll_clk, pd->pConf->lcd_timing.hpll_od, pd->pConf->lcd_timing.hdmi_pll_cntl5);
-	TV_LCD_INFO("sth1_hs_addr = %u, sth1_he_addr = %u \n", pd->pConf->lcd_timing.sth1_hs_addr, pd->pConf->lcd_timing.sth1_he_addr);
-	TV_LCD_INFO("sth1_vs_addr = %u, sth1_ve_addr = %u \n", pd->pConf->lcd_timing.sth1_vs_addr, pd->pConf->lcd_timing.sth1_ve_addr);
-	TV_LCD_INFO("stv1_hs_addr = %u, stv1_he_addr = %u \n", pd->pConf->lcd_timing.stv1_hs_addr, pd->pConf->lcd_timing.stv1_he_addr);
-	TV_LCD_INFO("stv1_vs_addr = %u, stv1_ve_addr = %u \n", pd->pConf->lcd_timing.stv1_vs_addr, pd->pConf->lcd_timing.stv1_ve_addr);
+	if (pd->pConf->lcd_timing.clk_auto == 0) {
+		TV_LCD_INFO("hpll_clk = %x, hpll_od =%x hdmi_pll_cntl5 = %x \n",
+			pd->pConf->lcd_timing.hpll_clk,
+			pd->pConf->lcd_timing.hpll_od,
+			pd->pConf->lcd_timing.hdmi_pll_cntl5);
+	}
 	TV_LCD_INFO("frame_rate_adjust_type = %u\n", pd->pConf->lcd_timing.frame_rate_adj_type);
+	TV_LCD_INFO("clk_auto = %u\n", pd->pConf->lcd_timing.clk_auto);
+	//TV_LCD_INFO("ss_level = %u\n", pd->pConf->lcd_timing.ss_level);
+	if (pd->pConf->version) {
+		TV_LCD_INFO("hsync_width = %u, hsync_bp = %u \n", pd->pConf->lcd_timing.hsync_width, pd->pConf->lcd_timing.hsync_bp);
+		TV_LCD_INFO("vsync_width = %u, vsync_bp = %u \n", pd->pConf->lcd_timing.vsync_width, pd->pConf->lcd_timing.vsync_bp);
+	} else {
+		TV_LCD_INFO("video_on_pixel = %u, video_on_line = %u \n", pd->pConf->lcd_basic.video_on_pixel, pd->pConf->lcd_basic.video_on_line);
+		TV_LCD_INFO("sth1_hs_addr = %u, sth1_he_addr = %u \n", pd->pConf->lcd_timing.sth1_hs_addr, pd->pConf->lcd_timing.sth1_he_addr);
+		TV_LCD_INFO("sth1_vs_addr = %u, sth1_ve_addr = %u \n", pd->pConf->lcd_timing.sth1_vs_addr, pd->pConf->lcd_timing.sth1_ve_addr);
+		TV_LCD_INFO("stv1_hs_addr = %u, stv1_he_addr = %u \n", pd->pConf->lcd_timing.stv1_hs_addr, pd->pConf->lcd_timing.stv1_he_addr);
+		TV_LCD_INFO("stv1_vs_addr = %u, stv1_ve_addr = %u \n", pd->pConf->lcd_timing.stv1_vs_addr, pd->pConf->lcd_timing.stv1_ve_addr);
+	}
 
 	TV_LCD_INFO("panel_power_pin: %s--%d \n",str,pd->pConf->lcd_power_ctrl.panel_power->gpio);
 	TV_LCD_INFO("on_value = %d \n",pd->pConf->lcd_power_ctrl.panel_power->on_value);
@@ -851,16 +889,16 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 		TV_LCD_INFO("lvds_repack = %d \n",pd->pConf->lcd_control.lvds_config->lvds_repack);
 		TV_LCD_INFO("pn_swap = %d \n",pd->pConf->lcd_control.lvds_config->pn_swap);
 		TV_LCD_INFO("dual_port = %d \n",pd->pConf->lcd_control.lvds_config->dual_port);
-		TV_LCD_INFO("port_reverse = %d \n",pd->pConf->lcd_control.lvds_config->port_reverse);
-		TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pd->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
-		//TV_LCD_INFO("pixel_clock = %d \n", pd->pConf->lcd_timing.lcd_clk);
+		TV_LCD_INFO("port_swap = %d \n",pd->pConf->lcd_control.lvds_config->port_swap);
+		//TV_LCD_INFO("port_reverse = %d \n",pd->pConf->lcd_control.lvds_config->port_reverse);
+		//TV_LCD_INFO("lvds_fifo_wr_mode = %d \n",pd->pConf->lcd_control.lvds_config->lvds_fifo_wr_mode);
 	} else if (pd->pConf->lcd_basic.lcd_type == LCD_DIGITAL_VBYONE) {
 		TV_LCD_INFO("lane_count = %d \n",pd->pConf->lcd_control.vbyone_config->lane_count);
 		TV_LCD_INFO("byte_mode = %d \n",pd->pConf->lcd_control.vbyone_config->byte_mode);
-		TV_LCD_INFO("region = %d \n",pd->pConf->lcd_control.vbyone_config->region);
+		TV_LCD_INFO("region_num = %d \n",pd->pConf->lcd_control.vbyone_config->region);
 		TV_LCD_INFO("color_fmt = %d \n",pd->pConf->lcd_control.vbyone_config->color_fmt);
 	} else if (pd->pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
-
+		TV_LCD_INFO("this is ttl att \n");
 	}
 #ifdef CONFIG_AML_LCD_EXTERN
 	if (pd->pConf->lcd_control.ext_config->index < LCD_EXTERN_INDEX_INVALID) {
@@ -875,13 +913,62 @@ static struct aml_lcd_platdata * _get_lcd_config(struct platform_device *pdev)
 	return pd;
 }
 
+static void lcd_tcon_config(Lcd_Config_t *pConf)
+{
+	unsigned short h_period, v_period, h_active, v_active;
+	unsigned short hsync_bp, hsync_width, vsync_bp, vsync_width;
+	unsigned short de_hstart, de_vstart;
+	unsigned short hstart, hend, vstart, vend;
+
+	h_period = pConf->lcd_basic.h_period;
+	v_period = pConf->lcd_basic.v_period;
+	h_active = pConf->lcd_basic.h_active;
+	v_active = pConf->lcd_basic.v_active;
+	hsync_bp = pConf->lcd_timing.hsync_bp;
+	hsync_width = pConf->lcd_timing.hsync_width;
+	vsync_bp = pConf->lcd_timing.vsync_bp;
+	vsync_width = pConf->lcd_timing.vsync_width;
+
+	de_hstart = h_period - h_active - 1;
+	de_vstart = v_period - v_active;
+
+	pConf->lcd_basic.video_on_pixel = de_hstart;
+	pConf->lcd_basic.video_on_line = de_vstart;
+
+	hstart = (de_hstart + h_period - hsync_bp - hsync_width) % h_period;
+	hend = (de_hstart + h_period - hsync_bp) % h_period;
+	pConf->lcd_timing.sth1_hs_addr = hstart;
+	pConf->lcd_timing.sth1_he_addr = hend;
+	pConf->lcd_timing.sth1_vs_addr = 0;
+	pConf->lcd_timing.sth1_ve_addr = v_period - 1;
+
+	pConf->lcd_timing.stv1_hs_addr = (hstart + h_period) % h_period;
+	pConf->lcd_timing.stv1_he_addr = pConf->lcd_timing.stv1_hs_addr;
+	vstart = (de_vstart + v_period - vsync_bp - vsync_width) % v_period;
+	vend = (de_vstart + v_period - vsync_bp) % v_period;
+	pConf->lcd_timing.stv1_vs_addr = vstart;
+	pConf->lcd_timing.stv1_ve_addr = vend;
+
+/*	printk("hs_hs_addr=%d, hs_he_addr=%d, hs_vs_addr=%d, hs_ve_addr=%d\n"
+		"vs_hs_addr=%d, vs_he_addr=%d, vs_vs_addr=%d, vs_ve_addr=%d\n",
+		pConf->lcd_timing.sth1_hs_addr, pConf->lcd_timing.sth1_he_addr,
+		pConf->lcd_timing.sth1_vs_addr, pConf->lcd_timing.sth1_ve_addr,
+		pConf->lcd_timing.stv1_hs_addr, pConf->lcd_timing.stv1_he_addr,
+		pConf->lcd_timing.stv1_vs_addr, pConf->lcd_timing.stv1_ve_addr);*/
+}
+
 static void init_lcd_config(struct aml_lcd *pDev)
 {
-	h_period_store = pDev->pConf->lcd_basic.h_period;
-	v_period_store = pDev->pConf->lcd_basic.v_period;
+	unsigned int h_period, v_period;
+
+	h_period = pDev->pConf->lcd_basic.h_period;
+	v_period = pDev->pConf->lcd_basic.v_period;
 
 	/* prepare 60hz clock */
-	pDev->pConf->lcd_timing.lcd_clk = h_period_store * v_period_store * 60;
+	pDev->pConf->lcd_timing.lcd_clk = h_period * v_period * 60;
+
+	if (pDev->pConf->version)
+		lcd_tcon_config(pDev->pConf);
 }
 #endif
 
@@ -957,24 +1044,16 @@ static int lcd_vmode_change(int index)
 	switch (type) {
 	case 1: /* htotal adjust */
 		pclk = pDev->pConf->lcd_timing.lcd_clk;
-		if ((sync_duration_den / sync_duration_num) < 55) { /* 50hz */
-			h_period = ((pclk / v_period) * sync_duration_den * 10) / sync_duration_num;
-			h_period = (h_period + 5) / 10; /* round off */
-		} else { /* 60hz */
-			h_period = h_period_store;
-		}
+		h_period = ((pclk / v_period) * sync_duration_den * 10) / sync_duration_num;
+		h_period = (h_period + 5) / 10; /* round off */
 		printk("lcd: %s: adjust h_period %u -> %u\n",
 			__func__, pDev->pConf->lcd_basic.h_period, h_period);
 		pDev->pConf->lcd_basic.h_period = h_period;
 		break;
 	case 2: /* vtotal adjust */
 		pclk = pDev->pConf->lcd_timing.lcd_clk;
-		if ((sync_duration_den / sync_duration_num) < 55) { /* 50hz */
-			v_period = ((pclk / h_period) * sync_duration_den * 10) / sync_duration_num;
-			v_period = (v_period + 5) / 10; /* round off */
-		} else { /* 60hz */
-			v_period = v_period_store;
-		}
+		v_period = ((pclk / h_period) * sync_duration_den * 10) / sync_duration_num;
+		v_period = (v_period + 5) / 10; /* round off */
 		printk("lcd: %s: adjust v_period %u -> %u\n",
 			__func__, pDev->pConf->lcd_basic.v_period, v_period);
 		pDev->pConf->lcd_basic.v_period = v_period;
@@ -995,7 +1074,7 @@ static int lcd_vmode_change(int index)
 
 static void _lcd_module_enable(void)
 {
-	printk("lcd: driver version: %s\n", LCD_TV_DRIVER_VERSION);
+	printk("lcd: driver version: %s.%d\n", LCD_TV_DRIVER_VERSION, pDev->pConf->version);
 	if (pDev == NULL) {
 		printk("lcd: [error]: no lcd device, exit\n");
 		return;
@@ -1061,7 +1140,7 @@ static int lcd_vmode_is_supported(vmode_t mode)
 
 	mode &= VMODE_MODE_BIT_MASK;
 	m = get_lcd_vmode(mode);
-	printk("initcall vmode = %d, lcd mode = %d(%s)\n", mode, m, lcd_info[m].name);
+	printk("lcd: initcall vmode = %d, lcd mode = %d(%s)\n", mode, m, lcd_info[m].name);
 
 	switch (mode) {
 	case VMODE_1080P:
diff --git a/drivers/amlogic/display/lcd/aml_lcd_tv.h b/drivers/amlogic/display/lcd/aml_lcd_tv.h
index bf4b2f51aca5..8538d7cc25d5 100644
--- a/drivers/amlogic/display/lcd/aml_lcd_tv.h
+++ b/drivers/amlogic/display/lcd/aml_lcd_tv.h
@@ -29,7 +29,7 @@
 #include <linux/amlogic/vout/aml_lcd_extern.h>
 #endif
 
-#define LCD_TV_DRIVER_VERSION        "20150916"
+#define LCD_TV_DRIVER_VERSION        "20151009"
 
 typedef enum {
     OFF = 0,
@@ -40,7 +40,6 @@ typedef enum {
 	LCD_DIGITAL_LVDS = 0,
 	LCD_DIGITAL_VBYONE,
 	LCD_DIGITAL_TTL,
-	//LCD_DIGITAL_MINILVDS,
 	LCD_TYPE_MAX,
 } Lcd_Type_t;
 
@@ -63,98 +62,58 @@ typedef struct {
 	//u16 lcd_bits;			// 6 or 8 bits
 	//u16 lcd_bits_option;	//option=0, means the panel only support one lcd_bits option
 }Lcd_Basic_t;
-/*
-
-typedef struct {
-	u32 pll_ctrl;		//video PLL settings
-	u32 div_ctrl;		// video pll div settings
-	u32 clk_ctrl;		// video clock settings //[31]clk_auto, [11:8]ss_ctrl, [7:0]xd
-	u32 lcd_clk;		// lcd clock
-	u16 sync_duration_num;
-	u16 sync_duration_den;
-
-	u16 pol_ctrl;
-	//u16 inv_cnt_addr;
-	//u16 tcon_misc_sel_addr;
-
-	u16 video_on_pixel;
-	u16 video_on_line;
-
-	u16 hsync_width;
-	u16 hsync_bp;
-	u16 vsync_width;
-	u16 vsync_bp;
-	u32 vsync_h_phase; //[31]sign [15:0]value
-	u16 hvsync_valid;
-	//u16 de_hstart;
-	//u16 de_vstart;
-	u16 de_valid;
-	u32 h_offset;
-	u32 v_offset;
-
-	u16 de_hs_addr;
-	u16 de_he_addr;
-	u16 de_vs_addr;
-	u16 de_ve_addr;
-
-	u16 hs_hs_addr;
-	u16 hs_he_addr;
-	u16 hs_vs_addr;
-	u16 hs_ve_addr;
-
-	u16 vs_hs_addr;
-	u16 vs_he_addr;
-	u16 vs_vs_addr;
-	u16 vs_ve_addr;
-
-	u16 vso_hstart;
-	u16 vso_vstart;
-	u16 vso_user;
-
-} Lcd_Timing_t;
-*/
 
 typedef struct {
 	u32 hpll_clk;
 	u32 hpll_od;
 	u32 hdmi_pll_cntl5;
 
+	unsigned char clk_auto; /* clk parameters auto generation flag */
 	u32 lcd_clk;		/* lcd clock = pixel clock*/
 	u32 pll_ctrl;		/* video PLL settings */
 	u32 div_ctrl;		/* video pll div settings */
 	u32 clk_ctrl;		/* video clock settings */  //[31]clk_auto, [11:8]ss_ctrl, [7:0]xd
 	unsigned char frame_rate_adj_type; /* 0=htotal adjust, 1=clock adjust */
+	unsigned char ss_level;
 
-    u16 sync_duration_num;
-    u16 sync_duration_den;
+	u16 sync_duration_num;
+	u16 sync_duration_den;
+
+	u16 hsync_width;
+	u16 hsync_bp;
+	u16 vsync_width;
+	u16 vsync_bp;
 
-    u16 sth1_hs_addr;
-    u16 sth1_he_addr;
-    u16 sth1_vs_addr;
-    u16 sth1_ve_addr;
+	u16 sth1_hs_addr;
+	u16 sth1_he_addr;
+	u16 sth1_vs_addr;
+	u16 sth1_ve_addr;
 
-    u16 stv1_hs_addr;
-    u16 stv1_he_addr;
-    u16 stv1_vs_addr;
-    u16 stv1_ve_addr;
+	u16 stv1_hs_addr;
+	u16 stv1_he_addr;
+	u16 stv1_vs_addr;
+	u16 stv1_ve_addr;
 } Lcd_Timing_t;
 
 typedef struct {
 	int lvds_bits;				// 6 / 8 /10  bits
-    int lvds_repack;
-    int pn_swap;
-    int dual_port;
-    int port_reverse;
-    int lvds_fifo_wr_mode;
+	int lvds_repack;
+	int pn_swap;
+	int dual_port;
+	unsigned int port_swap;
+	unsigned int port_sel;
+	/* for old version */
+	int port_reverse;
+	int lvds_fifo_wr_mode;
 } Lvds_Config_t;
 
 typedef struct {
 	int lane_count;
-    int byte_mode;
-    int region;
-    int color_fmt;
-    int phy_div;
-    unsigned int bit_rate;
+	int byte_mode;
+	int region;
+	int color_fmt;
+	int phy_div;
+	unsigned int bit_rate;
 } Vbyone_Config_t;
 
 #ifdef CONFIG_AML_LCD_EXTERN
@@ -187,7 +146,8 @@ typedef struct {
 } Lcd_Power_Ctrl_t;
 
 typedef struct {
-    Lcd_Basic_t lcd_basic;
+	unsigned char version; /* for driver version compatibility */
+	Lcd_Basic_t lcd_basic;
 	Lcd_Timing_t lcd_timing;
 	Lcd_Control_Config_t lcd_control;
 	Lcd_Power_Ctrl_t lcd_power_ctrl;
@@ -199,7 +159,7 @@ struct aml_lcd {
 	vinfo_t lcd_info;
 	struct aml_lcd_platdata *pd;
 
-	struct device		*dev;
+	struct device  *dev;
 	struct mutex init_lock;
 	struct timer_list timer;
 };
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
index 43a33dfae298..cbdcbee52c02 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.c
@@ -279,6 +279,29 @@ static unsigned int clk_div_calc(unsigned int clk,unsigned int div_sel, int dir)
 	return clk_ret;
 }
 
+static unsigned int clk_div_get(unsigned int divN)
+{ /* div * 100 */
+	unsigned int div_sel;
+
+	switch (divN) {
+	case 375:
+		div_sel = CLK_DIV_SEL_3p75;
+		break;
+	case 750:
+		div_sel = CLK_DIV_SEL_7p5;
+		break;
+	case 1500:
+		div_sel = CLK_DIV_SEL_15;
+		break;
+	case 500:
+		div_sel = CLK_DIV_SEL_5;
+		break;
+	default:
+		div_sel = CLK_DIV_SEL_MAX;
+		break;
+	}
+	return div_sel;
+}
 
 void generate_clk_parameter(Lcd_Config_t *pconf)
 {
@@ -328,6 +351,15 @@ void generate_clk_parameter(Lcd_Config_t *pconf)
 		fout_pll = pconf->lcd_control.vbyone_config->bit_rate / 1000;
 		if (fout_pll > CLK_DIV_MAX_CLK_IN)
 			goto generate_clk_done;
+
+		tmp = fout_pll * 100 / fout;
+		clk_div_sel = clk_div_get(tmp);
+		crt_xd_max = CRT_VID_DIV_MAX; //255
+		crt_xd = 1;
+		clk_div_out = fout * crt_xd;
+		if (clk_div_out > CRT_VID_MAX_CLK_IN)
+			goto generate_clk_done;
+
 		ret = check_pll(&pll, fout_pll);
 		if (ret)
 			goto generate_clk_done;
@@ -351,8 +383,8 @@ generate_clk_done:
 			((crt_xd << CLK_CTRL_XD) |
 			(pll.frac << CLK_CTRL_FRAC)));
 
-		printk("lcd: pll_ctrl=0x%x div_ctrl=0x%x clk_ctrl=0x%x \n",
-			pconf->lcd_timing.pll_ctrl, pconf->lcd_timing.div_ctrl,pconf->lcd_timing.clk_ctrl);
+		//printk("lcd: pll_ctrl=0x%x div_ctrl=0x%x clk_ctrl=0x%x \n",
+		//	pconf->lcd_timing.pll_ctrl, pconf->lcd_timing.div_ctrl,pconf->lcd_timing.clk_ctrl);
 
 	} else {
 		pconf->lcd_timing.pll_ctrl = (0 << PLL_CTRL_OD1) |
@@ -366,6 +398,7 @@ generate_clk_done:
 	}
 }
 
+#if 0
 static void hpll_load_initial(void)
 {
 	//printk("lcd: %s\n", __func__);
@@ -391,23 +424,30 @@ static void hpll_load_initial(void)
 
 static void hpll_load_en(void)
 {
-	//printk("lcd: %s\n", __func__);
+	//printk("lcd: test: %s\n", __func__);
 	//hdmi load gen
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);
+	//printk("lcd: test2: %s\n", __func__);
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 7, 0 , 3);
+	//printk("lcd: test3: %s\n", __func__);
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 16, 3);  // tmp use fclk_div4
+	//printk("lcd: test4: %s\n", __func__);
 	aml_write_reg32(P_ENCL_VIDEO_EN, 0x1);
+	//printk("lcd: test5: %s\n", __func__);
 	//    msleep(20);
 	aml_write_reg32(P_ENCL_VIDEO_EN, 0x0);
+	//printk("lcd: test6: %s\n", __func__);
 	//    msleep(20);
 	//    printk("read Addr: 0x%x[0x%x]  Data: 0x%x\n", P_HHI_HDMI_PLL_CNTL, (P_HHI_HDMI_PLL_CNTL & 0xffff) >> 2, aml_read_reg32(P_HHI_HDMI_PLL_CNTL));
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 16, 3);  // use vid_pll
+	//printk("lcd: test7: %s\n", __func__);
 }
+#endif
 
 static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
 {
 	unsigned m, n, od1, od2, od3, frac;
-	int wait_loop = 10;
+	int wait_loop = 100;
 	unsigned pll_lock = 0;
 	unsigned pll_ctrl, pll_ctrl2;
 
@@ -430,10 +470,11 @@ static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
 	//printk("pll_ctrl : 0x%x \n",pll_ctrl | (1 << 28));
 	//printk("pll_ctrl2 : 0x%x \n",pll_ctrl2);
 
-	hpll_load_initial();
+	//hpll_load_initial();
 
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, pll_ctrl | (1 << 28));
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL2, pll_ctrl2);
+#if 0
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV)
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL5, 0x71486900);
@@ -443,9 +484,10 @@ static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
 #endif
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL6, 0x00000a55);
+#endif
 	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, pll_ctrl);
 	do {
-		hpll_load_en();
+		//hpll_load_en();
 		mdelay(10);
 		pll_lock = (aml_read_reg32(P_HHI_HDMI_PLL_CNTL) >> 31) & 0x1;
 		wait_loop--;
@@ -463,6 +505,7 @@ static void lcd_set_pll(unsigned int pll_reg, unsigned int clk_ctrl_reg)
 #endif
 }
 
+#if 0
 static unsigned int lcd_clk_div_table[][3] = {
 	/* divider,        shift_val,  shift_sel */
 	{CLK_DIV_SEL_1,    0xffff,     0,},
@@ -553,34 +596,136 @@ static void lcd_set_vclk_crt(unsigned int clk_ctrl_reg)
 
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2, 1, 3, 1);
 }
+#endif
+
+void lcd_set_hpll_pll(int hpll_clk, int hpll_od,int hpll_cntl5)
+{
+	unsigned int wait_loop = 200;
+	unsigned int pll_lock;
+
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, (hpll_clk | (1 << 28)));
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL2,hpll_od);
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL5,hpll_cntl5);
+
+	aml_write_reg32(P_HHI_HDMI_PLL_CNTL, hpll_clk & (~(1 << 28)));
+	//aml_set_reg32_bits(P_HHI_HDMI_PLL_CNTL2,od1,18,2); //no used ,bit[18:19]
+
+	//printk("Wait 10us for phy_clk stable!\n");
+	udelay(10); // delay 10uS to wait clock is stable
+
+	do {
+		udelay(50);
+		pll_lock = (aml_read_reg32(P_HHI_HDMI_PLL_CNTL) >> 31) & 0x1;
+		wait_loop--;
+	} while ((pll_lock == 0) && (wait_loop > 0));
+	if (wait_loop == 0)
+		printk("lcd: hpll lock failed\n");
+}
+
+// --------------------------------------------------
+//              clocks_set_vid_clk_div
+// --------------------------------------------------
+// wire            clk_final_en    = control[19];
+// wire            clk_div1        = control[18];
+// wire    [1:0]   clk_sel         = control[17:16];
+// wire            set_preset      = control[15];
+// wire    [14:0]  shift_preset    = control[14:0];
+void lcd_clocks_set_vid_clk_div(int div_sel)
+{
+	int shift_val = 0;
+	int shift_sel = 0;
+
+	//printk("lcd: %s[%d] div = %d\n", __func__, __LINE__, div_sel);
+	// Disable the output clock
+	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 19, 1);
+	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+
+	switch (div_sel) {
+		case CLK_DIV_SEL_1:      shift_val = 0xFFFF; shift_sel = 0; break;
+		case CLK_DIV_SEL_2:      shift_val = 0x0aaa; shift_sel = 0; break;
+		case CLK_DIV_SEL_3:      shift_val = 0x0db6; shift_sel = 0; break;
+		case CLK_DIV_SEL_3p5:    shift_val = 0x36cc; shift_sel = 1; break;
+		case CLK_DIV_SEL_3p75:   shift_val = 0x6666; shift_sel = 2; break;
+		case CLK_DIV_SEL_4:      shift_val = 0x0ccc; shift_sel = 0; break;
+		case CLK_DIV_SEL_5:      shift_val = 0x739c; shift_sel = 2; break;
+		case CLK_DIV_SEL_6:      shift_val = 0x0e38; shift_sel = 0; break;
+		case CLK_DIV_SEL_6p25:   shift_val = 0x0000; shift_sel = 3; break;
+		case CLK_DIV_SEL_7:      shift_val = 0x3c78; shift_sel = 1; break;
+		case CLK_DIV_SEL_7p5:    shift_val = 0x78f0; shift_sel = 2; break;
+		case CLK_DIV_SEL_12:     shift_val = 0x0fc0; shift_sel = 0; break;
+		case CLK_DIV_SEL_14:     shift_val = 0x3f80; shift_sel = 1; break;
+		case CLK_DIV_SEL_15:     shift_val = 0x7f80; shift_sel = 2; break;
+		case CLK_DIV_SEL_2p5:    shift_val = 0x5294; shift_sel = 2; break;
+		default:
+		printk("lcd error: clocks_set_vid_clk_div:  Invalid parameter\n");
+		break;
+	}
+
+	if (shift_val == 0xffff ) {      // if divide by 1
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 18, 1);
+	} else {
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 16, 2);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 0, 14);
+
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_sel, 16, 2);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 15, 1);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, shift_val, 0, 14);
+		aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 0, 15, 1);
+	}
+	// Enable the final output clock
+	aml_set_reg32_bits(P_HHI_VID_PLL_CLK_DIV, 1, 19, 1);
+}
+
+void lcd_set_crt_video_enc(int vIdx, int inSel, int DivN)
+{
+	if (vIdx == 0) { //V1
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+		udelay(2);
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, inSel,   16, 3); // [18:16] - cntl_clk_in_sel
+		aml_set_reg32_bits(P_HHI_VID_CLK_DIV, (DivN-1), 0, 8); // [7:0]   - cntl_xd0
+		udelay(5);
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1);//[19] -enable clk_div0
+	} else { //V2
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+		udelay(2);
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, inSel,  16, 3); // [18:16] - cntl_clk_in_sel
+		aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, (DivN-1),0, 8); // [7:0]   - cntl_xd0
+		udelay(5);
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
+	}
+	udelay(5);
+}
+
+void lcd_enable_crt_video_encl(int enable, int inSel)
+{
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV,inSel,  12, 4); //encl_clk_sel:hi_viid_clk_div[15:12]
+
+	if (inSel <= 4) //V1
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL,1, inSel, 1);
+	else
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL,1, (inSel-5),1);
+
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2,enable, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
+}
 
 void set_vclk_lcd(Lcd_Config_t *pconf)
 {
 	unsigned pll_reg, div_reg, clk_reg;
-	int xd;
-	int lcd_type;
+	int div, xd;
 
 	pll_reg = pconf->lcd_timing.pll_ctrl;
 	div_reg = pconf->lcd_timing.div_ctrl;
 	clk_reg = pconf->lcd_timing.clk_ctrl;
+	div = (div_reg >> DIV_CTRL_CLK_DIV) & 0xff;
 	xd = (clk_reg >> CLK_CTRL_XD) & 0xff;
 
-	lcd_type = pconf->lcd_basic.lcd_type;
-
-	switch (lcd_type) {
-	case LCD_DIGITAL_LVDS:
-		xd = 1;
-		break;
-	default:
-		break;
-	}
-
-	clk_reg = (pconf->lcd_timing.clk_ctrl & ~(0xff << CLK_CTRL_XD)) |
-		(xd << CLK_CTRL_XD);
-
 	lcd_set_pll(pll_reg, clk_reg);
-	lcd_set_clk_div(div_reg);
-	lcd_set_vclk_crt(clk_reg);
+	//lcd_set_clk_div(div_reg);
+	//lcd_set_vclk_crt(clk_reg);
+	//lcd_clocks_set_vid_clk_div(div);
+	//lcd_set_crt_video_enc(0, 0, xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	//lcd_enable_crt_video_encl(1, 0); //select and enable the output
 }
 
 void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode)
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
index f91d4805b60f..55bb52f7f4ea 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lcd_common.h
@@ -91,7 +91,7 @@ enum div_sel_e {
 #define OD_SEL_MAX			3
 
 void lcd_clocks_set_vid_clk_div(int div_sel);
-int set_hpll_pll(int freq, int od1,int hdmi_pll_cntl5);
+void lcd_set_hpll_pll(int hpll_clk, int hpll_od,int hpll_cntl5);
 void lcd_set_crt_video_enc(int vIdx, int inSel, int DivN);
 void lcd_enable_crt_video_encl(int enable, int inSel);
 void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode);
@@ -99,7 +99,7 @@ void _enable_vsync_interrupt(void);
 
 void generate_clk_parameter(Lcd_Config_t *pconf);
 void set_vclk_lcd(Lcd_Config_t *pconf);
-void lcd_set_clk_div(unsigned long vid_div_reg);
+//void lcd_set_clk_div(unsigned int vid_div_reg);
 
 void _disable_display_driver(void);
 void lcd_test(unsigned int num, struct aml_lcd *pDev);
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
index 49a5aadf97fd..4f217e16fc5e 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/lvds_drv.c
@@ -28,7 +28,7 @@
 static void set_tcon_lvds(Lcd_Config_t *pConf)
 {
 	vpp_set_matrix_ycbcr2rgb(2, 0);
-	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 3);
+	//aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 3);
 	aml_write_reg32(P_L_RGB_BASE_ADDR, 0);
 	aml_write_reg32(P_L_RGB_COEFF_ADDR, 0x400);
 
@@ -44,19 +44,46 @@ static void set_tcon_lvds(Lcd_Config_t *pConf)
 
 static void init_phy_lvds(Lcd_Config_t *pConf)
 {
-	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
-	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
-	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+	//aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	//aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	//aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
 
-	aml_write_reg32(P_LVDS_PHY_CNTL0, 0xffff);
-	aml_write_reg32(P_LVDS_PHY_CNTL1, 0xff00);
-	aml_write_reg32(P_LVDS_PHY_CNTL4, 0x007f);
+	//aml_write_reg32(P_LVDS_PHY_CNTL0, 0xffff);
+	//aml_write_reg32(P_LVDS_PHY_CNTL1, 0xff00);
+	//aml_write_reg32(P_LVDS_PHY_CNTL4, 0x007f);
 
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
 	//od   clk 1039.5 / 2 = 519.75 = 74.25*7
-	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
+	//aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
+}
+
+static void set_lvds_clk_util(Lcd_Config_t *pConf)
+{
+	unsigned int fifo_mode, phy_div;
+
+	if (pConf->lcd_control.lvds_config->dual_port) {
+		fifo_mode = 0x3;
+		phy_div = 2;
+	} else {
+		fifo_mode = 0x1;
+		phy_div = 1;
+	}
+
+	aml_write_reg32(P_LVDS_GEN_CNTL, (aml_read_reg32(P_LVDS_GEN_CNTL)| (1 << 4) | (fifo_mode << 0)));
+	aml_set_reg32_bits(P_LVDS_GEN_CNTL, 1, 3, 1);
+
+	/* set fifo_clk_sel: div 7 */
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, (1 << 6));
+	/* set cntl_ser_en:  8-channel to 1 */
+	aml_set_reg32_bits(P_HHI_LVDS_TX_PHY_CNTL0, 0xfff, 16, 12);
+
+	/* decoupling fifo enable, gated clock enable */
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,
+		(1 << 30) | ((phy_div - 1) << 25) | (1 << 24));
+	/* decoupling fifo write enable after fifo enable */
+	aml_set_reg32_bits(P_HHI_LVDS_TX_PHY_CNTL1, 1, 31, 1);
 }
 
 static void set_control_lvds(Lcd_Config_t *pConf)
@@ -65,43 +92,44 @@ static void set_control_lvds(Lcd_Config_t *pConf)
 	unsigned int pn_swap = 0;
 	unsigned int dual_port = 1;
 	unsigned int lvds_repack = 1;
-	unsigned int port_reverse = 1;
+	unsigned int port_swap = 0;
+
+	set_lvds_clk_util(pConf);
 
 	lvds_repack = (pConf->lcd_control.lvds_config->lvds_repack) & 0x1;
-	pn_swap		= (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
-	dual_port	= (pConf->lcd_control.lvds_config->dual_port) & 0x1;
-	port_reverse= (pConf->lcd_control.lvds_config->port_reverse) & 0x1;
+	pn_swap   = (pConf->lcd_control.lvds_config->pn_swap) & 0x1;
+	dual_port = (pConf->lcd_control.lvds_config->dual_port) & 0x1;
+	port_swap = (pConf->lcd_control.lvds_config->port_swap) & 0x1;
 	switch (pConf->lcd_control.lvds_config->lvds_bits) {
-		case 10:
-			bit_num=0;
-			break;
-		case 8:
-			bit_num=1;
-			break;
-		case 6:
-			bit_num=2;
-			break;
-		case 4:
-			bit_num=3;
-			break;
-		default:
-			bit_num=1;
-			break;
+	case 10:
+		bit_num=0;
+		break;
+	case 8:
+		bit_num=1;
+		break;
+	case 6:
+		bit_num=2;
+		break;
+	case 4:
+		bit_num=3;
+		break;
+	default:
+		bit_num=1;
+		break;
 	}
 
-	aml_write_reg32(P_MLVDS_CONTROL,  (aml_read_reg32(P_MLVDS_CONTROL) & ~(1 << 0)));  //disable mlvds
 	aml_write_reg32(P_LVDS_PACK_CNTL_ADDR,
-					( lvds_repack<<0 ) | // repack
-					( port_reverse?(0<<2):(1<<2)) | // odd_even
-					( 0<<3 ) |			// reserve
-					( 0<<4 ) |			// lsb first
-					( pn_swap<<5 ) |	// pn swap
-					( dual_port<<6 ) |	// dual port
-					( 0<<7 ) |			// use tcon control
-					( bit_num<<8 ) |	// 0:10bits, 1:8bits, 2:6bits, 3:4bits.
-					( 0<<10 ) |			//r_select  //0:R, 1:G, 2:B, 3:0
-					( 1<<12 ) |			//g_select  //0:R, 1:G, 2:B, 3:0
-					( 2<<14 ));			//b_select  //0:R, 1:G, 2:B, 3:0;
+			( lvds_repack << 0 ) | // repack
+			( port_swap << 2) | // odd_even
+			( 0 << 3 ) |			// reserve
+			( 0 << 4 ) |			// lsb first
+			( pn_swap << 5 ) |	// pn swap
+			( dual_port << 6 ) |	// dual port
+			( 0 << 7 ) |			// use tcon control
+			( bit_num << 8 ) |	// 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+			( 0 << 10 ) |			//r_select  //0:R, 1:G, 2:B, 3:0
+			( 1 << 12 ) |			//g_select  //0:R, 1:G, 2:B, 3:0
+			( 2 << 14 ));			//b_select  //0:R, 1:G, 2:B, 3:0;
 }
 
 static void set_venc_lvds(Lcd_Config_t *pConf)
@@ -131,7 +159,7 @@ static void set_venc_lvds(Lcd_Config_t *pConf)
 	aml_write_reg32(P_ENCL_VIDEO_VSO_END,		pConf->lcd_timing.stv1_he_addr);
 	aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,		pConf->lcd_timing.stv1_vs_addr);
 	aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,		pConf->lcd_timing.stv1_ve_addr);
-	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 	0);
+	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 	3);
 
 	// enable encl
 	aml_write_reg32(P_ENCL_VIDEO_EN, 1);
@@ -146,40 +174,19 @@ static void venc_change_lvds(Lcd_Config_t *pConf)
 	lcd_notifier_call_chain(LCD_EVENT_BL_UPDATE, NULL);
 }
 
-static void set_pll_lvds(Lcd_Config_t *pConf)
+static void set_clk_lvds(Lcd_Config_t *pConf)
 {
-	unsigned int sw_port 	= (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0x100;
-	unsigned int lvds_fifo = (pConf->lcd_control.lvds_config->lvds_fifo_wr_mode)&0xff;
-	unsigned int vx1_phy_div;
-	unsigned int lvds_ports ;
-
-	generate_clk_parameter(pConf);
-	//printk("pll_ctrl=0x%x, div_ctrl=0x%x, clk_ctrl=0x%x.\n",
-	//	pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl,
-	//	pConf->lcd_timing.clk_ctrl);
-	set_vclk_lcd(pConf);
-
-	lvds_ports = pConf->lcd_control.lvds_config->dual_port;
-	if (lvds_ports < 2) {
-		vx1_phy_div  = 2/2;
-		//encl_div	 = vx1_phy_div*7;
-		if (lvds_ports == 1) //dual port
-			vx1_phy_div = vx1_phy_div*2;
-	}else if (lvds_ports >= 2) {
-		TV_LCD_ERR("lcd error :Quad-LVDS is not supported!\n");
-		return;
+	if (pConf->lcd_timing.clk_auto) {
+		generate_clk_parameter(pConf);
+		set_vclk_lcd(pConf);
+	} else {
+		lcd_set_hpll_pll(pConf->lcd_timing.hpll_clk, pConf->lcd_timing.hpll_od, pConf->lcd_timing.hdmi_pll_cntl5);
+		//lcd_clocks_set_vid_clk_div(CLK_DIV_SEL_7);
+		//lcd_set_crt_video_enc(0, 0, 1);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+		//lcd_enable_crt_video_encl(1, 0); //select and enable the output
 	}
-
-	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((vx1_phy_div-1)<<1)|1)<<24);
-
-	if ( sw_port == 0x100 )
-		aml_write_reg32( P_HHI_VIID_DIVIDER_CNTL, ((aml_read_reg32(P_HHI_VIID_DIVIDER_CNTL) & ~(0x7 << 8)) | (1 << 8) | (0<<10)));
-	else
-		aml_write_reg32( P_HHI_VIID_DIVIDER_CNTL, ((aml_read_reg32(P_HHI_VIID_DIVIDER_CNTL) & ~(0x7 << 8)) | (2 << 8) | (0<<10)));
-	aml_write_reg32(P_LVDS_GEN_CNTL, (aml_read_reg32(P_LVDS_GEN_CNTL)| (1 << 3) | (lvds_fifo << 0)));
 }
 
-
 unsigned int  lvds_init(struct aml_lcd *pDev)
 {
 	TV_LCD_INFO("lvds mode is selected\n");
@@ -188,7 +195,7 @@ unsigned int  lvds_init(struct aml_lcd *pDev)
 
 	switch (pDev->pConf->lcd_timing.frame_rate_adj_type) {
 	case 0: /* clk adjust */
-		set_pll_lvds(pDev->pConf);
+		set_clk_lvds(pDev->pConf);
 		set_venc_lvds(pDev->pConf);
 		set_tcon_lvds(pDev->pConf);
 		set_control_lvds(pDev->pConf);
diff --git a/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c b/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
index 11ebde98af0d..72a90e075e10 100644
--- a/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
+++ b/drivers/amlogic/display/lcd/aml_tv_lcd_port/vbyone_drv.c
@@ -84,17 +84,17 @@ static void set_tcon_vbyone(Lcd_Config_t *pConf)
 
 static void init_vbyone_phy(Lcd_Config_t *pConf)
 {
-	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
-	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
-	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+	//aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	//aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	//aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
 
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6e0ec918);
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x00000a7c);
 	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x00ff0800);
 	//od   clk 2970 / 5 = 594
-	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0xfff00c0);
+	//aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0xfff00c0);
 	//clear lvds fifo od (/2)
-	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1, 0xc1000000);
+	//aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1, 0xc1000000);
 }
 
 void set_vbyone_ctlbits(int p3d_en, int p3d_lr, int mode)
@@ -260,7 +260,7 @@ static void set_control_vbyone(Lcd_Config_t *pConf)
 
 	//PIN_MUX for VX1 need to add this to dtd
 
-	// printf("Set VbyOne PIN MUX ......\n");
+	// printk("Set VbyOne PIN MUX ......\n");
 	// aml_set_reg32_bits(P_PERIPHS_PIN_MUX_3,3,8,2);
 
 	// set Vbyone
@@ -369,6 +369,7 @@ static void venc_change_vbyone(Lcd_Config_t *pConf)
 	lcd_notifier_call_chain(LCD_EVENT_BL_UPDATE, NULL);
 }
 
+#if 0
 //clock seting for VX1
 static void set_pll_vbyone(Lcd_Config_t *pConf)
 {
@@ -427,14 +428,14 @@ static void set_pll_vbyone(Lcd_Config_t *pConf)
 	if (phy_div == 8) {
 		phy_div = phy_div/2;
 		//if(hdmi_vx1_clk_od1 != 0) {
-		//	printf("VX1 cannot support this configuration!\n");
+		//	printk("VX1 cannot support this configuration!\n");
 		//	return;
 		//}
 		// hdmi_vx1_clk_od1=1;
 	}
 	//need check whether we need to set this dpll !!!!!!!
 	//if (set_hdmi_dpll(hdmi_clk_out,hdmi_vx1_clk_od1)){
-	//   printf("Unsupported HDMI_DPLL out frequency!\n");
+	//   printk("Unsupported HDMI_DPLL out frequency!\n");
 	//    return;
 	//}
 
@@ -466,7 +467,7 @@ static void set_pll_vbyone(Lcd_Config_t *pConf)
 	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((phy_div-1)<<1)|1)<<24);
 
 	//configure crt_video
-	//set_crt_video_enc(0, 0, xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	//lcd_set_crt_video_enc(0, 0, xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
 	//if (vidx == 0)
 	{ //V1
 		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
@@ -494,6 +495,7 @@ static void set_pll_vbyone(Lcd_Config_t *pConf)
 
 	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2, 1, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
 }
+#endif
 
 static unsigned int vbyone_lane_num[] = {
 	1,
@@ -536,7 +538,12 @@ static void set_vbyone_config(Lcd_Config_t *pConf)
 		printk("change to min lane_num %d\n", minlane);
 	}
 
-	bit_rate = band_width / lane_count;
+	bit_rate = band_width / minlane;//band_width / lane_count;
+	phy_div = lane_count / minlane;
+	if (phy_div == 8) {
+		phy_div/= 2;
+		bit_rate /= 2;
+	}
 	if (bit_rate > (VBYONE_BIT_RATE_MAX * 1000)) {
 		printk("[error]:vbyone bit rate(%dKHz) is out of max range(%dKHz)\n",
 			bit_rate, (VBYONE_BIT_RATE_MAX * 1000));
@@ -547,17 +554,13 @@ static void set_vbyone_config(Lcd_Config_t *pConf)
 	}
 	bit_rate = bit_rate * 1000; /* Hz */
 
-	phy_div = lane_count / minlane;
-	if (phy_div == 8) {
-		phy_div/= 2;
-		bit_rate /= 2;
-	}
 	pConf->lcd_control.vbyone_config->phy_div = phy_div;
 	pConf->lcd_control.vbyone_config->bit_rate = bit_rate;
 	//printk("lane_count=%u, bit_rate = %uMHz, clk=%u.%03uMhz\n",
 	//	lane_count, (bit_rate / 1000000), (pclk / 1000), (pclk % 1000));
 }
 
+#if 0
 static void adjust_vx1_pll_by_parameters(Lcd_Config_t *pConf)
 {
 	unsigned int pll_ctrl, clk_ctrl;
@@ -617,14 +620,27 @@ static void adjust_vx1_pll_by_bit_rate(unsigned int bit_rate)
 	if (wait_loop == 0)
 		printk("[error]: hpll lock failed\n");
 }
+#endif
 
 #define VX1_PLL_ADJUST		1
 static void set_clk_vbyone(Lcd_Config_t *pConf)
 {
+#if 0
 	unsigned int bit_rate;
 
 	bit_rate = pConf->lcd_control.vbyone_config->bit_rate / 1000000;
 	//printk("bit rate change to %dMHz\n", bit_rate);
+#endif
+	if (pConf->lcd_timing.clk_auto) {
+		generate_clk_parameter(pConf);
+		set_vclk_lcd(pConf);
+	} else {
+		lcd_set_hpll_pll(pConf->lcd_timing.hpll_clk, pConf->lcd_timing.hpll_od, pConf->lcd_timing.hdmi_pll_cntl5);
+		//lcd_clocks_set_vid_clk_div(CLK_DIV_SEL_5);
+		//lcd_set_crt_video_enc(0, 0, 1);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+		//lcd_enable_crt_video_encl(1, 0); //select and enable the output
+	}
+#if 0
 	if (VX1_PLL_ADJUST) {
 		generate_clk_parameter(pConf);
 		adjust_vx1_pll_by_parameters(pConf);
@@ -632,6 +648,7 @@ static void set_clk_vbyone(Lcd_Config_t *pConf)
 		adjust_vx1_pll_by_bit_rate(bit_rate);
 	}
 	set_pll_vbyone(pConf);
+#endif
 }
 
 unsigned int vbyone_init(struct aml_lcd *pDev)
-- 
2.19.0

